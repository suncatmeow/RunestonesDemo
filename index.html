<!DOCTYPE html>
  <html>
    <head>
      <meta charset="utf-8"/>
      <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
      <title>Battle-Mage</title>
      <style>
        html,body {
          width:100%;
          height: 100%;
          margin: 0px;
          border: 0;
          overflow: hidden;
          display:block;
                 touch-action: none;             
          -webkit-user-select: none;      
          user-select: none;
          -webkit-tap-highlight-color: transparent;
        }
      </style>
    </head>
    <body>
<canvas id ="c" style = "position:absolute; left:0px; top:0px;"></canvas>
<script>
//////////////////////[VARIABLE DECLARATIONS]///////////////////////////
var canvas = document.getElementById("c");
var ctx = canvas.getContext("2d");
var wX = 0; //window length
var wY = 0; //window height
var tL = 0; //table length
var tH = 0; //table height
var tX = 0; //table top-left x coordinate(0,0)
var tY = 0; //table top-left x coordinate(0,0)
var cc = 0; //hand counter
var startGame = 0;
var timer = 0;
var s = 0;
var t = '';
var test1 = -22;
let lastTriggerTime = Date.now();
let lastTriggerTime2 = Date.now();
let lastSongTime = Date.now();
let lastTouchTime = 0;
let lastrandom = rnd(0,21);
const eIMG = {BLANK:0,LOGO:1,HEART:2,CHEST:3,TOME:4,SWORD:5,SHIELD:6,STAFF:7,WBOOT:8,GOBLIN:9}
const eLOOK = {F:0,D:1,M:2,H:3,A:4,R:5,S:6,STAT:7,INDEX:8}//field,deck,monster,hand,action,roll,stone
const eSTAT = {S:0,C:1,I:2,A:3}
const eDICE = {MIN:0, MAX:1, MOD:2,TXT:3}
const eTYPE = {MONSTER:0,ITEM:1,SPELL:2,NULL:3}
const eSUBTYPE = {NONE:0, EFFECT:1, USE:2, EQUIP:3,TREASURE:4}
var cL = 2.25; //card length
var cH = 3.5; //card height

var cY = 6.5;//card y
var arY = cY + 1.3; //arrow y
var abY = cY -.77; //action button Y
var aLH = .57; // hand arrow height and length

var hX = .875;//hand x
var halX = hX -.35;//hand l arrow x
var harX = hX+2.04;//hand r arrow x
var huX = hX *.96; //hand use x
var heX = hX + cL / 1.39; //hand examine x

var mX = 3.875; //monster x
var malX = mX -.35;//monster l arrow x
var marX = mX + 2.04;//monster r arrow x
var maX = mX * .99; //monstermonster attack x
var meX = mX + cL / 1.39; //monsterexamine x

  
var actLH = .66; //use/examine/attack button LH
var actY = cY - actLH-.16;//use/examine/attack Y
let lastFrameTime = Date.now();
let coinanix = 5;
let coinaniy = 5;
let coinaniz = 1;
let coinanir = 1;
let coinswitch = 0;
let debug = 0;


resizeCanvas(); //INITIALIZE CANVAS
//////////////////////[CLASS DECLARATIONS]///////////////////////////
class NPC {
  constructor(x, y, type, state = 'wandering') {
    this.x = x;
    this.y = y;
    this.type = type; 
    this.color = '#ff0000'; 
    this.visible = true; 

    this.dirX = Math.random() - 0.5;
    this.dirY = Math.random() - 0.5;
    this.speed = 0.02; 
    this.radius = 0.1;
    // --- NEW: 3D MODEL LOGIC ---
    this.model = null;
    this.bobOffset = 0; // For the up/down animation
    this.zHeight = 0;   // Height from floor

    if (this.type === 'Fire Elemental') {
        this.model = new Dice('d4');
        
        // Base color (Inner core of the fire)
        this.model.setColor(1, 0.5, 0); 
        
        // Glow color (Outer halo - Orange/Red)
        this.model.setGlow('#ff4400'); 
        
        this.model.rs = 0.05; 
        this.state = 'wandering';
    }
  
    // Set the initial state (can now be 'stationary')
    this.state = state; 
  }

  checkCollision(maze, x, y) {
    const points = [
        {x: x + this.radius, y: y}, 
        {x: x - this.radius, y: y}, 
        {x: x, y: y + this.radius}, 
        {x: x, y: y - this.radius}  
    ];
    for (let p of points) {
        if (maze[Math.floor(p.y)][Math.floor(p.x)] > 0) return true;
    }
    return false;
  }

  triggerInteraction(dungeon) {
    //battle
     if (this.type === 1) {
      dungeon.npcs.forEach(npc => npc.visible = false);
        
        dungeon.currentEnemy = this; 
        
        if (startGame !== 'battle') {
           console.log("Monster Caught you! Starting Battle...");
           startGame = 'battle'; 
           if(typeof MusicEngine !== 'undefined') MusicEngine.playSFX('slash'); 

           // --- NEW: ROTATE TO FACE OPEN SPACE ---
           // This ensures we aren't staring at a wall when the battle starts
           for (let i = 0; i < 4; i++) {
               let targetX = Math.floor(dungeon.x);
               let targetY = Math.floor(dungeon.y);

               // Check the tile directly in front of current direction
               if (dungeon.dir === 0) targetY -= 1;      // North
               else if (dungeon.dir === 1) targetX += 1; // East
               else if (dungeon.dir === 2) targetY += 1; // South
               else if (dungeon.dir === 3) targetX -= 1; // West

               // If it's NOT a wall, we are good! Stop rotating.
               if (!dungeon.isWall(targetX, targetY)) {
                   break; 
               }

               // If it IS a wall, turn right (clockwise) and try again
               dungeon.dir = (dungeon.dir + 1) % 4;
           }
           // -------------------------------------
        }
     }
     else if (this.type === 2) {
         console.log("Welcome to the shop!");
     }
     else {
         if (this.state !== 'stationary') this.state = 'wandering';
     }
  }
  startDialogue(dungeon) {
      dungeon.npcs.forEach(npc => npc.visible = false);
      dungeon.currentSpeaker = this;
      console.log("Starting dialogue...");
      startGame = 'dialogue';
      if(typeof MusicEngine !== 'undefined') MusicEngine.playSFX('click');
  }
  
  update(maze, playerX, playerY, dungeon) {
    // 1. Calculate distance
    const diffX = playerX - this.x;
    const diffY = playerY - this.y;
    const dist = Math.sqrt(diffX*diffX + diffY*diffY);
    
    if (startGame === 'explore' && dist > 1.5) this.visible = true;

    // Normalized vector to player
    const toPlayerX = diffX / dist;
    const toPlayerY = diffY / dist;
    const dotProd = (this.dirX * toPlayerX) + (this.dirY * toPlayerY);
    
    // --- 2. Vision / State Logic ---
    // We strictly guard this so Stationary NPCs rarely change state
    if (this.state !== 'stationary') {
        if (dist < 5 && dotProd > 0.6) {
           if (this.type === 1) this.state = 'chasing'; 
           else this.state = 'wandering';
        } else if (dist > 7) {
           this.state = 'wandering';
        }
    } else {
        // OPTIONAL: If stationary and player is close, face the player
        if (dist < 4) {
            this.dirX = toPlayerX;
            this.dirY = toPlayerY;
        }
    }

    // --- 3. Movement Calculations ---
    
    // If Chasing, update direction to player
    if (this.state === 'chasing') {
        this.dirX = toPlayerX;
        this.dirY = toPlayerY;
    } 

    // Proximity Trigger (Keep this for all types!)
    if (dist < 0.6) { 
        this.triggerInteraction(dungeon); 
        
        // Only bounce if NOT stationary
        if (this.state !== 'stationary') {
            this.dirX = -toPlayerX + (Math.random() - 0.5); 
            this.dirY = -toPlayerY + (Math.random() - 0.5);
        }
    }
// --- NEW: UPDATE 3D MODEL ---
     if (this.model) {
         // 1. Rotate the model
         // We manually step the rotation so it spins even if stationary
         this.model.rx += 0.05; 
         this.model.ry += 0.03;

         // 2. Calculate Bobbing (Sine wave)
         this.bobOffset += 0.1; 
         // Oscillate between height 0 and 0.2
         this.zHeight = Math.abs(Math.sin(this.bobOffset)) * 0.2; 
     }
    // --- 4. Apply Movement ---
    // CORE CHANGE: Entire movement block is skipped if stationary
    if (this.state !== 'stationary') {
        const newX = this.x + (this.dirX * this.speed);
        const newY = this.y + (this.dirY * this.speed);

        if (this.checkCollision(maze, newX, newY)) {
           if (this.state === 'wandering') {
               this.dirX = Math.random() - 0.5;
               this.dirY = Math.random() - 0.5;
           } else {
               if (!this.checkCollision(maze, newX, this.y)) this.x = newX;
               else if (!this.checkCollision(maze, this.x, newY)) this.y = newY;
           }
        } else {
           this.x = newX;
           this.y = newY;
        }
    } // End of stationary check
    
    // Normalize vector (Keep this to ensure rendering works correctly)
    const length = Math.sqrt(this.dirX*this.dirX + this.dirY*this.dirY);
    if(length !== 0) {
        this.dirX /= length;
        this.dirY /= length;
    }
  }
}
class Explore {
  constructor() {
    this.card= [];
    this.card[0] = new Card(2, 0);//hp
    this.card[1] = new Card(0, 0);//fool
    this.card[2] = new Card(6, 0);//lovers
    this.card[3] = new Card(8, 0)//str
    this.card[4] = new Card(13, 0)//death
    this.at = 0;
    this.az = 0;
    this.ay = 0;
    this.reroll = 0;
    this.tutorialFinished = 0;
    this.option = 0;
    this.mc = 0;
    this.npcs = [
    new NPC(7.5, 5.5, 2,'stationary'),//north high priestess
    new NPC(1.5, 1.5, 9.1),//west
    new NPC(7.5, 9.5, 3,'stationary'),//south
    new NPC(5.5, 7.5, 4,'stationary'),//south
    new NPC(9.5, 7.5, 5,'stationary'),//east
    //new NPC(1.5, 1.5, 3)
];
    this.dCounter = 0;
    this.x = 7.5;
    this.y = 7.5;
    this.dir = 0; 
    this.frame = 0;
    this.currentEnemy = null;
    this.currentSpeaker = null; // NEW: Track who we are talking to
    this.clickInput = null;
    // Map Data
    this.maze = [
      [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
      [1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1],
      [1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1],
      [1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1],
      [1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1],
      [1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1],
      [1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1],
      [1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1],
      [1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1],
      [1, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 1],
      [1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1],
      [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1],
      [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
    ];

    
    
    // Initialize Z-Buffer (Depth Buffer)
    this.zBuffer = []; 
  }
  registerClick(x, y) {
      this.clickInput = { x: x, y: y };
  }
  isWall(mapX, mapY) {
    if (mapX < 0 || mapX >= this.maze[0].length || mapY < 0 || mapY >= this.maze.length) return true;
    return this.maze[mapY][mapX] > 0;
  }
  canInteract() {
    // 1. Get Player Direction Vector based on current Dir (0,1,2,3)
    const angle = this.dir * Math.PI / 2;
    const pDirX = Math.sin(angle);
    const pDirY = -Math.cos(angle);

    for (let npc of this.npcs) {
        // Only care about Type 0 (Civilian/Talkable)
        if (npc.type !== 2||npc.type !== 4||npc.type!==5) continue; 
        if (!npc.visible) continue;

        const diffX = npc.x - this.x;
        const diffY = npc.y - this.y;
        const dist = Math.sqrt(diffX*diffX + diffY*diffY);

        // If NPC is very close (within 1.5 blocks)
        if (dist < 1.5) {
            // Check if NPC is in front of Player (Dot Product)
            const normX = diffX / dist;
            const normY = diffY / dist;
            // Dot product of PlayerDir vs VectorToNPC
            const dot = pDirX * normX + pDirY * normY;

            // If dot > 0.7, the NPC is roughly within a 45-degree cone in front of us
            if (dot > 0.7) return true;
        }
    }
    return false;
  }
  render() {
    this.frame++;
    this.npcs.forEach(npc => npc.update(this.maze, this.x, this.y, this));
    //0=N, 1=E, 2=S, 3=W

    // 2. Read Global Table Dimensions (from your resizeCanvas)
    // Safety check: if tL is 0 (first frame), default to 400 to prevent errors
    const viewW = (tL > 0) ? tL : 400;
    const viewH = (tH > 0) ? tH : 400;
    const viewX = tX; // Top-left X
    const viewY = tY; // Top-left Y

    // Reset Z-Buffer for this frame
    this.zBuffer = new Array(viewW).fill(0);

    // 3. Draw Background (Floor/Ceiling)
    const grad = ctx.createLinearGradient(0, viewY, 0, viewY + viewH);
    grad.addColorStop(0, '#0d0a05'); 
    grad.addColorStop(0.5, '#0d0a05');
    grad.addColorStop(1, '#1a150a'); 
    ctx.fillStyle = grad;
    ctx.fillRect(viewX, viewY, viewW, viewH);

    // 4. Raycasting Variables
    const angle = this.dir * Math.PI / 2;
    const dirX = Math.sin(angle);
    const dirY = -Math.cos(angle);
    const planeX = dirY * 0.66;
    const planeY = -dirX * 0.66;

    // 5. Cast Rays for Walls
    for (let x = 0; x < viewW; x++) {
      const cameraX = 2 * x / viewW - 1;
      const rayDirX = dirX + planeX * cameraX;
      const rayDirY = dirY + planeY * cameraX;
      
      this.castWallRay(rayDirX, rayDirY, x, viewX, viewY, viewW, viewH);
    }

    // 6. Draw Sprites (NPCs)
    this.drawSprites(ctx, viewX, viewY, viewW, viewH, dirX, dirY, planeX, planeY);

    // 7. Draw Minimap
    this.drawMinimap(ctx, viewX, viewY, viewW, viewH);
    
  }
  castWallRay(rayDirX, rayDirY, stripX, viewX, viewY, viewW, viewH) {
    let mapX = Math.floor(this.x);
    let mapY = Math.floor(this.y);
    const deltaDistX = Math.abs(1 / rayDirX);
    const deltaDistY = Math.abs(1 / rayDirY);
    let stepX, stepY, sideDistX, sideDistY;

    if (rayDirX < 0) { stepX = -1; sideDistX = (this.x - mapX) * deltaDistX; }
    else { stepX = 1; sideDistX = (mapX + 1 - this.x) * deltaDistX; }
    if (rayDirY < 0) { stepY = -1; sideDistY = (this.y - mapY) * deltaDistY; }
    else { stepY = 1; sideDistY = (mapY + 1 - this.y) * deltaDistY; }

    let hit = 0, side;
    while (!hit) {
      if (sideDistX < sideDistY) { sideDistX += deltaDistX; mapX += stepX; side = 0; }
      else { sideDistY += deltaDistY; mapY += stepY; side = 1; }
      if (this.isWall(mapX, mapY)) hit = 1;
    }

    let perpWallDist;
    if (side === 0) perpWallDist = (mapX - this.x + (1 - stepX) / 2) / rayDirX;
    else perpWallDist = (mapY - this.y + (1 - stepY) / 2) / rayDirY;

    // --- Z-BUFFER STORAGE ---
    // Store the distance to the wall at this screen column (stripX)
    this.zBuffer[stripX] = perpWallDist;

    const lineHeight = viewH / perpWallDist;
    const drawStart = Math.max(0, -lineHeight / 2 + viewH / 2);
    const drawEnd = Math.min(viewH, lineHeight / 2 + viewH / 2);

    // Color logic
    let shade = Math.min(255, 150 / (perpWallDist + 0.5));
    if (side === 1) shade *= 0.7;
    const r = Math.floor(shade * 0.6);
    const g = Math.floor(shade * 0.4);
    const b = Math.floor(shade * 0.3);
    ctx.fillStyle = `rgb(${r},${g},${b})`;

    // --- DRAWING FIX ---
    // Changed from (viewW - stripX) to (stripX). 
    // This ensures left rays are drawn on the left, matching the sprite math.
    ctx.fillRect(viewX + stripX, viewY + drawStart, 1, drawEnd - drawStart);
  }
//SET DIALOGUE CHARACTERS HERE TRIGGERED ON CLICK
  drawSprites(ctx, viewX, viewY, viewW, viewH, dirX, dirY, planeX, planeY) {
    // 1. Sort NPCs (Painter's Algorithm)
    this.npcs.forEach(npc => {
        npc.dist = ((this.x - npc.x) * (this.x - npc.x) + (this.y - npc.y) * (this.y - npc.y));
    });
    this.npcs.sort((a, b) => b.dist - a.dist);

    // 2. Loop through NPCs
    for (let i = 0; i < this.npcs.length; i++) {
        const sprite = this.npcs[i];
        if (!sprite.visible) continue;
        // Transform sprite position to camera space
        const spriteX = sprite.x - this.x;
        const spriteY = sprite.y - this.y;

        const invDet = 1.0 / (planeX * dirY - dirX * planeY); 
        const transformX = invDet * (dirY * spriteX - dirX * spriteY);
        const transformY = invDet * (-planeY * spriteX + planeX * spriteY); // Depth

        if (transformY <= 0.1) continue; // Behind player

        // Screen X position
       
        const spriteScreenX = Math.floor((viewW / 2) * (1 + transformX / transformY));
        const spriteSize = Math.abs(Math.floor(viewH / transformY)); 
         const yOffset = (sprite.zHeight || 0) * spriteSize;
        const drawStartY = Math.floor(-spriteSize / 2 + viewH / 2 + viewY - yOffset);
        const drawStartX = Math.floor(-spriteSize / 2 + spriteScreenX + viewX);

        // --- NEW: 3D RENDER BRANCH ---
        if (sprite.model) {
            // Check visibility: Look at the Z-Buffer at the center of the sprite
            // If the wall is closer than the sprite, don't draw it.
            // (Simple center-point occlusion check)
            if (spriteScreenX > 0 && spriteScreenX < viewW) {
                if (transformY < this.zBuffer[spriteScreenX]) {
                    
                    // We call the model's draw function directly
                    // viewX/Y + screen coords gives us the center point
                    const centerX = drawStartX + spriteSize / 2;
                    const centerY = drawStartY + spriteSize / 2;

                    // Pass context, center X, center Y, Scale, and FOV factor (4 is standard)
                    // We multiply spriteSize by 0.5 to fit it inside the "box"
                    sprite.model.draw(ctx, centerX, centerY, spriteSize * 0.5, 4);
                }
            }
            // Skip the rest of the 2D drawing logic for this loop iteration
            continue; 
        }
        if (drawStartX > viewX + viewW || drawStartX + spriteSize < viewX) continue;

        // --- NEW: FACE CHECK ---
        // Vector from NPC to Player (Player Pos - NPC Pos)
        // Note: we use 'this.x' (player) and 'sprite.x' (npc)
        const toPlayerX = this.x - sprite.x;
        const toPlayerY = this.y - sprite.y;

        // Dot Product: (NPCDirX * ToPlayerX) + (NPCDirY * ToPlayerY)
        const dotProd = (sprite.dirX * toPlayerX) + (sprite.dirY * toPlayerY);
        
        // If dotProd is NEGATIVE, they are facing AWAY (Back turned)
        const isBackTurned = dotProd < 0;
        ///////////DIALOGUE START///////
// Allow clicking on Type 0 (Civilian) OR (Fire Elemental)
if (this.clickInput && (sprite.type === 2 || sprite.type === 3||sprite.type == 4||sprite.type == 5) && transformY < 1.5 && !isBackTurned) {            
            // Check if click is inside the Sprite's box
            if (this.clickInput.x >= drawStartX && this.clickInput.x <= drawStartX + spriteSize &&
                this.clickInput.y >= drawStartY && this.clickInput.y <= drawStartY + spriteSize) {
                
                // Success! Start dialogue
                sprite.startDialogue(this);
                
                // Consume the click so we don't trigger anything else
                this.clickInput = null; 
                continue;
            }
        }

        // --- START DRAWING ---
        ctx.save();
        ctx.beginPath();
        
        // Clipping Mask Loop (Same as before)
        for (let x = 0; x < spriteSize; x++) {
             const screenCol = Math.floor(-spriteSize / 2 + spriteScreenX) + x;
             if (screenCol >= 0 && screenCol < viewW) {
                 if (transformY < this.zBuffer[screenCol]) {
                     ctx.rect(viewX + screenCol, drawStartY, 1, spriteSize);
                 }
             }
        }
        ctx.clip(); 
        
        // Hijack Globals
        const oldTX = tX; const oldTY = tY; const oldTL = tL; const oldTH = tH;
        tX = drawStartX; tY = drawStartY; tL = spriteSize; tH = spriteSize;

if (typeof drawPortrait === 'function') {
            drawPortrait(sprite.type, 0, 0, 1);
            if (isBackTurned) {
               ctx.filter = `blur(${(tL/10)*.16}px)`; 
             
             // Optional: Lower opacity for "ghostly" back view
             //ctx.globalAlpha = 0.7;
              ctx.filter = 'brightness(0%) contrast(20%) sepia(0%) hue-rotate(0deg)'; 
              drawPortrait(sprite.type, 0, 0, 1);
              ctx.filter = 'brightness(0%) contrast(50%) sepia(0%) hue-rotate(0deg)'; 
              drawPortrait(sprite.type, .04, .2, .96);
              ctx.filter = 'brightness(0%) contrast(70%) sepia(0%) hue-rotate(0deg)'; 
              drawPortrait(sprite.type, .07, .3, .93);
            }
        } else {
            ctx.fillStyle = 'red';
            ctx.fillRect(tX, tY, tL, tH);
        }

        

        

        // Restore Globals
        tX = oldTX; tY = oldTY; tL = oldTL; tH = oldTH;

        // The restore() here automatically turns off the BLUR filter
        // because we set it after ctx.save()
        
        ctx.restore(); 
        this.clickInput = null;

    }
  }
  drawMinimap(ctx, viewX, viewY, viewW, viewH) {
    // Minimap Logic (Same as before, updated for globals)
    const size = viewW * 0.2; 
    const padding = 10;
    const cellSize = size / 15;
    
    // Draw inside the playing table bounds
    const startX = viewX + viewW - size - padding;
    const startY = viewY + padding;

    // Background
    ctx.fillStyle = 'rgba(0,0,0,0.5)';
    ctx.fillRect(startX, startY, size, size);

    // Draw Walls
    const range = 7;
    for (let y = -range; y <= range; y++) {
      for (let x = -range; x <= range; x++) {
        const mapX = Math.floor(this.x) + x;
        const mapY = Math.floor(this.y) + y;
        if (mapX >= 0 && mapX < this.maze[0].length && mapY >= 0 && mapY < this.maze.length) {
          if (this.maze[mapY][mapX] > 0) {
             const screenX = startX + size / 2 + x * cellSize;
             const screenY = startY + size / 2 + y * cellSize;
             if (screenX >= startX && screenX < startX + size && screenY >= startY && screenY < startY + size) {
                ctx.fillStyle = '#864';
                ctx.fillRect(screenX, screenY, cellSize, cellSize);
             }
          }
        }
      }
    }

    // Draw NPCs on Minimap
    this.npcs.forEach(npc => {
        const diffX = npc.x - this.x;
        const diffY = npc.y - this.y;
        if(Math.abs(diffX) < range && Math.abs(diffY) < range) {
            const screenX = startX + size/2 + diffX * cellSize;
            const screenY = startY + size/2 + diffY * cellSize;
            ctx.fillStyle = npc.color;
            ctx.beginPath();
            ctx.arc(screenX + cellSize/2, screenY + cellSize/2, cellSize/3, 0, Math.PI*2);
            ctx.fill();
        }
    });

    // Player Arrow
    const playerScreenX = startX + size / 2;
    const playerScreenY = startY + size / 2;
    ctx.save();
    ctx.translate(playerScreenX + cellSize / 2, playerScreenY + cellSize / 2);
    ctx.rotate(this.dir * Math.PI / 2);
    ctx.fillStyle = '#fff';
    ctx.beginPath();
    ctx.moveTo(0, -cellSize);
    ctx.lineTo(-cellSize / 2, cellSize / 2);
    ctx.lineTo(cellSize / 2, cellSize / 2);
    ctx.fill();
    ctx.restore();
  }
  battle() {
    if (!this.currentEnemy) return;
    if (this.currentEnemy.model) {
        
        // 1. Calculate Screen Center
        // You can hardcode this or use dynamic values based on your canvas
        const centerX = tX + (tL > 0 ? tL : 400) / 2; 
        const centerY = tY + (tH > 0 ? tH : 400) / 2;
        
        // 2. Animate the Model (Spin it!)
        // We do this here so it spins during the battle UI
        this.currentEnemy.model.rx += 0.04;
        this.currentEnemy.model.ry += 0.02;

        // 3. Draw it BIG at the center of the screen
        // Scale factor: 150 (Adjust this number to make the monster bigger/smaller)
        this.currentEnemy.model.draw(ctx, centerX, centerY, 150, 4);
    }
    // Reuse the sprite type from the specific NPC we collided with
    // Position x=1.25, y=2, size=0.75 (from your previous preference)
    if (this.currentEnemy.type ==3){

    }else{
      drawPortrait(this.currentEnemy.type, 1.25, 2, 0.75);
    }
  }
  dialogue() {
    if (!this.currentSpeaker) return;
    
    // --- BRANCH A: 3D NPC (e.g., The Fire Elemental or special quest giver) ---
    if (this.currentSpeaker.model) {
        
        // 1. Calculate Screen Position
        // We center it horizontally, and place it slightly higher up 
        // to leave room for the text box at the bottom.
        const centerX = tX + (tL > 0 ? tL : 400) / 2; 
        const centerY = tY + (tH > 0 ? tH : 400) * 0.4; // 0.4 places it at 40% height
        
        // 2. Animate the Model
        // A slow, hypnotic spin is usually better for dialogue than a fast battle spin
        this.currentSpeaker.model.rx += 0.02; 
        this.currentSpeaker.model.ry += 0.01;

        // 3. Draw the Model
        // Scale is set to 120 (slightly smaller than battle to fit the frame)
        this.currentSpeaker.model.draw(ctx, centerX, centerY, 120, 4);
    } 
    
    // --- BRANCH B: 2D Pixel NPC ---
    else {
        // Standard 2D portrait logic
        
        drawPortrait(this.currentSpeaker.type, 1.25, 2, 0.75);
        //HIGH PRIESTESS
        if (this.currentSpeaker.type == 2){
          if (this.dCounter == 0){
          MessageBox.show(.5,8,1,9,2,'Welcome. Do you want to learn to play Runestones?','dialogue',1,0)
        }
        if (this.dCounter == 1){
          MessageBox.show(2.5,0,1,5,2,'Learn to play Runestones?','dialogue',1,0)
          btnYes.show(.5,5,1,2,1.5,'Yes','jrpg_btn',1,0)
          btnNo.show(7.5,5,1,2,1.5,'No','jrpg_btn',1,0)
        }
        if (this.dCounter > 1)(this.dCounter = 0)
        }
        //EMPRESS
        if (this.currentSpeaker.type == 3){
          if (this.dCounter == 0){MessageBox.show(.5,8,1,9,2,'Hello. Do you like Music? I heard a rumor that Suncat has music out on Spotify...look for the logo of the ginger cat chasing a butterfly.','dialogue',1,this.foe)}
          if (this.dCounter == 1){startGame = 'explore'; this.x = 7.5; this.y = 7.5; this.dCounter = 0; }
        }
        //EMPEROR
        if (this.currentSpeaker.type == 4){
          if (this.tutorialFinished == 0){
            if (this.dCounter == 0){MessageBox.show(.5,8,1,9,2,'Hello, lad. Fancy a game of stones? Ah, you dont know how to play? Talk to the lady in blue over there...','dialogue',1,0)}
            if (this.dCounter == 1){startGame = 'explore'; this.x = 7.5; this.y = 7.5; this.dCounter = 0; }
          }
          else{
            if (this.dCounter == 0){MessageBox.show(.5,8,1,9,2,'Well done lad. You finished that tutorial like a champ. Fancy a game of stones?','dialogue',1,0)}
            if (this.dCounter == 1){
              MessageBox.show(2.5,0,1,5,2,'Play a game of Runestones?','dialogue',1,0)
              btnYes.show(.5,5,1,2,1.5,'Yes','jrpg_btn',1,'emperor')
              btnNo.show(7.5,5,1,2,1.5,'No','jrpg_btn',1,'emperor')
            }}
        }
        //HEIROPHANT
        if (this.currentSpeaker.type == 5){
          if (this.dCounter == 0){MessageBox.show(.5,8,1,9,2,'If you would like to get to know our creator Suncat...why not visit their instagram? @suncat.meow','dialogue',1,0)}
          if (this.dCounter == 1){startGame = 'explore'; this.x = 7.5; this.y = 7.5; this.dCounter = 0; }
        }
        

    }

    // --- DRAW TEXT BOX (Optional Overlay) ---
    // If you haven't drawn your UI elsewhere, you can force a text box here
    // to ensure the text is readable over the 3D model.
    /*
    ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
    ctx.fillRect(tX, tY + (tH * 0.7), tL, tH * 0.3);
    ctx.fillStyle = 'white';
    ctx.font = '20px monospace';
    ctx.fillText("Greetings, traveler...", tX + 20, tY + (tH * 0.8));
    */
  }
  tutorial(dt){
    let tick = 30 * dt
    const SPEED_Y = 6 * dt; 
    const SPEED_Z = 3 * dt; 
    //draw padding
	        ctx.fillStyle = "rgba(39,39,39,1)";
	        ctx.fillRect(0,0,wX,wY);
	        //draw table
	        ctx.fillStyle = "rgba(0,6,13,1)";
	        ctx.fillRect(tX,tY,tL,tH);
          this.card[0].place(3.875,0,1)
          if (this.option != 6){
          this.card[1].place(3.875,6.5,1)}
          sRune.refresh();
        cRune.refresh();
        iRune.refresh();
        aRune.refresh();
        
    switch(this.option){
      case 0://intro to runestones quick, start by learning how to attack
        if (this.dCounter == 0){MessageBox.show(.5,8,1,9,2,'Let us begin.','dialogue',1,0)}
        if (this.dCounter == 1){MessageBox.show(.5,8,1,9,2,'To play Runestones, both players must draw from their deck of cards until they get a monster card, easily identifiable by its yellow color.','dialogue',1,0)}
        if (this.dCounter == 2){MessageBox.show(.5,8,1,9,2,'Aside from monster cards, Runestone decks also contain item cards(blue) and spell cards (purple)','dialogue',1,0)}
        if (this.dCounter == 3){MessageBox.show(.5,8,1,9,2,'Then both players must decide on an action based on their available cards...','dialogue',1,0)}
        if (this.dCounter == 4){MessageBox.show(.5,8,1,9,2,'Since only us Monsters occupy the field, we will start with the most basic action - Attack','dialogue',1,0)}
        if (this.dCounter == 5){MessageBox.show(.5,8,1,9,2,'click on your card and select the attack option','dialogue',1,0)}
        if (this.dCounter == 6){this.option = 1;this.dCounter = 0;}
        break;
      case 1://waiting for player to click monster
        MessageBox.show(4.85,6,1,9,2,'','indicator',1,0)
        break;
      case 2://Prompt for attack click
        drawPortrait(-15,mX*.99,5.68,.066);//attack icon
        drawText(mX-.15,5.39,1.13,1,'Attack','white',.75);
        if (this.dCounter <= 1){MessageBox.show(.5,8,1,9,2,'Now click the Attack button to begin the round','dialogue',1,0)}
        if (this.dCounter == 2){this.dCounter = 0;this.option = 3;}
      break;
      case 3://waiting for player to Click the attack button
          drawPortrait(-15,mX*.99,5.68,.066);//attack icon
          drawText(mX-.15,5.39,1.13,1,'Attack','white',.75);
          
          MessageBox.show(mX,4.89,1,9,2,'','indicator',1,0)
          
          break;
      case 4://AGI check
          drawPortrait(-14,9,9,.1);//draw hourglass
          drawPortrait(-14,0,9,.1);//draw hourglass
          drawPortrait(-14,0,0,.1);//draw hourglass
          drawPortrait(-14,9,0,.1);//draw hourglass
          if(this.at <31){this.at = this.at+tick;} //animation timer tick
          if (this.at > 31 && this.at < 36){this.at = 31}
          //step 1. up and closer like flipping coin ay = animation y and az = animation z. 
          if (this.ay < 3 && this.at <=30){this.ay = this.ay+SPEED_Y;this.az = this.az + SPEED_Z;}
          //step2.Dice Falls
          if (this.ay >=3 && this.az !=1 && this.at<=30){this.az = this.az -SPEED_Z;}
          //step 4.Dice Stops
          if (this.ay >=3 && this.az ==1 && this.at<=30){
            Player.setDice(8,8,6,1,.001,dt)
            drawText(7.7,5.6,1,1,''+rnd(1,8),'white',1);
            Foe.flip();
            Foe.setDice(8,8,6,1,.001,dt)
            drawText(7.7,5.6,1,1,''+rnd(1,8),'white',1);
            Foe.flip();
          }
          //step 3.Dice Animate
          else{if (this.at < 30){
              Player.setDice(8,8,9-this.ay,this.az,99,dt)
              Foe.flip();
              Foe.setDice(8,8,9-this.ay,this.az,99,dt)
              Foe.flip();
            }
          }
          if (this.at > 30){//show result of roll and announce turns
            //DICE STOP
            
            Player.setDice(8,8,6,1,.001,dt);
            if (this.reroll == 0){drawText(7.7,5.6,1,1,''+8,'white',1);}else{drawText(7.7,5.6,1,1,''+6,'white',1);} 
            Foe.flip();
            Foe.setDice(8,8,6,1,.001,dt)
            if (this.reroll == 0){drawText(7.7,5.6,1,1,''+8,'white',1);}else{drawText(7.7,5.6,1,1,''+3,'white',1);} 
            Foe.flip();  
            
            if ( this.at==31){
              //drawText(2.15,4.75,6,1,"Tap Screen To Continue",`rgba(${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)})`,1);
              if (this.reroll == 0){
                MessageBox.show(.5,6,1.5,2,1,'Tie - Roll Again!','jrpg',1,0)
                Foe.flip();  
                MessageBox.show(.5,6,1.5,2,.9,'Tie - Roll Again!','jrpg',1,0)
                Foe.flip();  
              }
              else{
                MessageBox.show(.5,6,1.5,2,1,'First!','jrpg',1,0)
                Foe.flip();  
                MessageBox.show(.5,6,1.5,2,.9,'Second!','jrpg',1,0)
                Foe.flip();
              }
            }
            if (this.at == 36){
              if (this.reroll == 0){this.at = 0; this.ay = 0; this.az = 0;this.reroll = 1;} 
              else{MessageBox.show(.5,8,1,9,2,'Well Done...','dialogue',1,0)}
            }
            if (this.at==37){MessageBox.show(.5,8,1,9,2,'You move quickly.','dialogue',1,0)}
            if (this.at==38){MessageBox.show(.5,8,1,9,2,'And because your AGI roll landed higher than mine you make the first move.','dialogue',1,0)}
            if (this.at==39){MessageBox.show(.5,8,1,9,2,'Let us move on. You will Attack by rolling STR and I will Defend by rolling CON..','dialogue',1,0);
              this.option = 5;
              this.at = 0;this.ay = 0;this.az = 0;
              this.reroll = 0;
            }

            }//end show result of roll and announce turns
          break;
      case 5://death by combat
          if (this.reroll == 0){
            drawPortrait(-11,9,9,.1);//draw hourglass
          drawPortrait(-11,0,9,.1);//draw hourglass
          drawPortrait(-13,0,0,.1);//draw hourglass
          drawPortrait(-13,9,0,.1);//draw hourglass
          }
          else{
            drawPortrait(-11,0,0,.1);//draw hourglass
          drawPortrait(-11,9,0,.1);//draw hourglass
          drawPortrait(-13,9,9,.1);//draw hourglass
          drawPortrait(-13,0,9,.1);//draw hourglass
          }
          if(this.at <69){this.at = this.at+tick;} //animation timer tick
          if (this.at >= 69 && this.at < 73){this.at = 69}
          //step 1. up and closer like flipping coin ay = animation y and az = animation z. 
          if (this.ay < 3 && this.at <=30){this.ay = this.ay+SPEED_Y;this.az = this.az + SPEED_Z;}
          //step2.Dice Falls
          if (this.ay >=3 && this.az !=1 && this.at<=30){this.az = this.az -SPEED_Z;}
          //step 4.Dice Stops
          if (this.ay >=3 && this.az ==1 && this.at<=30){
            Player.setDice(4,8,6,1,.001,dt)
            drawText(7.7,5.6,1,1,''+rnd(1,4),'white',1);
            Foe.flip();
            Foe.setDice(4,8,6,1,.001,dt)
            drawText(7.7,5.6,1,1,''+rnd(1,4),'white',1);
            Foe.flip();
          }
          //step 3.Dice Animate
          else{if (this.at < 30){
            this.mc = 1;
              Player.setDice(4,8,9-this.ay,this.az,99,dt)
              Foe.flip();
              Foe.setDice(4,8,9-this.ay,this.az,99,dt)
              Foe.flip();
              if(this.reroll == 0){
                MessageBox.show(.5,6,1.5,2,1,'Fool attacks!','jrpg',1,0)
                drawPortrait(-20,4.5-this.at*.005,7-(this.at*.04),.1+this.at*.001);
                Foe.flip();
                drawPortrait(-16,4.5-this.at*.005,7-(this.at*.03),.1+this.at*.001);
                Foe.flip();
              }
              else{
                MessageBox.show(.5,6,1.5,2,1,'High Priestess attacks!','jrpg',1,0)
                Foe.flip();
                drawPortrait(-20,4.5-this.at*.005,7-(this.at*.05),.1+this.at*.001);
                Foe.flip();
                drawPortrait(-16,4.5-this.at*.005,7-(this.at*.03),.1+this.at*.001);
              }
              
            }
          }
          if (this.at > 30){//show result of roll and announce turns
            //DICE STOP
           
            Player.setDice(4,8,6,1,.001,dt);
            if (this.reroll == 0){drawText(7.7,5.6,1,1,''+3,'white',1);}else{drawText(7.7,5.6,1,1,''+1,'white',1);}
            Foe.flip();
            Foe.setDice(4,8,6,1,.001,dt)
            if (this.reroll == 0){drawText(7.7,5.6,1,1,''+3,'white',1);}else{drawText(7.7,5.6,1,1,''+4,'white',1);}
            Foe.flip();  
            
            if ( this.at>31){
              //drawText(2.15,4.75,6,1,"Tap Screen To Continue",`rgba(${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)})`,1);
              if (this.reroll == 0){
                MessageBox.show(.5,6,1.5,2,1,'High Priestess resists the attack!','jrpg',1,0)
                if (this.at <69){
                  drawPortrait(-20,4.5-this.at*.005,7-(this.at*.05),.1+this.at*.001);
                  Foe.flip();
                  drawPortrait(-16,4.5-this.at*.005,7-(this.at*.03),.1+this.at*.001);
                  Foe.flip();
                }
              }  
              else{
                
                
                if(this.mc == 1){MusicEngine.playSFX('death');MusicEngine.stop();MusicEngine.play(21); this.mc = 0;}
                MessageBox.show(.5,6,1.5,2,1,'Fool is slain!','jrpg',1,0)
                drawShape('rec',0,0,1,3.88,6.5,2.25,3.55,0,0,0,0,`rgba(0,0,0,${(.3+this.at*.01)})`,1);
                
               
                
                if (this.at <69){
                  
                  drawPortrait(3.2,4.5-this.at*.001,7,.1+this.at*.001);
                    Foe.flip();
                    drawPortrait(-20,4.5-this.at*.005,7-(this.at*.05),.1+this.at*.001);
                    Foe.flip();
          
                }
              }
            }
              
              
            if (this.at == 69){
              if (this.reroll == 0){
              MessageBox.show(.5,8,1,9,2,'Heh...I guess I got lucky.Did I sense a hint of killing intent there?','dialogue',1,0)}
              else{
                MessageBox.show(.5,8,1,9,2,'...','dialogue',1,0)}
            }
            if (this.at==76){
               if (this.reroll == 0){
              MessageBox.show(.5,8,1,9,2,'No matter. Since I survived your attack you must now face my counterattack.','dialogue',1,0)
            }
              else{MessageBox.show(.5,8,1,9,2,'I should bring him back...','dialogue',1,0)}
            }
            if (this.at==77){
              if (this.reroll == 0){
                MessageBox.show(.5,8,1,9,2,'You will roll CON to Defend and I will roll STR to Attack. En Garde!','dialogue',1,0)
              }
              else{MessageBox.show(.5,8,1,9,2,'I guess...','dialogue',1,0)}
            }
            if (this.at==78){
              if (this.reroll == 0){
              this.at = 0;this.ay = 0;this.az = 0; this.reroll = 1;}
              else{this.at = 0;this.ay = 0;this.az = 0;this.option = 6;this.reroll = 0;MusicEngine.stop();MusicEngine.play(8)}
            }

            }//end show result of roll and announce turns
      break;
      case 6://drawing cards and taking runestones
           if(this.at <99&& this.at > -1){this.at = this.at+tick;} //animation timer tick
             if (this.dCounter > 4){drawText(4.6, .93, .4, .3, '+1', 'green', 1);}
           if (this.at < 39&& this.at > 1){this.card[2].place(10-this.at*.23,6.5,1)}
           
           if (this.at >= 39 && this.at < 69){
            this.card[2].place(.875,6.5,1)
            this.card[3].place(10-(this.at-39)*.3,6.5,1)
           }
           if (this.at >= 69&& this.at < 99){
            this.card[2].place(.875,6.5,1)
            this.card[3].place(.875,6.5,1)
            this.card[1].place(10-(this.at-69)*.2,6.5,1)
           }
           if (this.at>99){
            this.card[1].place(3.875,6.5,1)
            this.card[2].place(.875,6.5,1)
            this.card[3].place(.875,6.5,1)
            this.at = -1;
            this.dCounter = 0;
           }
           if (this.at == -1){
            this.card[1].place(3.875,6.5,1)
            this.card[2].place(.875,6.5,1)
            this.card[3].place(.875,6.5,1)
            if (this.dCounter == 0){MessageBox.show(.5,8,1,9,2,'Ahem...to continue our lesson...','dialogue',1,0)}
            if (this.dCounter == 1){MessageBox.show(.5,8,1,9,2,'If you lose a monster, you must draw from your deck until you get a new monster','dialogue',1,0)}
            if (this.dCounter == 2){MessageBox.show(.5,8,1,9,2,'This is the only way to get item cards and spell cards in your hand without using a card like Treasure Chest.','dialogue',1,0)}
            if (this.dCounter == 3){
              MessageBox.show(3.85,4.25,1,9,2,'','indicator',1,0)
              MessageBox.show(1.85,4.25,1,9,2,'','indicator',1,0)
              MessageBox.show(5.85,4.25,1,9,2,'','indicator',1,0)
              MessageBox.show(7.85,4.25,1,9,2,'','indicator',1,0)
              MessageBox.show(.5,8,1,9,2,'As the winner of this round... I have the right to take a runestone from the center of the field, or if none on the field remain, i may take it from the opponent','dialogue',1,0);}
            if(this.dCounter ==4){
              MessageBox.show(.5,8,1,9,2,'To win the game you must seize all four runestones... or make your opponent run out of monsters.','dialogue',1,0)
            }
            if (this.dCounter == 5){
               iRune.changeOwner('tutorial')
              MessageBox.show(.5,8,1,9,2,'Finally, seizing a Runestone gives a +1 bonus to its corresponding Stat. ','dialogue',1,0);
            }
            if (this.dCounter == 6){MessageBox.show(.5,8,1,9,2,'STR for Attack. CON for Defend. INT for spells. AGI gives the initiative which paired with Items and spells, can turn the tide of battle!','dialogue',1,0);}
            if (this.dCounter == 7){MessageBox.show(.5,8,1,9,2,'Lastly, the final invisible Stat which determines everything. Luck!','dialogue',1,0)}
           
            if (this.dCounter == 8){MessageBox.show(.5,8,1,9,2,'Now then, onto the final topic of Spells (purple cards) and Items (blue cards)','dialogue',1,0)}
            if (this.dCounter == 9){this.option = 7; this.at = 0; this.dCounter = 0;}
          }
           
      break;
      case 7://Using cards in hand
      
        drawText(4.6, .93, .4, .3, '+1', 'green', 1);
      
        if(this.dCounter < 2){
          MessageBox.show(halX-.15,arY-.35,1,9,2,'','indicator',1,0)
          MessageBox.show(harX+.4,arY-.35,1,9,2,'','indicator',1,0)
          drawText(1.5, 5.75, 1, 1, '1/2', 'white', 1);
          this.card[2].place(.875,6.5,1)
          this.card[3].place(.875,6.5,1)
          drawPortrait(-1,halX-.5,arY,.1);//left
          drawPortrait(-2,harX,arY,.1);//right
        }

        if (this.dCounter == 0){MessageBox.show(.5,8,1,9,2,'I see you have a Strength spell... What else do you have there?. Click the arrows to cycle through your hand.','dialogue',1,0)}

        if (this.dCounter == 2){
          drawText(1.5, 5.75, 1, 1, '2/2', 'white', 1);
          this.card[2].place(.875,6.5,1)
          drawPortrait(-1,halX-.5,arY,.1);//left
          drawPortrait(-2,harX,arY,.1);//right
          MessageBox.show(.5,8,1,9,2,'*blush* the Lovers eh? ahem... I mean, go ahead and select the card','dialogue',1,0)
        }
        if (this.dCounter == 3){
          //drawText(1.5, 5.75, 1, 1, ''+ this.dCounter, 'white', 1);
          this.card[2].place(.875,6.5,1)
          drawPortrait(-1,halX-.5,arY,.1);//left
          drawPortrait(-2,harX,arY,.1);//right
          MessageBox.show(hX+.95,cY - .4,1,9,2,'','indicator',1,0)
        }
        if (this.dCounter == 4){
          drawText(1.5, 5.75, 1, 1, ''+this.dCounter, 'white', 1);
          this.card[2].place(.875,6.5,1)
          drawPortrait(-1,halX-.5,arY,.1);//left
          drawPortrait(-2,harX,arY,.1);//right
          drawPortrait(-21,hX*.96,5.68,.066);//Use/Cast icon
          drawText(hX,5.33,1,1,'Use','white',.66);//USE/CAST TEXT
          MessageBox.show(hX+.15,5.33 - .4,1,9,2,'','indicator',1,0)
          MessageBox.show(.5,8,1,9,2,'Click the Use button to ready the card for battle and to begin the next round of combat.','dialogue',1,0)
        }
        if (this.dCounter == 5){
          drawText(1.5, 5.75, 1, 1, ''+ this.dCounter, 'white', 1);
          this.card[2].place(.875,6.5,1)
          drawPortrait(-1,halX-.5,arY,.1);//left
          drawPortrait(-2,harX,arY,.1);//right
          drawPortrait(-21,hX*.96,5.68,.066);//Use/Cast icon
          drawText(hX,5.33,1,1,'Use','white',.66);//USE/CAST TEXT
          MessageBox.show(hX+.15,5.33 - .4,1,9,2,'','indicator',1,0)
          }
          if(this.dCounter == 6){this.at = 0; this.ax = 0; this.ay = 0; this.dCounter = 0; this.option = 8}
       
      break;
      case 8://Round 2 AGI check again
          drawPortrait(-14,9,9,.1);//draw hourglass
          drawPortrait(-14,0,9,.1);//draw hourglass
          drawPortrait(-14,0,0,.1);//draw hourglass
          drawPortrait(-14,9,0,.1);//draw hourglass
          if(this.at <31){this.at = this.at+tick;} //animation timer tick
          if (this.at > 31 && this.at < 36){this.at = 31}
          //step 1. up and closer like flipping coin ay = animation y and az = animation z. 
          if (this.ay < 3 && this.at <=30){this.ay = this.ay+SPEED_Y;this.az = this.az + SPEED_Z;}
          //step2.Dice Falls
          if (this.ay >=3 && this.az !=1 && this.at<=30){this.az = this.az -SPEED_Z;}
          //step 4.Dice Stops
          if (this.ay >=3 && this.az ==1 && this.at<=30){
            Player.setDice(8,8,6,1,.001,dt)
            drawText(7.7,5.6,1,1,''+rnd(1,8),'white',1);
            Foe.flip();
            Foe.setDice(8,8,6,1,.001,dt)
            drawText(7.7,5.6,1,1,''+rnd(1,8),'white',1);
            Foe.flip();
          }
          //step 3.Dice Animate
          else{if (this.at < 30){
              Player.setDice(8,8,9-this.ay,this.az,99,dt)
              Foe.flip();
              Foe.setDice(8,8,9-this.ay,this.az,99,dt)
              Foe.flip();
            }
          }
          if (this.at > 30){//show result of roll and announce turns
            //DICE STOP
            
            Player.setDice(8,8,6,1,.001,dt);
            drawText(7.7,5.6,1,1,''+8,'white',1);
            Foe.flip();
            Foe.setDice(8,8,6,1,.001,dt)
            drawText(7.7,5.6,1,1,''+1,'white',1);
            Foe.flip();  
            
            if ( this.at==31){
              //drawText(2.15,4.75,6,1,"Tap Screen To Continue",`rgba(${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)})`,1);
              
                MessageBox.show(.5,6,1.5,2,1,'First!','jrpg',1,0)
                Foe.flip();  
                MessageBox.show(.5,6,1.5,2,.9,'Second!','jrpg',1,0)
                Foe.flip();
              
            }
            if (this.at == 36){
             
              MessageBox.show(.5,8,1,9,2,'As expected of my love... *cough* er... ANYWAY ','dialogue',1,0)
            }
            if (this.at==37){MessageBox.show(.5,8,1,9,2,'Because your AGI roll landed higher than mine you must make the first move','dialogue',1,0)}
            if (this.at==38){MessageBox.show(.5,8,1,9,2,'Because you selected an Item from your hand, you will not Attack, instead you will activate the item.','dialogue',1,0)}
            if (this.at==39){MessageBox.show(.5,8,1,9,2,'Items have game changing effects and typically do not require stats to activate, unlike Spells... as you shall soon see.','dialogue',1,0);}
            if (this.at==40){MessageBox.show(.5,8,1,9,2,'Now lets move on. Your item will now take effect and then I shall make my move.','dialogue',1,0);}
            if (this.at==41){ this.option = 9;this.at = 0;this.ay = 0;this.az = 0;}
            }//end show result of roll and announce turns
          break;
      case 9://Item use  
        if (this.reroll == 0){
          drawPortrait(-21,9,9,.1);
          drawPortrait(-21,0,9,.1);
          drawPortrait(-13,0,0,.1);//draw hourglass
          drawPortrait(-13,9,0,.1);//draw hourglass
          if (this.at <61){this.at = this.at+tick;}
          if (this.at >= 61){this.at = 61}
          //MOVE ITEM FROM HAND TO CENTER OF FIELD
          if (this.at <= 30){this.card[2].place(1+((2.875/30)*this.at),6.5,1);}
          //GLOW EFFECT TO INDICATE USE
          if (this.at > 30 && this.at <=60){
            this.card[2].place(3.88,6.5,1);
            drawShape('rec',3.88,6.5,1,0,0,2.25,3.55,0,0,0,0,`rgba(255,255,0,${.1+this.at*.01})`,1);
            this.dCounter = 0;
          }
          if (this.dCounter == 0 && this.at ==61){MessageBox.show(.5,8,1,9,2,'As you can see activating the card gives a +1 bonus to STR and a +1 bonus to CON..','dialogue',1,0)}
          if (this.dCounter == 1 && this.at ==61){MessageBox.show(.5,8,1,9,2,'Now, Spells, unlike Items, are dependent on stats rolls to activate.','dialogue',1,0)}
          if (this.dCounter == 2 && this.at ==61){MessageBox.show(.5,8,1,9,2,'Since you have taken your turn, allow me to demonstrate Spell use...','dialogue',1,0)}
          if (this.dCounter == 3 && this.at ==61){
              MessageBox.show(.5,8,1,9,2,'Since you have taken your turn, allow me to demonstrate Spell use.','dialogue',1,0)
              this.reroll = 1; this.at = 0; this.ay = 0; this.az = 0;
          }
        }
        if (this.reroll == 1){
          if(this.at <130){this.at = this.at+tick;}//ticking til 100
          else if (this.at>130&&this.at <136 ){this.at = 130;}//pause at 101
          else if (this.at >=136){this.at = this.at+tick;}//continue after 106  
          drawPortrait(-21, 0, 0, .1);
          drawPortrait(-21, 9, 0, .1);
          drawPortrait(-13,9,9,.1);//draw hourglass
          drawPortrait(-13,0,9,.1);//draw hourglass
          //MOVE ITEM FROM HAND TO CENTER OF FIELD
          if (this.at <= 30){
            this.mc = 1;
            Foe.flip();
            this.card[4].place(1+((2.875/30)*this.at),6.5,1);
            Foe.flip();
          }
          //GLOW EFFECT TO INDICATE USE
          if (this.at > 30 && this.at <=69){
            Foe.flip()
            this.card[4].place(3.88,6.5,1);
            drawShape('rec',3.88,6.5,1,0,0,2.25,3.55,0,0,0,0,`rgba(255,255,0,${.1+this.at*.01})`,1);
            Foe.flip()
          }
          if (this.at > 69){
            drawPortrait(-12, 9, 9, .1);
            drawPortrait(-12, 0, 9, .1);
            drawPortrait(-12, 9, 0, .1);
            drawPortrait(-12, 0, 0, .1);
            if (this.ay < 3 && this.at < 100) {this.ay = this.ay + SPEED_Y;this.az = this.az + SPEED_Z;}
            if (this.ay > 3 && this.az > 1 && this.at < 100) {this.az = this.az - SPEED_Z;}
            // DICE STOPPED
            if (this.ay > 3 && this.az <= 1 && this.at < 100) {
              Player.setDice(4, 8, 6, 1.5, .0001, dt);
              drawText(7.7, 5.6, 1, 1, '' + 4, 'white', 1);
              Foe.flip();
              Foe.setDice(10, 8, 6, 1.5, .0001, dt);
              drawText(7.7, 5.6, 1, 1, '' + 9, 'white', 1);
              Foe.flip()
            } 
            // DICE ROLLING
            else {if (this.at < 100) {
              // Player Roll
              Player.setDice(4, 8, 9 - this.ay, this.az, 99, dt);
              // Foe Roll
              Foe.flip();
              Foe.setDice(10, 8, 9 - this.ay, this.az, 99, dt);
              Foe.flip();
              MessageBox.show(.5,6,1.5,2,1,'High Priestess mutters an incantation...','jrpg',1,0)  
              drawPortrait(13, 4.5 - this.at * .005, 5 - this.at * .003, .1 + this.at * .001)
              }   //<100 
            }//end if dice rolling....
            //Roll Results
            if (this.at > 100) {
              //DICE STOP
              Player.setDice(4, 8, 6, 1.5, .0001, dt);
              drawText(7.7, 5.6, 1, 1, '' + 3, 'white', 1);
              //DICE STOP FOE
              Foe.flip();
              Foe.setDice(10, 8, 6, 1.5, .0001, dt);
              drawText(7.7, 5.6, 1, 1, '' + 9, 'white', 1);
              Foe.flip();
              if (this.mc == 1){MusicEngine.stop();MusicEngine.playSFX('death');MusicEngine.play(21);this.mc = 0;}
              MessageBox.show(.5,6,1.5,2,1, 'Fool succumbs to the spell!','jrpg',1,0)
              drawShape('rec',0,0,1,3.88,6.45,2.25,3.55,0,0,0,0,`rgba(0,0,0,${(.3+(this.at-100)*.2)})`,1);
            }//>100
            if (this.at == 130){
              this.option = 10
              this.at = 0; this.ay = 0; this.az = 0; this.dCounter = 0;  
            }
          }//>69
        }//reroll = 1
      break;
      case 10://END and return to explore
        drawShape('rec',0,0,1,3.88,6.45,2.25,3.55,0,0,0,0,`rgba(0,0,0,1)`,1);
         //DICE STOP
              Player.setDice(4, 8, 6, 1.5, .0001, dt);
              drawText(7.7, 5.6, 1, 1, '' + 3, 'white', 1);
              //DICE STOP FOE
              Foe.flip();
              Foe.setDice(10, 8, 6, 1.5, .0001, dt);
              drawText(7.7, 5.6, 1, 1, '' + 9, 'white', 1);
              Foe.flip();
              MessageBox.show(.5,6,1.5,2,1, 'Fool succumbs to the spell!','jrpg',1,0)
        if (this.dCounter <2){MessageBox.show(.5,8,1,9,2,'Oh dear...','dialogue',1,0)}
        if (this.dCounter == 2){MessageBox.show(.5,8,1,9,2,'I forget my own strength at times...','dialogue',1,0)}
        if (this.dCounter == 3){this.dCounter = 0; startGame = 'explore'; this.x = 7.5; this.y = 7.5;this.tutorialFinished = 1;MusicEngine.stop();MusicEngine.playSFX('heal');MusicEngine.play(4);}
      break;
    } 
  }
}

class btn{
  constructor(x,y,l,h,z,text,frameColor,textColor,index=0,visible = 0){
    this.wobbleTimer = 0;
    this.wobbleMax = 0;
    this.x = x; this.y = y; this.z = z;
    this.text = text;
    this.frameColor = frameColor;
    this.textColor = textColor;
    this.visible = visible;
    this.index = index;
    //shape,x,y,z,x1,y1,x2,y2,x3,y3,x4,y4,color,fill,x5,y5
    drawShape('rec',this.x,this.y,this.z,0,0,this.l,this.h,0,0,0,0,this.frameColor,0,0,0)
    //x, y, boxW, boxH, text, color, z
    drawText(this.x,this.y,this.l,this.h,this.text,this.textColor,this.z)
  }
  setOrigin(x,y,z){
    this.originx = x;
    this.originy = y;
    this.originz = z;
  }
  show(x,y,z,l,h,text,type='frame',visible = 1,foe,originx = this.x, originy = this.y,originz = this.originz){
    if (foe == 1&&Foe.isCPU == 1){return}
    this.foe = foe
    this.x = x;
    this.y = y;
    this.z = z;
    this.l = l;
    this.h = h;
    let pulse = 0;
    let isPressed = 0;
    let bSize = 0;
    let baseCol = 0;
    let frameCol = 0;
    let inset = 0;
    let borderCol = 0;
    let bgCol = 0;
    this.originx = originx;
    this.originy = originy;
    this.originz = originz;
    this.type = type;
    this.visible = visible;
    this.text = text
    if (this.visible > 0){
      switch(type){
        case 'frame':
          this.frameColor = 'rgba(0,0,190,.75)';
          this.textColor = 'black'
          //shape,x,y,z,x1,y1,x2,y2,x3,y3,x4,y4,color,fill,x5,y5
          //drawShape('rec',this.x+.05*this.z,this.y+.05*this.z,this.z,0,0,this.l-.06*this.z,this.h,0,0,0,0,'gold',0,0,0)
          drawShape('rec',this.x,this.y,this.z,0,0,this.l,this.h,0,0,0,0,'gold',0,0,0)
          drawShape('rec',this.x,this.y,this.z,0,0,this.l,this.h,0,0,0,0,this.frameColor,1,0,0)
          drawShape('rec',this.x,this.y,this.z,0,0,this.l-.03*this.z,this.h-.06*this.z,0,0,0,0,'rgba(255,255,255,.5)',1,0,0)
          drawShape('rec',this.x,this.y,this.z,0,0,this.l-.03*this.z,this.h-.06*this.z,0,0,0,0,'gold',0,0,0)
          //x, y, boxW, boxH, text, color, z
          drawText(this.x,this.y+.015*this.z,this.l-.02*this.z,this.h-.02*this.z,this.text,this.textColor,this.z-.01)
          break;
        case 'button3D':
          // If pressed, we move the top layer down and change the color slightly
          let pressShift = this.isPressed ? 0.02 * this.z : 0;
          let shadowColor = '#555';
          let faceColor = this.isPressed ? '#d4af37' : 'gold'; // Darkens 'gold' when pressed

          // 1. DRAW THE SHADOW (The "Side" of the button)
          // We draw this at the original position
          drawShape('rec', this.x, this.y, this.z, 0, 0, this.l, this.h + (0.03 * this.z), 0, 0, 0, 0, shadowColor, 1, 0, 0);

          // 2. DRAW THE MAIN FACE
          // We offset 'y' by pressShift. When pressed, it moves DOWN.
          drawShape('rec', this.x, this.y + pressShift, this.z, 0, 0, this.l, this.h, 0, 0, 0, 0, faceColor, 1, 0, 0);

          // 3. DRAW THE TEXT
          // Text must also move down with the face!
          drawText(this.x, this.y + pressShift, this.l, this.h, this.text, this.textColor, this.z - 0.01);
          break;
        case 'neon':
          let glowSize = this.isPressed ? 0.06 * this.z : 0.02 * this.z;
          let glowColor = this.isPressed ? '#00ffff' : '#008888';

          // Glow Layer
          drawShape('rec', this.x - glowSize/2, this.y - glowSize/2, this.z, 0, 0, this.l + glowSize, this.h + glowSize, 0,0,0,0, glowColor, 1, 0, 0);
          
          // Main Dark Box
          drawShape('rec', this.x, this.y, this.z, 0, 0, this.l, this.h, 0,0,0,0, '#111', 1, 0, 0);
          
          drawText(this.x, this.y, this.l, this.h, this.text, '#00ffff', this.z);
          break;
        case 'seesaw':
          const WOBBLE_SPEED = 15; // Higher is faster
          let finalTilt = 0;

          if (this.isPressed) {
            let elapsed = (Date.now() - this.wobbleTimer) / 1000;
            let progress = elapsed * WOBBLE_SPEED;
            
            // Logic: 1 = Tilt & Back | 2 = Tilt, Back, Other Side, Back
            // We use Math.sin and a decay multiplier so it stops at the count
            if (progress < (this.wobbleMax * Math.PI)) {
              finalTilt = Math.sin(progress) * 0.15 * this.side;
            }
          }

          // Calculate 4 corners using the dynamic finalTilt
          let x1 = 0, y1 = 0 - finalTilt;
          let x2 = this.l, y2 = 0 + finalTilt;
          let x3 = this.l, y3 = this.h + finalTilt;
          let x4 = 0, y4 = this.h - finalTilt;

          // Draw Shadow
          drawShape('qua', this.x, this.y + 0.05, this.z, x1, y1, x2, y2, x3, y3, x4, y4, '#444', 1);
          // Draw Face
          drawShape('qua', this.x, this.y, this.z, x1, y1, x2, y2, x3, y3, x4, y4, 'gold', 1);
          // Draw Text
          drawText(this.x, this.y + (finalTilt/2), this.l, this.h, this.text, 'black', this.z - 0.01);
          break;
        case 'pulse':
          pulse = Math.sin(Date.now() / 200) * 0.03;
          let thick = 0.05 + pulse;

          // Dark Center
          drawShape('qua', this.x, this.y, this.z, 
                    -thick, -thick, 
                    this.l + thick, -thick, 
                    this.l + thick, this.h + thick, 
                    -thick, this.h + thick, 
                    '#111', 1);
          // Pulsing neon border (using 'qua' for precision)
          drawShape('qua', this.x, this.y, this.z, 
                    -thick, -thick, 
                    this.l + thick, -thick, 
                    this.l + thick, this.h + thick, 
                    -thick, this.h + thick, 
                    '#00ff00', 0);

          drawText(this.x, this.y, this.l, this.h, this.text, `rgba(${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)})`, this.z);
          break;
        case 'jrpg':
          bSize = 0.04; // Border/Bevel thickness
          isPressed = 0;
          
          // 1. OUTER SHADOW (Grounds the UI)
          drawShape('rec', this.x + 0.03, this.y + 0.03, this.z, 0, 0, this.l, this.h, 0, 0, 0, 0, 'rgba(0,0,0,0.5)', 1);

          // 2. MAIN BODY (The Gradient)
          // We use a slightly lighter color if pressed
          baseCol = isPressed ? '#1a1a99' : '#000066'; 
          drawShape('rec', this.x, this.y, this.z, 0, 0, this.l, this.h, 0, 0, 0, 0, baseCol, 1);
          // Secondary "Wash" for top half to simulate light hitting silk/glass
          drawShape('rec', this.x, this.y, this.z, 0, 0, this.l, this.h * 0.5, 0, 0, 0, 0, 'rgba(255,255,255,0.1)', 1);

          // 3. THE BEVEL (Lighting Simulation)
          // Top Highlight (Light hitting the top edge)
          drawShape('lin', this.x, this.y, this.z, 0, 0, this.l, 0, 0, 0, 0, 0, 'rgba(255,255,255,0.8)', 0);
          // Left Highlight
          drawShape('lin', this.x, this.y, this.z, 0, 0, 0, this.h, 0, 0, 0, 0, 'rgba(255,255,255,0.5)', 0);
          // Bottom Shadow (Ambient occlusion)
          drawShape('lin', this.x, this.y + (this.h * this.z), this.z, 0, 0, this.l, 0, 0, 0, 0, 0, 'rgba(0,0,0,0.8)', 0);

          // 4. THE PINSTRIPE (The "Golden" Frame)
          frameCol = isPressed ? '#ffffff' : '#d4af37'; // Glows white when clicked
          // Draw an inset rectangle
          inset = 0.05;
          drawShape('rec', this.x, this.y, this.z, inset, inset, this.l - (inset * 2), this.h - (inset * 2), 0, 0, 0, 0, frameCol, 0);

          // 5. THE TEXT (With subtle drop shadow)
          // Draw shadow text first
          //drawText(this.x + 0.01, this.y + 0.01, this.l, this.h, this.text, 'black', this.z);
          // Draw main text
          //drawText(this.x, this.y, this.l*.98, this.h*.98, this.text, 'white', this.z);
         // if (this.text == 'Second'||this.text == 'First'){
            //drawText(this.x + 0.07, this.y + 0.21, this.l*.8, this.h*.8, this.text, 'black', this.z);
            drawText(this.x+.13, this.y+.2, this.l*.8, this.h*.8, this.text, 'white', this.z);
          //}else{
            // Draw shadow text first
         //drawText(this.x + 0.01, this.y + 0.01, this.l, this.h, this.text, 'black', this.z);
          // Draw main text
       // drawText(this.x, this.y, this.l, this.h, this.text, 'white', this.z);
          //}
          break;
          
        case 'jrpg_btn':
          bSize = 0.04; // Border/Bevel thickness
          isPressed = this.isPressed;
          
          // 1. OUTER SHADOW (Grounds the UI)
          drawShape('rec', this.x + 0.03, this.y + 0.03, this.z, 0, 0, this.l, this.h, 0, 0, 0, 0, 'rgba(0,0,0,0.5)', 1);

          // 2. MAIN BODY (The Gradient)
          // We use a slightly lighter color if pressed
          baseCol = isPressed ? '#1a1a99' : '#000066'; 
          drawShape('rec', this.x, this.y, this.z, 0, 0, this.l, this.h, 0, 0, 0, 0, baseCol, 1);
          // Secondary "Wash" for top half to simulate light hitting silk/glass
          drawShape('rec', this.x, this.y, this.z, 0, 0, this.l, this.h * 0.5, 0, 0, 0, 0, 'rgba(255,255,255,0.1)', 1);

          // 3. THE BEVEL (Lighting Simulation)
          // Top Highlight (Light hitting the top edge)
          drawShape('lin', this.x, this.y, this.z, 0, 0, this.l, 0, 0, 0, 0, 0, 'rgba(255,255,255,0.8)', 0);
          // Left Highlight
          drawShape('lin', this.x, this.y, this.z, 0, 0, 0, this.h, 0, 0, 0, 0, 'rgba(255,255,255,0.5)', 0);
          // Bottom Shadow (Ambient occlusion)
          drawShape('lin', this.x, this.y + (this.h * this.z), this.z, 0, 0, this.l, 0, 0, 0, 0, 0, 'rgba(0,0,0,0.8)', 0);

          // 4. THE PINSTRIPE (The "Golden" Frame)
          frameCol = isPressed ? '#ffffff' : '#d4af37'; // Glows white when clicked
          // Draw an inset rectangle
          inset = 0.05;
          drawShape('rec', this.x, this.y, this.z, inset, inset, this.l - (inset * 2), this.h - (inset * 2), 0, 0, 0, 0, frameCol, 0);

          // 5. THE TEXT (With subtle drop shadow)
          // Draw shadow text first
          //drawText(this.x + 0.01, this.y + 0.01, this.l, this.h, this.text, 'black', this.z);
          // Draw main text
          //drawText(this.x, this.y, this.l*.98, this.h*.98, this.text, 'white', this.z);
          //if (this.text == 'Second'){
            drawText(this.x + 0.07, this.y + 0.21, this.l*.93, this.h*.96, this.text, 'black', this.z);
            drawText(this.x+.13, this.y+.2, this.l*.93, this.h*.96, this.text, 'white', this.z);
          //}else{
            // Draw shadow text first
         // drawText(this.x + 0.01, this.y + 0.01, this.l, this.h, this.text, 'black', this.z);
          // Draw main text
          //drawText(this.x, this.y, this.l, this.h, this.text, 'white', this.z);
          //}
          break;
          // --- Active Animation: Subtle Border Pulse ---
          pulse = Math.sin(Date.now() / 300) * 0.02;
          borderCol = this.isPressed ? 'yellow' : 'white';
          bgCol = this.isPressed ? '#4a4aff' : '#00008b'; // Lighter blue when pressed

          // 1. Black Outer Shadow
          drawShape('rec', this.x + 0.02, this.y + 0.02, this.z, 0, 0, this.l, this.h, 0, 0, 0, 0, 'black', 1, 0, 0);
          
          // 2. Main Blue Body
          drawShape('rec', this.x, this.y, this.z, 0, 0, this.l, this.h, 0, 0, 0, 0, bgCol, 1, 0, 0);
          
          // 3. The White Border (with the pulse animation)
          drawShape('rec', this.x, this.y, this.z, 0.02 - pulse, 0.02 - pulse, this.l - 0.04 + (pulse*2), this.h - 0.04 + (pulse*2), 0, 0, 0, 0, borderCol, 0, 0, 0);

          drawText(this.x + 0.05, this.y, this.l - 0.1, this.h, this.text, 'white', this.z);
          break;       
        case 'dialogue':
          // 1. DIMMER OVERLAY (Optional)
          // Darkens the game world slightly behind the box for focus
          // drawShape('rec', 0, 0, 10, 0, 0, 10, 10, 0, 0, 0, 0, 'rgba(0,0,0,0.3)', 1);

          // 2. OUTER GLOW & MAIN BODY
          // Using a deep obsidian blue with 85% opacity
          let bodyCol = 'rgba(10, 15, 40, 0.85)';
          drawShape('rec', this.x, this.y, this.z, 0, 0, this.l, this.h, 0, 0, 0, 0, 'black', 1); // Border shadow
          drawShape('rec', this.x, this.y, this.z, 0.02, 0.02, this.l - 0.04, this.h - 0.04, 0, 0, 0, 0, bodyCol, 1);

          // 3. ORNATE CORNERS (The "Industry" Polish)
          // We draw small L-shapes or brackets in the corners
          let cSize = 0.2; // Corner bracket size
          let cThick = 0.03;
          let gold = '#d4af37';
          // Top-Left Bracket
          drawShape('rec', this.x, this.y, this.z, 0, 0, cSize, cThick, 0, 0, 0, 0, gold, 1);
          drawShape('rec', this.x, this.y, this.z, 0, 0, cThick, cSize, 0, 0, 0, 0, gold, 1);
          // Bottom-Right Bracket
          drawShape('rec', this.x, this.y, this.z, this.l - cSize, this.h - cThick, cSize, cThick, 0, 0, 0, 0, gold, 1);
          drawShape('rec', this.x, this.y, this.z, this.l - cThick, this.h - cSize, cThick, cSize, 0, 0, 0, 0, gold, 1);
          
            drawText(this.x+.13, this.y+.2, this.l*.93, this.h*.96, this.text, 'white', this.z);
          
          break;
        case 'indicator':
          // 4. THE NAME TAG (Header)
          // If the text contains a ":" we can extract a name, or just use a default
          //drawShape('rec', this.x + 0.5, this.y - 0.3, this.z, 0, 0, 2.5, 0.5, 0, 0, 0, 0, 'gold', 1);
          //drawText(this.x + 0.6, this.y - 0.25, 2.3, 0.4, "SPEAKER", 'black', this.z);

          // 5. THE DIALOGUE TEXT
          // We use a slight inset so text doesn't touch the borders
          drawText(this.x + 0.3, this.y + 0.3, this.l - 0.6, this.h - 0.6, this.text, 'white', this.z);

          // 6. "NEXT" INDICATOR (Animated Arrow)
          let arrowBounce = Math.sin(Date.now() / 150) * 0.05;
          drawShape('tri', this.x , this.y + arrowBounce, this.z, 
                    0, 0, 
                    0.3, 0, 
                    0.15, 0.2, 
                    0, 0, 'gold', 1);
          break;
        }
    }
    
  }
  // Check if a touch coordinate (tx, ty) is inside the button
  isTouched(tx, ty) {
    // 1. Calculate the 'Visual' scale if you're using one (default to 1)
    let s = this.scale || 1.0; 
    
    // 2. Calculate the actual boundaries based on the grid
    // We add a tiny 'grace' buffer (0.05) to make clicking feel more responsive
    let buffer = 0.05;
    let xMin = this.x - buffer;
    let xMax = this.x + (this.l * this.z * s) + buffer;
    let yMin = this.y - buffer;
    let yMax = this.y + (this.h * this.z * s) + buffer;

    if (tx >= xMin && tx <= xMax && ty >= yMin && ty <= yMax) {
        // Calculate which side was hit for your 'seesaw' effects
        let midPoint = this.x + (this.l * this.z / 2);
        this.side = (tx < midPoint) ? -1 : 1;
        return true;
    }
    return false;
}
press(count = 2) {
    this.isPressed = true;
    this.wobbleMax = count;
    this.wobbleTimer = Date.now();
    // Keep the "active" state alive for the duration of the wobble
    // Each back-and-forth takes roughly 200ms
    setTimeout(() => { 
      this.isPressed = false; 
      if (this.index == 1){
        //Dungeon.x = 1.5;Dungeon.y = 1.5;
        if (this.foe == 'emperor'){
          startGame = 4;Foe.isCPU = 1;iRune.changeOwner(2);MusicEngine.stop();MusicEngine.playSFX('heal');MusicEngine.play(4);
        }else{
        startGame = 'tutorial';
        MusicEngine.playSFX('heal')
      }
        btnYes.visible = false;
        btnNo.visible = false;
        Dungeon.dCounter = 0;
      }
      if (this.index == 2){
        Dungeon.x = 7.5;Dungeon.y = 7.5;
        startGame = 'explore'
        Dungeon.dCounter = 0;
        btnYes.visible = false;
        btnNo.visible = false;
        MusicEngine.playSFX('cancel')
      }
      if (this.index == 0){
        if (startGame == 'jukebox'){
          MusicEngine.stop();
        }
      }
    }, count * 200);
  }
}
class Field{
  constructor(foe,isCPU = 0){
    this.foe = foe;  // player(0), foe(1) , examine(613)
    this.isCPU =isCPU;
      this.deck = [];
			this.hand = [];
      this.aMonster = [];
      this.draw = 0;					//value of 1 starts drawing animation
      this.equip = 0;
      this.option = 11;				//value of 1 displays option menu
      this.view;
      this.look = [0,0,0,0,-1,0,0,0,0];//F:0(field),D:1(deck),M:2(monster),H:3(hand),A:4(action),R:5(dice roll),P:6(stone)
      this.d2 = new Dice('d2');
      this.d4 = new Dice('d4');
      this.d6 = new Dice('d6');
      this.d8 = new Dice('d8');
      this.d10 = new Dice('d10');
      this.d12 = new Dice('d12');
      this.d20 = new Dice('d20');
      this.timer = 0;
      this.ax = 0;
      this.ay = 0;
      this.az = 1;
      this.at = 0;
      this.mOpt = 0;
      this.preOpt = 0;
      this.respawn = 0;
      this.defStat = 1;
      this.hasReroll = 0;
      this.hasWingedBoots = 0;
      this.hasStarPendant = 0;
      this.hasScalesOfJustice = 0;
      this.hasTreasureChest = 0;
      this.hasLovers = 0;
      this.hasBind = 0;
      this.hasLunacy = 0;
      this.diceType = 0;
      this.turnOrder = 0;
      this.turnCurrent = 0;
      this.runeStat = [0,0,0,0];
      /*
      if (this.foe == 0){
        this.deck.splice(0,0,new Card(16,foe));
        this.deck[0].locIndex = 0;		//stores card index
        this.deck[0].locCount = 0;
        this.deck[0].location = 'deck';		//stores card count in location
        this.deck.splice(1,0,new Card(15,foe));
        this.deck[1].locIndex = 1;		//stores card index
        this.deck[1].locCount = 1;
        this.deck[1].location = 'deck';		//stores card count in location
        this.deck.splice(2,0,new Card(12,foe));
        this.deck[2].locIndex = 2;		//stores card index
        this.deck[2].locCount = 2;
        this.deck[2].location = 'deck';		//stores card count in location
        this.deck.splice(3,0,new Card(18,foe));
        this.deck[3].locIndex = 3;		//stores card index
        this.deck[3].locCount = 3;
        this.deck[3].location = 'deck';		//stores card count in location
         this.deck.splice(4,0,new Card(1,foe));
        this.deck[3].locIndex = 4;		//stores card index
        this.deck[3].locCount = 4;
        this.deck[3].location = 'deck';		//stores card count in location
      }*/
    
    // --- DECK INITIALIZATION START ---

// 1. GENERATE: Create all 22 unique cards (indices 0 through 21).
for (let cardIndex = 0; cardIndex < 22; cardIndex++) {
    const newCard = new Card(cardIndex, foe);
    
    // Optional: Set initial properties if your Card constructor doesn't handle them
    newCard.locIndex = cardIndex; 
    newCard.locCount = cardIndex;
    newCard.location = 'deck';
    
    this.deck.push(newCard);
}

// 2. SHUFFLE: Apply the Fisher-Yates algorithm in place.
let currentIndex = this.deck.length; // Start at 22
let randomIndex;

// While there remain elements to shuffle (currentIndex goes from 22 down to 1).
while (currentIndex !== 0) {
    
    // Pick a remaining element (randomIndex will be between 0 and currentIndex - 1).
    randomIndex = Math.floor(Math.random() * currentIndex);
    currentIndex--; 

    // Swap the current element with the randomly picked element.
    // This is the array destructuring swap:
    [this.deck[currentIndex], this.deck[randomIndex]] = [
        this.deck[randomIndex], this.deck[currentIndex]
    ];
    
    // Optional: Update the location index for the card that moved to the 'current' position.
    this.deck[currentIndex].locIndex = currentIndex;
    
    // Note: The original monster-checking logic is removed as the deck is guaranteed 
    // to contain all 22 unique cards.
}

// --- DECK INITIALIZATION END ---
  }//end constructor
  //REFERENCE TO Foe or player
  get opponent() {
    // If "this" is the Player (0), return the Foe object
    if (this.foe === 0) {
      return Foe;
    } 
    // If "this" is the Foe (1), return the Player object
    else {
      return Player;
    }
  }
  //CPU HELPERS
  getWinChance(myStat, oppStat) {
    let wins = 0;
    let iterations = 50;
    
    // Safety check if monsters exist
    if (this.aMonster.length === 0 || this.opponent.aMonster.length === 0) return 0;

    for (let i = 0; i < iterations; i++) {
        // Simulate CPU Roll (Min + rand(Max-Min) + Mod)
        let myMin = this.aMonster[0].stat[myStat][eDICE.MIN];
        let myMax = this.aMonster[0].stat[myStat][eDICE.MAX];
        let myMod = this.aMonster[0].stat[myStat][eDICE.MOD];
        let myRoll = Math.floor(Math.random() * (myMax - myMin + 1) + myMin) + myMod;

        // Simulate Player Roll
        let opMin = this.opponent.aMonster[0].stat[oppStat][eDICE.MIN];
        let opMax = this.opponent.aMonster[0].stat[oppStat][eDICE.MAX];
        let opMod = this.opponent.aMonster[0].stat[oppStat][eDICE.MOD];
        let opRoll = Math.floor(Math.random() * (opMax - opMin + 1) + opMin) + opMod;

        if (myRoll > opRoll) wins++;
    }
    return wins / iterations; // Returns decimal (e.g., 0.75 for 75%)
  }
  cpuTurn() {
    // 1. If no monsters, we can't act (or logic for empty field handled elsewhere)
    if (this.aMonster.length === 0) return;
    let isBound = (this.hasBind > 0);
    let isSilenced = (this.hasLunacy > 0);
    let bestAction = { type: 0, index: 0, score: 0 }; // Default to Basic Attack
    
    // --- EVALUATE BASIC ATTACK ---
    // CPU STR vs Player CON (or AGI if Player might dodge, we can simulate standard CON first)
    let attackWinChance = this.getWinChance(eSTAT.S, eSTAT.C);
    
    // Base score is win chance * damage potential (estimated)
    let attackScore = (attackWinChance * 100); 
    
    // Psychic: If Player is attacking (0), prioritize defense/HP? 
    // If Player is using Card (>0), maybe rush them down?
    if (this.opponent.look[eLOOK.A] > 0) {
        attackScore += 10; // Aggression bonus if player is casting
    }
    
    bestAction.score = attackScore;

    // --- EVALUATE HAND CARDS ---
    for (let i = 0; i < this.hand.length; i++) {
        let card = this.hand[i];
        let cardScore = 0;

        // SPELLS (Type 2)
        if (card.type === 2) {
          if (isSilenced) continue;
            // Check INT vs INT
            let magicWinChance = this.getWinChance(eSTAT.I, eSTAT.I);
            
            if (card.subType === 'debuff') {
                // If we have high INT chance, debuffs are powerful
                cardScore = magicWinChance * 110; 
                // Specific logic: If it's Death (13) and chance > 80%, massive priority
                if (card.index === 13 && magicWinChance > 0.8) cardScore += 200;
            } else if (card.subType === 'buff') {
                // Buffs are good if Attack is weak
                if (attackWinChance < 0.4) cardScore = 80;
            } else if (card.subType === 'cast') {
                // Alchemy etc.
                cardScore = 70 + (magicWinChance * 20);
            }
        }
        
        // ITEMS (Type 1)
        else if (card.type === 1) {
          if (isBound || isSilenced) continue;
            if (card.subType === 3) { // Equip
                // Always good to equip early
                cardScore = 90; 
                // Winged Boots: High priority if AGI is decent but CON is low
                if (card.index === 7) cardScore += 20;
            }
            if (card.subType === 2) { // Use
                // Healing or situational
                cardScore = 60;
              // SOLAR RITE (19): Use if I am heavily debuffed OR Opponent is heavily buffed
                if (card.index === 19) {
                  let myMods = 0;
                  let oppMods = 0;
        
                  // Sum up STR(0), CON(1), INT(2), AGI(3) modifiers
                  for(let s=0; s<4; s++) {
                    myMods += this.aMonster[0].stat[s][eDICE.MOD];
                    oppMods += this.opponent.aMonster[0].stat[s][eDICE.MOD];
                  }
                  // Logic: 
                  // 1. If my mods are negative (I am Cursed/Debuffed) -> Good to clear
                  // 2. If opp mods are positive (They are Buffed/Equipped) -> Good to clear
                  // 3. Weight it: Clearing my debuffs is worth more than clearing their buffs
        
                  let utilityScore = (oppMods * 20) - (myMods * 20);
        
                  // Base score for simply playing a card
                  cardScore = 0 + utilityScore;
                }
                  // Horn of Judgement: Use if opponent has field advantage
                 // HORN OF JUDGEMENT (20): The "Reset Button"
                if (card.index === 20) {
                  // Calculate raw win chance for Attack
                  let winChance = this.getWinChance(eSTAT.S, eSTAT.C);
        
                  // Only consider nuking the board if:
                  // 1. My win chance is terrible (< 20%)
                  // 2. AND I have cards in my deck to draw a replacement (don't suicide if deck empty)
                  if (winChance < 0.20 && this.deck.length > 0) {
                    cardScore = 200; // Highest priority, Emergency!
                  } else {
                    cardScore = 0; // Never use if I'm winning
                  }
                }
              }
            }

            // Compare to current best
            if (cardScore > bestAction.score) {
                bestAction.score = cardScore;
                bestAction.type = card.type;
                bestAction.index = i; // Hand index
            }
      }

    // --- EXECUTE DECISION ---
    // If Attack (type 0) was best
    if (bestAction.type === 0 && bestAction.score === attackScore) {
        this.look[eLOOK.A] = 0; // Attack
    } else {
        // Play Card
        this.look[eLOOK.H] = bestAction.index; // Set pointer to hand index
        this.look[eLOOK.A] = this.hand[bestAction.index].type; // Set action type
    }

    // Lock in
    this.option = 5; // Ready state
  }
  cpuRuneSelect() {
    // 1. VICTORY CHECK: Do I already have 3 runes? If so, grab the 4th to win immediately.
    let myRunes = 0;
    let missingRune = -1;
    
    // Check which runes I own
    if (sRune.owner === this.foe) myRunes++; else missingRune = eSTAT.S;
    if (cRune.owner === this.foe) myRunes++; else missingRune = eSTAT.C;
    if (iRune.owner === this.foe) myRunes++; else missingRune = eSTAT.I;
    if (aRune.owner === this.foe) myRunes++; else missingRune = eSTAT.A;

    // If I have 3, targeting the missing one is Priority #1
    if (myRunes === 3 && missingRune !== -1) {
        this.look[eLOOK.S] = missingRune;
        return;
    }

    // 2. AVAILABILITY: Identify which runes are actually takable.
    // Rule: Take from Table (2) first. If Table empty, steal from Opponent.
    let available = [];
    
    // Check Table
    if (sRune.owner === 2) available.push(eSTAT.S);
    if (cRune.owner === 2) available.push(eSTAT.C);
    if (iRune.owner === 2) available.push(eSTAT.I);
    if (aRune.owner === 2) available.push(eSTAT.A);

    // If Table is empty, check Opponent (The "Steal" phase)
    if (available.length === 0) {
        if (sRune.owner === this.opponent.foe) available.push(eSTAT.S);
        if (cRune.owner === this.opponent.foe) available.push(eSTAT.C);
        if (iRune.owner === this.opponent.foe) available.push(eSTAT.I);
        if (aRune.owner === this.opponent.foe) available.push(eSTAT.A);
    }

    // Safety fallback (shouldn't happen unless logic error)
    if (available.length === 0) { 
        this.look[eLOOK.S] = eSTAT.S; 
        return; 
    }

    // 3. STRATEGY: Buff my weakest stat
    // If I have multiple options, pick the one where my current monster is weakest.
    // e.g. If my monster has 1d4 CON, I desperately want the CON rune.
    let bestRune = available[0];
    let lowestStatVal = 999;

    if (this.aMonster.length > 0) {
        for (let i = 0; i < available.length; i++) {
            let statType = available[i];
            // Check my monster's MAX potential for this stat
            let myVal = this.aMonster[0].stat[statType][eDICE.MAX];
            
            if (myVal < lowestStatVal) {
                lowestStatVal = myVal;
                bestRune = statType;
            }
        }
    }

    // Lock in the selection
    this.look[eLOOK.S] = bestRune;
  }
  cpuHandleReroll() {
    let myRoll = this.look[eLOOK.R];
    let oppRoll = this.opponent.look[eLOOK.R];
    let shouldReroll = false;

    // 1. CONTEXT CHECK
    // Are we in a contested roll? (Initiative, Attack, Defend, Debuff)
    // Most rolls in this game are contested.
    // Exception: Self-Buffs (Strength Spell) or non-combat items.
    
    let isContested = true;
    if (this.option === 8 && this.hand.length > 0 && this.look[eLOOK.H] < this.hand.length) {
        // If using a card, check if it's a buff
        if (this.hand[this.look[eLOOK.H]].subType === 'buff') isContested = false;
    }

    // 2. DECISION LOGIC
    if (isContested) {
        // If I am strictly losing or tied, REROLL.
        // (This makes the CPU very annoying/challenging to fight)
        if (myRoll <= oppRoll) {
            shouldReroll = true;
        }
    } else {
        // Uncontested (e.g. Casting Strength buff).
        // If my roll is poor (less than 60% of die max), reroll.
        // We use diceType (which stores the Max Die Value)
        if (myRoll < (this.diceType * 0.6)) {
            shouldReroll = true;
        }
    }

    // 3. EXECUTE
    // Find the Star Pendant to mark it as triggered
    let pendantIndex = -1;
    for (let i = 0; i < this.aMonster.length; i++) {
        if (this.aMonster[i].index == 17 && this.aMonster[i].effectTriggered == 0) {
            pendantIndex = i;
            break;
        }
    }

    if (pendantIndex !== -1) {
        this.aMonster[pendantIndex].effectTriggered = 1; // Mark used
        
        if (shouldReroll) {
            // YES: Reset timers to 0 to trigger the re-animation and re-roll
            this.ax = 0; this.ay = 0; this.az = 0; this.at = 0;this.hasReroll = 1;
            this.option = this.preOpt; // Go back to action
        } else {
            // NO: Just go back without resetting timers (keeps the current roll)
            this.option = this.preOpt; 
        }
    }
  }
  //UI HELPERS
  setDice(type,x,y,z,r,dt){
    if(type==4){this.d4.animate(x,y,z*1.5,r,dt);}
    if(type==6){this.d6.animate(x,y,z*1.5,r,dt);}
    if(type==8){this.d8.animate(x,y,z,r,dt);}
    if(type==10){this.d10.animate(x,y,z,r,dt);}
    if(type==12){this.d12.animate(x,y,z,r,dt);}
    if(type==20){this.d20.animate(x,y,z,r,dt);}
  }
  flip(){
    ctx.translate(wX/2,wY/2);
    ctx.rotate(Math.PI);
    ctx.translate(-wX/2,-wY/2);
  } 
  //GAMEPLAY FUNCTIONS
  react(dt){
    if (this.isCPU === 1 && this.opponent.option === 5 && this.option !== 5) {
        this.cpuTurn();
    }
    if (this.foe == 1){this.flip()}
    let tick = 30 * dt
    const SPEED_Y = 6 * dt; 
    const SPEED_Z = 3 * dt; 
    ctx.textAlign= 'left';
    let elem = 0;
    let debug = 0;
    if( debug == 1){
      drawText(0,1,1,.25,'P[A]:' + Player.look[eLOOK.A],'white',1);//Players intended action
      drawText(0,1.25,1,.25,'P[H]:' + Player.look[eLOOK.H],'white',1);//Current focus in hand
      drawText(0,1.5,1,.25,'P[M]:' + Player.look[eLOOK.M],'white',1);//current focus in monster field
      drawText(0,1.75,1,.25,'P[R]:' + Player.look[eLOOK.R],'white',1);//focused on rune
      drawText(0,2,1,.25,'F[A]:' + Foe.look[eLOOK.A],'white',1);
      drawText(0,2.25,1,.25,'F[H]:' + Foe.look[eLOOK.H],'white',1);
      drawText(0,2.5,1,.25,'F[M]:' + Foe.look[eLOOK.M],'white',1);
      drawText(0,2.75,1,.25,'F[R]:' + Foe.look[eLOOK.R],'white',1);
      drawText(0,3.25,1,.25,'FO:' + Foe.option,'white',1);//foe's current phase
      drawText(0,3,1,.25,'PO:' + Player.option,'white',1);
      drawText(0,3.5,1,.25,'Pat:' + Player.at,'white',1);//ani timer state
      drawText(0,3.75,1,.25,'Fat:' + Foe.at,'white',1);
      drawText(0,4,1,.25,'SG:' + startGame,'white',1);
    }
      switch(this.option){
        case 0:
          
          //drawText(9,9,1,1,"mL:"+this.aMonster.length+" dL:" +this.deck.length,"white",1)
          let rcount = 0; //count runes
          let runeQTY = 4;//total number of runes
          if (sRune.owner == this.foe) {sRune.changeOwner(this.foe)}
          if (cRune.owner == this.foe) {cRune.changeOwner(this.foe)}
          if (iRune.owner == this.foe) {iRune.changeOwner(this.foe)}
          if (aRune.owner == this.foe) {aRune.changeOwner(this.foe)}
          if (sRune.owner == this.foe) {rcount = rcount+1;}
          if (cRune.owner == this.foe) {rcount = rcount+1;}
          if (iRune.owner == this.foe) {rcount = rcount+1;}
          if (aRune.owner == this.foe) {rcount = rcount+1;}
          if (rcount == runeQTY){this.option = 'TRIUMPH';}else{rcount = 0} //if player has all runes, player wins animate a game over screen with crown on player side and broken sword on loser side?
          if (this.deck.length == 0 && this.aMonster.length == 0){this.option = 'DEFEAT';}
          rcount = 0
          if (sRune.owner == 1) {rcount = rcount+1;}
          if (cRune.owner == 1) {rcount = rcount+1;}
          if (iRune.owner == 1) {rcount = rcount+1;}
          if (aRune.owner == 1) {rcount = rcount+1;}

          if (startGame == 4||startGame == 6){
              if (rcount ==1){
                MusicEngine.stop();
              MusicEngine.play(0);
              }
              if (rcount ==2){
                MusicEngine.stop();
              MusicEngine.play(1);
              }
              if (rcount ==3){
                MusicEngine.stop();
              MusicEngine.play(3);
              }
              if (rcount ==0){
                MusicEngine.stop();
              MusicEngine.play(4);
              }
              
            startGame = 5;
          }
          break;
        case 1://hand menu visible
          drawPortrait(-22,this.hand[0].x + this.hand[0].l/1.39,5.68,.066);//eye Icon
          drawText(this.hand[this.look[eLOOK.H]].x +this.hand[0].l/1.63,5.33,1.5,1,'Examine','white',.8);//EXAMINE TEXT

          drawPortrait(-21,this.hand[0].x *.96,5.68,.066);//Use/Cast icon
          drawText(this.hand[this.look[eLOOK.H]].x-.05 ,5.33,1,1,'Use','white',.66);//USE/CAST TEXT
         break;
        case 2://hand examine
          drawShape('rec',0,0,1,0,0,10,10,0,0,0,0,'rgba(0,0,0,.75)',1);
          this.cardID(this.hand[0+this.look[eLOOK.H]].index)
         break;
        case 3://monster menu visible
         drawPortrait(-22,this.aMonster[0].x + this.aMonster[0].l/1.39,5.68,.066);//eye icon
         drawText(this.aMonster[0].x +this.aMonster[0].l/1.63,5.39,1.5,1,'Examine','white',.75);
         if (this.aMonster[this.look[eLOOK.M]].type == 0&&this.isCPU == 0){
         drawPortrait(-15,this.aMonster[0].x*.99,5.68,.066);//attack icon
         drawText(this.aMonster[this.look[eLOOK.M]].x -.15,5.39,1.13,1,'Attack','white',.75);}
         break;
        case 4://monster examine
          if (this.isCPU==1){this.flip();}///half the size of examine because player ready half screen taken
          drawShape('rec',0,0,1,0,0,10,10,0,0,0,0,'rgba(0,0,0,.75)',1);
          this.cardID(this.aMonster[0+this.look[eLOOK.M]].index)
          if (this.isCPU==1){this.flip();}
          break;
        case 5://ready
          if (Foe.isCPU == 1){} else{
         drawShape('rec',0,5,1,0,0,10,5,0,0,0,0,'rgba(0,0,0,.9)',1);
         if (this.look[eLOOK.A] >0) {
              this.hand[this.look[eLOOK.H]].place(1,6,1);
         }else{
           if (this.look[eLOOK.A] == 0){
             this.aMonster[0].place(1,6,1);
           }
         }
        
         drawText(4,5.5,4,1,'Player Ready','green',1.5);
         drawPortrait (-3,4.5,6,.4);
         drawText(1.755,5,1,1,'X','white',1.25);
        }
         if(this.foe == 0 && this.option == 5&&this.opponent.option == 5){
          this.option = 6;
          this.opponent.option = 6;
         }
         break;
        case 6://AGI Check
          if (startGame == 5||startGame == 7){
            song = rnd(0,3);
            if (song == 0){
              MusicEngine.stop();
              MusicEngine.play(5);
            }
            if (song == 1){
              MusicEngine.stop();
              MusicEngine.play(16);
            }
            if (song == 2){
              MusicEngine.stop();
              MusicEngine.play(17);
            }
            if (song == 3){
              MusicEngine.stop();
              MusicEngine.play(15);
            }    
            startGame = 6;
          }
          drawPortrait(-14,9,9,.1);//draw hourglass
          drawPortrait(-14,0,9,.1);//draw hourglass
          this.diceType = this.aMonster[0].stat[eSTAT.A][eDICE.MAX];
          if(this.at <31){this.at = this.at+tick;} //animation timer tick
          if (this.at > 31 && this.at < 36){this.at = 31}
          this.aMonster[0].place(3.88,5.5,1);//draw card in center
          //step 1. up and closer like flipping coin ay = animation y and az = animation z. 
          if (this.ay < 3 && this.at <=30){this.ay = this.ay+SPEED_Y;this.az = this.az + SPEED_Z;}
          //step2.Dice Falls
          if (this.ay >=3 && this.az !=1 && this.at<=30){this.az = this.az -SPEED_Z;}
          //step 4.Dice Stops
          if (this.ay >=3 && this.az ==1 && this.at<=30){
            this.setDice(this.diceType,8,6,1,.001,dt)
            drawText(7.7,5.6,1,1,''+this.look[eLOOK.R],'white',1);
          }
          //step 3.Dice Animate
          else{if (this.at < 30){
              this.setDice(this.diceType,8,9-this.ay,this.az,99,dt)
              this.look[eLOOK.R] = 0;
              this.look[eLOOK.R]=this.aMonster[0].rollStat(3);
            }
          }
          if (this.at > 30){//show result of roll and announce turns
            //DICE STOP
            this.setDice(this.diceType,8,6,1,.001,dt);
            drawText(7.7,5.6,1,1,''+this.look[eLOOK.R],'white',1);   
            //STAR PENDANT ACTIVATE////////////////////////
            if (this.hasStarPendant==1){
                for (let i = 0; i < this.aMonster.length; i++){
                  if (this.aMonster[i].index == 17 && this.aMonster[i].effectTriggered == 0){
                    this.preOpt = this.option;
                    this.option = 6.1;
                    if (this.foe == 1){this.flip()}
                    return
                  }
                }
              }
            ////////////////////////////////////////////
            if ( this.at==31&&this.opponent.at == 31 && this.opponent.option != 6.1){
              if (this.foe == 0){drawText(2.15,4.75,6,1,"Tap Screen To Continue",`rgba(${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)})`,1);}
              if (this.look[eLOOK.R]>this.opponent.look[eLOOK.R]){MessageBox.show(.5,6,1.5,2,1,'First','jrpg',1,this.foe)}
              else if (this.look[eLOOK.R]<this.opponent.look[eLOOK.R]){MessageBox.show(.5,6,1.5,2,.9,'Second','jrpg',1,this.foe)}
              else if (this.look[eLOOK.R]==this.opponent.look[eLOOK.R]){MessageBox.show(.5,6,1.5,2,.9,'Tie - Roll Again!','jrpg',1,this.foe)}
            }
            if (this.at ==36){
              if (this.look[eLOOK.R]>this.opponent.look[eLOOK.R]){
                MessageBox.show(.5,6,1.5,2,1,'First','jrpg',1,this.foe)
                this.option = 8;
                this.turnCurrent = 1;
                this.turnOrder = 1;
                this.ay = 0;
                this.az = 0;
                this.at = 0
                //Star Pendant Reset///////////
                if (this.hasStarPendant == 1){
                  for (let i = 0; i < this.aMonster.length; i++){
                    if (this.aMonster[i].index == 17 && this.aMonster[i].effectTriggered == 1){
                      this.aMonster[i].effectTriggered = 0;
                    }
                  }
                }
                ////////////////////////////////////         
              }
              else if (this.look[eLOOK.R]<this.opponent.look[eLOOK.R]){//second, player moves to opt 7 first defend
                MessageBox.show(.5,6,1.5,2,.9,'Second','jrpg',1,this.foe)
                this.option = 7;
                this.defStat = 1; //0 str, 1 con, 2, int, 3, agi
                this.turnCurrent = 2;
                this.turnOrder = 2; 
                this.ay = 0;
                this.az = 0;
                this.at = 0;
                //Star Pendant Reset///////////
                if (this.hasStarPendant == 1){
                    for (let i = 0; i < this.aMonster.length; i++){
                      if (this.aMonster[i].index == 17 && this.aMonster[i].effectTriggered == 1){
                        this.aMonster[i].effectTriggered = 0;
                      }
                    }
                  }
                /////////////////////////////////     
                //end >69
              }//end second
              else if (this.look[eLOOK.R]==this.opponent.look[eLOOK.R]){//Tie, roll again by resetting tick counters
                //DICE ROLL STOP
                this.setDice(this.diceType,8,6,1,.001,dt)
                ////////////////
                drawText(7.7,5.6,1,1,''+this.look[eLOOK.R],'white',1);
                MessageBox.show(.5,6,1.5,2,.9,'Tie - Roll Again!','jrpg',1,this.foe)
                //reset all counters after enough time to read message
                this.ay = 0;
                this.az = 0;
                this.at = 0
                //Star Pendant Reset///////////
                if (this.hasStarPendant == 1){
                    for (let i = 0; i < this.aMonster.length; i++){
                      if (this.aMonster[i].index == 17 && this.aMonster[i].effectTriggered == 1){
                        this.aMonster[i].effectTriggered = 0;
                      }
                    }
                  }
                /////////////////////////////////  
              }
            }//end show result of roll and announce turns
          }//>32
          break;
        case 7://DEFEND
          switch(this.opponent.look[eLOOK.A]){
            case 0://reacting to monster attack from Foe
              this.aMonster[0].place(3.88,5.5,1);
              //Winged Boots 6.2 EFFECT ACTIVATE
              if (this.hasWingedBoots==1&&this.opponent.hasScalesOfJustice <1&&this.opponent.hasBind <1){
                for (let i = 0; i < this.aMonster.length; i++){
                  if (this.aMonster[i].index == 7 && this.aMonster[i].effectTriggered == 0){
                    this.preOpt = this.option;
                    this.option = 6.2;
                    if (this.foe == 1){this.flip()}
                    return
                  }
                }
              }
              //SET BORDER GRAPHICS AND SET DICE TYPE FOR ROLLS
              if (this.opponent.hasScalesOfJustice == 1){//scales of justice
                drawPortrait(11,9,9,.1);
                drawPortrait(11,0,9,.1);
                //drawPortrait(11,9,5,.1);
                //drawPortrait(11,0,5,.1);
                this.diceType = 12
              }
              else if(this.opponent.hasScalesOfJustice ==2 ||this.opponent.hasScalesOfJustice == 3 ){
                drawPortrait(14,9,9,.1);
                drawPortrait(14,0,9,.1);
                //drawPortrait(14,9,5,.1);
                //drawPortrait(14,0,5,.1);
                this.at = 0;
                this.ay = 0;
                this.az = 0;
                if (this.foe == 1){this.flip()}
                return;
              }
              else if ( this.opponent.hasScalesOfJustice == 4){
                if (this.look[eLOOK.STAT]== eSTAT.S){
                  drawPortrait(-11,9,9,.1);
                  drawPortrait(-11,0,9,.1);
                  //drawPortrait(-11,9,5,.1);
                  //drawPortrait(-11,0,5,.1);
                  this.diceType = this.aMonster[0].stat[eSTAT.S][eDICE.MAX]
                }
                if (this.look[eLOOK.STAT]== eSTAT.C){
                  drawPortrait(-13,9,9,.1);
                  drawPortrait(-13,0,9,.1);
                  //drawPortrait(-13,9,5,.1);
                  //drawPortrait(-13,0,5,.1);
                  this.diceType = this.aMonster[0].stat[eSTAT.C][eDICE.MAX]
                }
                if (this.look[eLOOK.STAT]== eSTAT.I){
                  drawPortrait(-12,9,9,.1);
                  drawPortrait(-12,0,9,.1);
                  //drawPortrait(-12,9,5,.1);
                  //drawPortrait(-12,0,5,.1);
                  this.diceType = this.aMonster[0].stat[eSTAT.I][eDICE.MAX]
                }
                if (this.look[eLOOK.STAT]== eSTAT.A){
                  drawPortrait(-14,9,9,.1);
                  drawPortrait(-14,0,9,.1);
                  //drawPortrait(-14,9,5,.1);
                  //drawPortrait(-14,0,5,.1);
                  this.diceType = this.aMonster[0].stat[eSTAT.A][eDICE.MAX]
                }
              }
              //DEF graphics/////
              else if (this.defStat == 1){//CON
                drawPortrait(-13,9,9,.1);
                drawPortrait(-13,0,9,.1);
                //drawPortrait(-13,9,5,.1);
                //drawPortrait(-13,0,5,.1);
                this.diceType = this.aMonster[0].stat[eSTAT.C][eDICE.MAX]
             }
              else if (this.defStat == 3){//AGI
                drawPortrait(-14,9,9,.1);
                drawPortrait(-14,0,9,.1);
                //drawPortrait(-14,9,5,.1);
                //drawPortrait(-14,0,5,.1);
                this.diceType = this.aMonster[0].stat[eSTAT.A][eDICE.MAX]
              } 
              ///////////////
              //ACTIVATE FOE BIND?
              if (this.opponent.hasBind>0){
                if (this.foe == 1){this.flip()}
                return;
              }
              /////////
              if(this.at <30){this.at = this.at+tick;}
              else if(this.at>=36){this.at = this.at+tick;} //animation timer tick              
              else  if(this.at>=30&&this.at < 36){this.at = 31;}
              if (this.ay < 3 && this.at <=30){//step 1. Start Dice Ani Timers. up and closer like flipping coin ay = animation y and az = animation z. if coin has not completed path, keep adding to y and z
                this.ay = this.ay + SPEED_Y;
                this.az = this.az + SPEED_Z;
              }             
              if (this.ay >=3 && this.az >1 && this.at<=30){//step2.Dice switches from comin up to going down. gets smaller as it falls to table
                  this.az = this.az - SPEED_Z;
              }
              if (this.ay >=3 && this.az <1 && this.at<=30){//step 4.dice stops rolling
                //DICE ROLL STOP
                this.setDice(this.diceType,8,6,1,.001,dt)
                drawText(7.7,5.6,1,1,''+this.look[eLOOK.R],'white',1);
              }
              else{//step 3.Dice continues to roll until it completes path
                if (this.at <= 30){
                  //DICE ROLL ANIMATE
                  this.setDice(this.diceType,8,9-this.ay,this.az,99,dt)
                  ////////////////
                  this.look[eLOOK.R] = 0;
                  if (this.defStat == 1){this.look[eLOOK.R]=this.aMonster[0].rollStat(eSTAT.C);}
                  if (this.defStat == 3){this.look[eLOOK.R]=this.aMonster[0].rollStat(eSTAT.A);}
                  //Scales of justice activate 
                  if (this.opponent.hasScalesOfJustice == 1){this.look[eLOOK.R] = rnd(1,12);}
                  ////////////////////
                  //Alchemy Activate
                  if ( this.opponent.hasScalesOfJustice == 4){
                    if (this.look[eLOOK.STAT]== eSTAT.S){this.look[eLOOK.R] = this.aMonster[0].rollStat(eSTAT.S);}
                    if (this.look[eLOOK.STAT]== eSTAT.C){this.look[eLOOK.R] = this.aMonster[0].rollStat(eSTAT.C);}
                    if (this.look[eLOOK.STAT]== eSTAT.I){this.look[eLOOK.R] = this.aMonster[0].rollStat(eSTAT.I);}
                    if (this.look[eLOOK.STAT]== eSTAT.A){this.look[eLOOK.R] = this.aMonster[0].rollStat(eSTAT.A);
                    }
                  }
                  ///////
                  
                  drawPortrait(-16,4.5-this.at*.005,7-(this.at*.05),.1+this.at*.001);
                  MessageBox.show(.5,6,1.5,2,1,this.aMonster[0].name + ' defends!','jrpg',1,this.foe)
                }
              }
              if (this.at > 30){//step 5. roll results
                //DICE ROLL STOP
                this.setDice(this.diceType,8,6,1,.001,dt)
                drawText(7.7,5.6,1,1,''+this.look[eLOOK.R],'white',1);
                //STAR PENDANT EFFECT ACTIVATE////
                if (this.hasStarPendant==1){
                  for (let i = 0; i < this.aMonster.length; i++){
                    if (this.aMonster[i].index == 17 && this.aMonster[i].effectTriggered == 0){
                      this.preOpt = this.option;
                      this.option = 6.1;
                      if (this.foe == 1){this.flip()}
                      return
                    }
                  }
                }
                /////////////////////////////
                if (this.at==31&&this.opponent.at == 31&&this.opponent.option != 6.1 && this.opponent.option != 6.2){
                  if(this.foe == 0){drawText(2.15,4.75,6,1,"Tap Screen To Continue",`rgba(${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)})`,1);}
                  MessageBox.show(.5,6,1.5,2,1,this.aMonster[0].name + ' defends!','jrpg',1,this.foe)
                }
                //Wait for a this.at+1
                if (this.at >= 36){
                  if (this.opponent.look[eLOOK.R]>this.look[eLOOK.R]){//if PSTR > PCON,  monster dies, goes to 12 to reset field allow player to claim stone
                    
                    MessageBox.show(.5,6,1.5,2,1,this.opponent.aMonster[0].name+' slays '+ this.aMonster[0].name + '!','jrpg',1,this.foe)
                   
                    drawPortrait(3.2,4.5-this.at*.001,7,.1+this.at*.001);
                    drawShape('rec',0,0,1,3.88,5.4,2.25,3.55,0,0,0,0,`rgba(0,0,0,${(.3+this.at*.01)})`,1);
                    if (this.at > 69){
                      this.option = 10;
                      this.ay = 0;
                      this.az = 0;
                      this.at = 0
                    }   
                  }//end Player fail to defend
                  if (this.opponent.look[eLOOK.R]<=this.look[eLOOK.R]){//if PSTR <= FCON, lives goes on to 10 to second attack
                  
                     
                    MessageBox.show(.5,6,1.5,2,1,this.aMonster[0].name + ' resists ' + this.opponent.aMonster[0].name+ '!','jrpg',1,this.foe)
                    drawPortrait(-16,4.5-this.at*.005,7-this.at*.03,.1+this.at*.001);
                    if (this.at > 69){
                      if (this.turnOrder == 1){this.option = 11;}
                      if (this.turnOrder == 2){this.option = 8;}
                      this.ay = 0;
                      this.az = 0;
                      this.at = 0
                      //STAR PENDANT RESET
                      if (this.hasStarPendant == 1){
                        for (let i = 0; i < this.aMonster.length; i++){
                          if (this.aMonster[i].index == 17 && this.aMonster[i].effectTriggered == 1){
                            this.aMonster[i].effectTriggered = 0;
                          }
                        }
                      }          
                      ////////////////////////////   
                      //Winged Boots reset
                      if (this.hasWingedBoots == 1){
                        for (let i = 0; i < this.aMonster.length; i++){
                          if (this.aMonster[i].index == 7 && this.aMonster[i].effectTriggered == 1){
                            this.aMonster[i].effectTriggered = 0;
                          }
                        }
                      }
                      ////////////////////////
                    }
                  }//end Player Defends
                }//>=32
              }//>30
              break;
            case 1://reacting to item use by foe
              this.aMonster[0].place(3.88,5.5,1);
              drawPortrait(-13,9,9,.1);
              drawPortrait(-13,0,9,.1);
              //drawPortrait(-13,9,5,.1);
              //drawPortrait(-13,0,5,.1);
              if (this.opponent.option == 11){this.option = 11}
              if (this.opponent.option == 7){this.option = 8}
            break;
            case 2://reacting to spell use by foe
              this.aMonster[0].place(3.88,5.5,1);
              drawPortrait(-13,9,9,.1);
              drawPortrait(-13,0,9,.1);
              //drawPortrait(-13,9,5,.1);
              //drawPortrait(-13,0,5,.1);
              //Do NOT ACTIVATE STAR PENDANT FOR FOE STRENGTH SPELL
              if (this.opponent.at == 101&& this.opponent.hand[this.opponent.look[eLOOK.H]].index != 8){
                //Star Pendant Activate//////////////// 
                if (this.hasStarPendant==1){
                  for (let i = 0; i < this.aMonster.length; i++){
                    if (this.aMonster[i].index == 17 && this.aMonster[i].effectTriggered == 0){
                      this.preOpt = this.option;
                      this.option = 6.1;
                      if (this.foe == 1){this.flip()}
                      return
                    }
                  }
                }
                ///////////////
              }
              if (this.opponent.option == 11){this.option = 11}
              if (this.opponent.option == 7){this.option = 8}
              break;
          
            }//end switch (foe.look[eLOOK.A])
          break;//end case 7
        case 8://ATTACK
          switch(this.look[eLOOK.A]){
            case 0://MONSTER attack against foe
              //Activate Bind
              if (this.hasBind > 0){
                this.aMonster[0].place(3.88,5.5,1);
                this.at= this.at+1
                this.opponent.at = 0;
                this.opponent.ay = 0;
                this.opponent.az = 0;
                drawPortrait(12,9,9,.1);
                drawPortrait(12,0,9,.1);
                drawPortrait(12,9,5,.1);
                drawPortrait(12,0,5,.1);
                MessageBox.show(.5,6,1.5,2,1,this.aMonster[0].name + ' cannot act!','jrpg',1,this.foe)
                if (this.at>69){
                  this.hasBind = this.hasBind - 1;
                  if (this.hasBind == 0) {
                      for (let i = 0; i < this.aMonster.length; i++) {
                          if (this.aMonster[i].index == 12) { // 12 is the Bind card ID
                              this.aMonster.splice(i, 1); // Remove it from the field
                              break; // Stop looking
                          }
                      }
                  }
                  if (this.turnOrder == 1){
                    this.option = 7;
                    this.opponent.option = 8;
                  }
                  if (this.turnOrder == 2){
                    this.option = 11;
                    this.opponent.option = 11;
                  }
                  this.at = 0;
                  this.ay = 0;
                  this.az = 0;
                }
                if (this.foe == 1){this.flip()}
                return;
                
              }
              //Scales of justice graphics
              if (this.hasScalesOfJustice == 1){
                drawPortrait(11,9,9,.1);
                drawPortrait(11,0,9,.1);
                //drawPortrait(11,9,5,.1);
                //drawPortrait(11,0,5,.1);
                this.diceType = 12;
              }
              //Alchemy activate Step 1
              else if (this.hasScalesOfJustice == 2|| this.hasScalesOfJustice == 3){
                drawPortrait(14,9,9,.1);
                drawPortrait(14,0,9,.1);
                //drawPortrait(14,9,5,.1);
                //drawPortrait(14,0,5,.1);
                
                if (this.hand[this.look[eLOOK.H]].effectTriggered == 0){
                  this.preOpt = this.option;
                  this.option = 6.3;
                  if (this.foe == 1){this.flip()}
                  return
                }
              }
              //Alchemy activate step 2
              else if ( this.hasScalesOfJustice == 4){
                if (this.look[eLOOK.STAT]== eSTAT.S){
                  drawPortrait(-11,9,9,.1);
                  drawPortrait(-11,0,9,.1);
                  //drawPortrait(-11,9,5,.1);
                  //drawPortrait(-11,0,5,.1);
                  this.diceType = this.aMonster[0].stat[eSTAT.S][eDICE.MAX]
                }
                if (this.look[eLOOK.STAT]== eSTAT.C){
                  drawPortrait(-13,9,9,.1);
                  drawPortrait(-13,0,9,.1);
                  //drawPortrait(-13,9,5,.1);
                  //drawPortrait(-13,0,5,.1);
                  this.diceType = this.aMonster[0].stat[eSTAT.C][eDICE.MAX]
                }
                if (this.look[eLOOK.STAT]== eSTAT.I){
                  drawPortrait(-12,9,9,.1);
                  drawPortrait(-12,0,9,.1);
                  //drawPortrait(-12,9,5,.1);
                  //drawPortrait(-12,0,5,.1);
                  this.diceType = this.aMonster[0].stat[eSTAT.I][eDICE.MAX]
                }
                if (this.look[eLOOK.STAT]== eSTAT.A){
                  drawPortrait(-14,9,9,.1);
                  drawPortrait(-14,0,9,.1);
                  //drawPortrait(-14,9,5,.1);
                  //drawPortrait(-14,0,5,.1);
                  this.diceType = this.aMonster[0].stat[eSTAT.A][eDICE.MAX]
                }

              }
              /////////////
              else{//STR attack graphics
                drawPortrait(-11,9,9,.1);
                drawPortrait(-11,0,9,.1);
                //drawPortrait(-11,9,5,.1);
                //drawPortrait(-11,0,5,.1);
                this.diceType = this.aMonster[0].stat[eSTAT.S][eDICE.MAX]
              }
              if(this.at <30){this.at = this.at+tick;}
              else if (this.at >=36){this.at = this.at+tick;}
              else if (this.at <36 &&this.at>=30){this.at = 31;} //animation timer tick
              this.aMonster[0].place(3.88,5.5,1);
              
              if (this.ay < 3 && this.at <30){//step 1. up and closer like flipping coin ay = animation y and az = animation z. if coin has not completed path, keep adding to y and z
                this.ay = this.ay + SPEED_Y;
                this.az = this.az + SPEED_Z;
              }
              if (this.ay >3 && this.az > 1 && this.at<30){//step2.coin gets smaller as it falls to table
                this.az = this.az - SPEED_Z;
              }
              if (this.ay >=3 && this.az <=1 && this.at<30){//step 4.coin stops
                //DICE ROLL STOP
                this.setDice(this.diceType,8,6,1,.001,dt)
                drawText(7.7,5.6,1,1,''+this.look[eLOOK.R],'white',1);
              }
              //step 3.draws the dice if still hasnt completed path, rolls STR stat at the same time
              else{if (this.at <= 30){
                //DICE ROLL ANIMATED
                this.setDice(this.diceType,8,9-this.ay,this.az,99,dt)
                this.look[eLOOK.R] = 0;
                this.look[eLOOK.R]=this.aMonster[0].rollStat(eSTAT.S);
                 //scales of justice activate/////////
                if (this.hasScalesOfJustice == 1){this.look[eLOOK.R] = rnd(1,12);}
                //////////
                //Alchemy activate
                if ( this.hasScalesOfJustice == 4){
                  if (this.look[eLOOK.STAT]== eSTAT.S){this.look[eLOOK.R] = this.aMonster[0].rollStat(eSTAT.S);}
                  if (this.look[eLOOK.STAT]== eSTAT.C){this.look[eLOOK.R] = this.aMonster[0].rollStat(eSTAT.C);}
                  if (this.look[eLOOK.STAT]== eSTAT.I){this.look[eLOOK.R] = this.aMonster[0].rollStat(eSTAT.I);}
                  if (this.look[eLOOK.STAT]== eSTAT.A){this.look[eLOOK.R] = this.aMonster[0].rollStat(eSTAT.A);}
                }
                ////////
                
                  MessageBox.show(.5,6,1.5,2,1,this.aMonster[0].name + ' attacks ' + this.opponent.aMonster[0].name + '!','jrpg',1,this.foe)
                
                drawPortrait(-20,4.5-this.at*.005,7-(this.at*.05),.1+this.at*.001);
                }
              }
              if (this.at > 30){//step 5: roll results
                //DICE ROLL STOP
                this.setDice(this.diceType,8,6,1,.001,dt)
                drawText(7.7,5.6,1,1,''+this.look[eLOOK.R],'white',1);
                //Star Pendant Activate//////////////// 
                if (this.hasStarPendant==1){
                  for (let i = 0; i < this.aMonster.length; i++){
                    if (this.aMonster[i].index == 17 && this.aMonster[i].effectTriggered == 0){
                      this.preOpt = this.option;
                      this.option = 6.1;
                      if (this.foe == 1){this.flip()}
                      return
                    }
                  }
                }
                ///////////////
                if (this.at==31&&this.opponent.at == 31&&this.opponent.option != 6.1 && this.opponent.option != 6.2){
                  if(this.foe == 0){drawText(2.15,4.75,6,1,"Tap Screen To Continue",`rgba(${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)})`,1);}
                  MessageBox.show(.5,6,1.5,2,1,this.aMonster[0].name + ' attacks ' + this.opponent.aMonster[0].name + '!','jrpg',1,this.foe)
                }
                //WAIT FOR AT+1 from player click
                if (this.at>=36){
                  if (this.look[eLOOK.R]>this.opponent.look[eLOOK.R]){
                    drawPortrait(-20,4.5-this.at*.005,7-(this.at*.051),.1+this.at*.001);
                    
                      MessageBox.show(.5,6,1.5,2,1,this.opponent.aMonster[0].name + ' is slain!','jrpg',1,this.foe)
                    
                    if (this.at > 69){
                      MusicEngine.playSFX('death');
                      this.option = 9;//get runestones option
                      this.ay = 0;
                      this.az = 0;
                      this.at = 0
                      //activate Lovers///////////
                      if (this.hasLovers > 0 && this.hasLovers <3 ){
                        this.aMonster[0].stat[eSTAT.S][eDICE.MOD]=this.aMonster[0].stat[eSTAT.S][eDICE.MOD] + 1;
                        this.aMonster[0].stat[eSTAT.C][eDICE.MOD]=this.aMonster[0].stat[eSTAT.C][eDICE.MOD] + 1;
                        this.hasLovers = this.hasLovers + 1;
                      }
                      //////////////////////////////////
                      //Star Pendant Reset//////////////////////
                      if (this.hasStarPendant == 1){
                        for (let i = 0; i < this.aMonster.length; i++){
                          if (this.aMonster[i].index == 17 && this.aMonster[i].effectTriggered == 1){
                            this.aMonster[i].effectTriggered = 0;
                          }
                        }
                      } 
                      /////////////////////////////
                      //scales of justice deactivate/////////////////////////
                      if (this.hasScalesOfJustice == 1){this.hasScalesOfJustice = 0;}
                      ///////////////////////////////
                      //Alchemy deactivate
                      if (this.hasScalesOfJustice == 4){
                        this.look[eLOOK.STAT] = 0;
                        this.opponent.look[eLOOK.STAT] = 0;
                        this.hand.splice(this.look[eLOOK.H],1);
                        this.look[eLOOK.H] = 0;
                        this.hasScalesOfJustice = 0;
                      } 
                      ////////////////
                    }   
                  }
                  if (this.look[eLOOK.R]<=this.opponent.look[eLOOK.R]){
                    
                      MessageBox.show(.5,6,1.5,2,1,this.opponent.aMonster[0].name + ' resists the attack!','jrpg',1,this.foe)
                    
                    drawPortrait(-20,4.5-this.at*.005,7-this.at*.04,.1+this.at*.001);
                    if (this.at > 69){
                      this.defStat = 1; //0 str, 1 con, 2, int, 3, agi 
                      if (this.turnOrder == 1){this.option = 7;}
                      if (this.turnOrder == 2){this.option = 11;}
                      this.ay = 0;
                      this.az = 0;
                      this.at = 0
                      //Star Pendant Reset//////////////////////
                      if (this.hasStarPendant == 1){
                        for (let i = 0; i < this.aMonster.length; i++){
                          if (this.aMonster[i].index == 17 && this.aMonster[i].effectTriggered == 1){
                            this.aMonster[i].effectTriggered = 0;
                          }
                        }
                      } 
                      /////////////////////////////
                      //scales of justice deactivate////////////////////////
                      if (this.hasScalesOfJustice == 1){this.hasScalesOfJustice = 0;}
                      ////////////////////// 
                      //Alchemy deactivate
                      if (this.hasScalesOfJustice == 4){
                        this.look[eLOOK.STAT] = 0;
                        this.opponent.look[eLOOK.STAT] = 0;
                        this.hand.splice(this.look[eLOOK.H],1);
                        this.look[eLOOK.H] = 0;
                        this.hasScalesOfJustice = 0;
                      }
                      /////////////////
                    }//>69 for foe defends
                  }//foe defends
                }//>=32
              }//>30             
              break;
            case 1://ITEM either to player or foe
              if (this.hasBind > 0){
                this.aMonster[0].place(3.88,5.5,1);
                this.at= this.at+1
                this.opponent.at = 0;
                this.opponent.ay = 0;
                this.opponent.az = 0;
                drawPortrait(12,9,9,.1);
                drawPortrait(12,0,9,.1);
                drawPortrait(12,9,5,.1);
                drawPortrait(12,0,5,.1);
                MessageBox.show(.5,6,1.5,2,1,this.aMonster[0].name + ' cannot act!','jrpg',1,this.foe)                
                if (this.at>69){
                  this.hasBind = this.hasBind - 1;
                  if (this.hasBind == 0) {
                      for (let i = 0; i < this.aMonster.length; i++) {
                          if (this.aMonster[i].index == 12) { // 12 is the Bind card ID
                              this.aMonster.splice(i, 1); // Remove it from the field
                              break; // Stop looking
                          }
                      }
                  }
                  if (this.turnOrder == 1){
                    this.option = 7;
                    this.opponent.option = 8;
                  }
                  if (this.turnOrder == 2){
                    this.option = 11;
                    this.opponent.option = 11;
                  }
                  this.at = 0;
                  this.ay = 0;
                  this.az = 0;
                }
                if (this.foe == 1){this.flip()}
                return;
                
              }
              //////////////
              //Activate Lunacy
              if (this.hasLunacy > 0){
                this.aMonster[0].place(3.88,5.5,1);
                this.at= this.at+1
                this.opponent.at = 0;
                this.opponent.ay = 0;
                this.opponent.az = 0;     
                drawPortrait(18,9,9,.1);
                drawPortrait(18,0,9,.1);
                drawPortrait(18,9,5,.1);
                drawPortrait(18,0,5,.1);
                MessageBox.show(.5,6,1.5,2,1,this.aMonster[0].name + ' cannot act!','jrpg',1,this.foe)
                if (this.at>69){
                  this.hasLunacy = this.hasLunacy - 1;
                  if (this.hasLunacy == 0) {
                      for (let i = 0; i < this.aMonster.length; i++) {
                          if (this.aMonster[i].index == 18) { // 12 is the Bind card ID
                              this.aMonster.splice(i, 1); // Remove it from the field
                              break; // Stop looking
                          }
                      }
                  }
                  if (this.turnOrder == 1){
                    this.option = 7;
                    this.opponent.option = 8;
                  }
                  if (this.turnOrder == 2){
                    this.option = 11;
                    this.opponent.option = 11;
                  }
                  this.at = 0;
                  this.ay = 0;
                  this.az = 0;
                }
                if (this.foe == 1){this.flip()}
                return;
              }
              /////////
              this.defStat = 1; //0 str, 1 con, 2, int, 3, agi 
              drawPortrait(-21,9,9,.1);
              drawPortrait(-21,0,9,.1);
              //drawPortrait(-21,9,5,.1);
              //drawPortrait(-21,0,5,.1);
              this.at = this.at+tick;
              if (this.at > 159&&this.hand[this.look[eLOOK.H]].index == 10){
                //TREASURE CHEST DRAWS MONSTER HERE
              }
              else{this.aMonster[0].place(3.88,5.5,1);}
              //MOVE ITEM FROM HAND TO CENTER OF FIELD
              if (this.at <= 30){this.hand[this.look[eLOOK.H]].place(1+((2.875/30)*this.at),7.5-((2/30)*this.at),1);}
              //GLOW EFFECT TO INDICATE USE
              if (this.at > 30 && this.at <=60){
                this.hand[this.look[eLOOK.H]].place(3.88,5.5,1);
                drawShape('rec',3.88,5.5,1,0,0,2.25,3.55,0,0,0,0,`rgba(255,255,0,${.1+this.at*.01})`,1);
              }
              if (this.at > 69){
                //check for subtype - 2:use, 3:equip
                switch (this.hand[this.look[eLOOK.H]].subType){
                  case 2://use
                    //horn of judgement
                    if (this.hand[this.look[eLOOK.H]].index == 20){
                        this.hand.splice(this.look[eLOOK.H],1);
                        this.look[eLOOK.H] = 0;
                        this.option = 10;
                        this.opponent.option = 10;
                        this.at = 0;
                        this.hasWingedBoots = 0;
                        this.hasStarPendant = 0;
                        this.hasScalesOfJustice = 0;
                        this.hasTreasureChest = 0;
                        this.hasLovers = 0;
                        this.hasBind = 0;
                        this.hasLunacy = 0;
                        this.opponent.hasWingedBoots = 0;
                        this.opponent.hasStarPendant = 0;
                        this.opponent.hasScalesOfJustice = 0;
                        this.opponent.hasTreasureChest = 0;
                        this.opponent.hasLovers = 0;
                        this.opponent.hasBind = 0;
                        this.opponent.hasLunacy = 0;
                        if (this.foe == 1){this.flip()}
                      return
                    }
                    //scales of justice
                    if (this.hand[this.look[eLOOK.H]].index == 11){
                      this.hand.splice(this.look[eLOOK.H],1);
                      this.look[eLOOK.H] = 0;
                      this.hasScalesOfJustice = 1;
                      this.look[eLOOK.A] = 0;
                      this.at = 0;
                      if (this.foe == 1){this.flip()}
                      return
                    }
                    //treasure chest 
                    if (this.hand[this.look[eLOOK.H]].index == 10){
                      if (this.deck.length > 0){
                        if (this.at <= 99){//move from deck to middle
                          this.deck[0].location = 'hand'
                          this.deck[0].place(7-((2.875/30)*(this.at-69)),7.5-((2/30)*(this.at-69)),1);
                        }
                        if (this.at > 99 && this.at <=129){  //display center        
                          this.deck[0].place(3.88,5.5,1) 

                        }
                        if (this.at > 129 && this.at <= 159){//move from center to hand
                          this.deck[0].place(3.88-((2.875/30)*(this.at-129)),5.5+((2/30)*(this.at-129)),1);
                          
                        }
                        if (this.at > 159){//put in hand/swap monster/dont swap
                          if (this.deck[0].type == 0){//if monster
                            this.deck[0].place(1.5,6.5,1)
                            this.aMonster[0].place(6,6.5,1);
                            drawText(2.15,5,6,1,'Swap out active monster?','white',1)
                            drawText(1.9,5.75,6,1,'Yes                   No','white',1)
                            if (this.hasTreasureChest == 0) {this.hasTreasureChest = 1}
                            // --- CPU TREASURE CHEST LOGIC START ---
                            if (this.isCPU === 1 && this.hasTreasureChest === 1) {
                                // 1. Calculate Score for Current Monster (Sum of Max Stats + Mods)
                                // Note: Current monster stats ALREADY include equipped item buffs, 
                                // which is correct because swapping loses those items.
                                let currentScore = 0;
                                for(let s=0; s<4; s++) {
                                    currentScore += this.aMonster[0].stat[s][eDICE.MAX] + this.aMonster[0].stat[s][eDICE.MOD];
                                }

                                // 2. Calculate Score for New Monster (Raw Stats)
                                let newScore = 0;
                                for(let s=0; s<4; s++) {
                                    newScore += this.deck[0].stat[s][eDICE.MAX] + this.deck[0].stat[s][eDICE.MOD];
                                }

                                // 3. Smart Decision
                                // If the new monster is stronger, take it.
                                if (newScore > currentScore) {
                                    this.hasTreasureChest = 2; // Yes (Swap)
                                } else {
                                    this.hasTreasureChest = 3; // No (Discard)
                                }
                                if (this.foe == 1){this.flip()}
                                return; // Exit frame to let the swap logic execute next tick
                            }
                            // --- CPU TREASURE CHEST LOGIC END ---
                            //yes
                            if (this.hasTreasureChest == 2){
                              this.aMonster.length = 0;
                              this.aMonster.push(this.deck.shift());
                              this.aMonster[0].location = 'field';
                              this.look[eLOOK.M] = 0;
                              if (this.turnOrder==1){this.option = 7}
                              if (this.turnOrder==2){this.option = 11}
                              this.at = 0;
                              this.hand.splice(this.look[eLOOK.H],1);
                              this.look[eLOOK.H] = 0;
                              this.hasTreasureChest = 0;
                              this.hasWingedBoots = 0;
                              this.hasStarPendant = 0;
                              this.hasScalesOfJustice = 0;
                              this.hasLovers = 0;
                              this.hasBind = 0;
                              this.hasLunacy = 0;
                              if (this.foe == 1){this.flip()}
                              return
                            }
                            //no
                            if (this.hasTreasureChest == 3){
                              this.hand.splice(this.look[eLOOK.H],1);
                              this.deck.splice(0,1);
                              this.look[eLOOK.H] = 0;
                              
                              this.hasTreasureChest = 0;
                              if (this.turnOrder==1){this.option = 7}
                              if (this.turnOrder==2){this.option = 11}
                              this.at = 0;
                              if (this.foe == 1){this.flip()}
                              return

                            }
                          }
                          //item
                          else{
                            this.hand.push(this.deck.shift());
                            this.at = 69;
                            if (this.foe == 1){this.flip()}
                            return
                          }
                          
                        }
                      } 
                      //no cards in deck
                      else{
                        this.hand.splice(this.look[eLOOK.H],1);
                        this.look[eLOOK.H] = 0;
                        if (this.turnOrder==1){this.option = 7}
                        if (this.turnOrder==2){this.option = 11}
                        this.at = 0;
                        if (this.foe == 1){this.flip()}
                        return;
                      }
                    
                    }
                    //Solar Rite
                    if (this.hand[this.look[eLOOK.H]].index == 19){
                      let tempindex = this.aMonster[0].index
                      this.aMonster.length = 0;
                      this.aMonster[0] = new Card(tempindex,0)
                      this.aMonster[0].location = 'field';
                      this.aMonster[0].foe = this.foe;
                      this.look[eLOOK.M] = 0;
                      this.aMonster[0].locIndex = 0;
                      this.aMonster[0].locCount = 1;

                      tempindex = this.opponent.aMonster[0].index
                      this.opponent.aMonster.length = 0;
                      this.opponent.aMonster[0] = new Card(tempindex,1)
                      this.opponent.aMonster[0].location = 'field';
                      this.opponent.look[eLOOK.M] = 0;
                      this.opponent.aMonster[0].foe = this.opponent.foe;
                      this.opponent.aMonster[0].locIndex = 0;
                      this.opponent.aMonster[0].locCount = 1;
                      
                      this.hasWingedBoots = 0;
                      this.hasStarPendant = 0;
                      this.hasScalesOfJustice = 0;
                      this.hasTreasureChest = 0;
                      this.hasLovers = 0;
                      this.hasLunacy = 0;
                      this.hasBind = 0;
                      this.opponent.hasWingedBoots = 0;
                      this.opponent.hasStarPendant = 0;
                      this.opponent.hasScalesOfJustice = 0;
                      this.opponent.hasTreasureChest = 0;
                      this.opponent.hasLovers = 0;
                      this.opponent.hasBind = 0;
                      this.opponent.hasLunacy = 0;
                      if (sRune.owner == this.foe) {sRune.changeOwner(this.foe)}
                      if (cRune.owner == this.foe) {cRune.changeOwner(this.foe)}
                      if (iRune.owner == this.foe) {iRune.changeOwner(this.foe)}
                      if (aRune.owner == this.foe) {aRune.changeOwner(this.foe)}
                      if (sRune.owner == this.opponent.foe) {sRune.changeOwner(this.opponent.foe)}
                      if (cRune.owner == this.opponent.foe) {cRune.changeOwner(this.opponent.foe)}
                      if (iRune.owner == this.opponent.foe) {iRune.changeOwner(this.opponent.foe)}
                      if (aRune.owner == this.opponent.foe) {aRune.changeOwner(this.opponent.foe)}
                      if (this.turnOrder==1){this.option = 7}
                      if (this.turnOrder==2){this.option = 11}
                      this.at = 0;
                      this.hand.splice(this.look[eLOOK.H],1);
                      this.look[eLOOK.H] = 0;
                      if (this.foe == 1){this.flip()}
                      return;
                    }

                    break;
                  case 3://equip
                    this.draw = 0;
                    this.aMonster.push(this.hand.splice(this.look[eLOOK.H],1)[0]) 
                    this.look[eLOOK.H] = 0;
                    this.aMonster[this.aMonster.length - 1].location = "field";
                    this.aMonster[this.aMonster.length - 1].locCount = this.aMonster.length - 1;
                    this.aMonster[this.aMonster.length-1].locIndex = this.aMonster.length-1;
                    this.at = 0;
                    //winged boots
                    if (this.aMonster[this.aMonster.length - 1].index == 7){
                      this.aMonster[0].stat[3][2]= this.aMonster[0].stat[3][2]+3;
                      this.hasWingedBoots = 1;
                    }
                    //star penddant
                    if (this.aMonster[this.aMonster.length - 1].index == 17){
                      this.hasStarPendant = 1;
                    }
                    //Lovers
                    if (this.aMonster[this.aMonster.length - 1].index == 6){
                      this.hasLovers = 1;
                      this.aMonster[0].stat[eSTAT.S][eDICE.MOD]=this.aMonster[0].stat[eSTAT.S][eDICE.MOD] + 1;
                      this.aMonster[0].stat[eSTAT.C][eDICE.MOD]=this.aMonster[0].stat[eSTAT.C][eDICE.MOD] + 1;
                    }
                    if (this.turnOrder==1){this.option = 7}
                    if (this.turnOrder==2){this.option = 11}
                    this.at = 0;
                    this.ay = 0; 
                    this.az = 0;
                    break;
                }      
                
              }
            break;           
            case 2: //SPELL either on player or foe
              
            //Activate Lunacy
              if (this.hasLunacy > 0){
                this.aMonster[0].place(3.88,5.5,1);
                this.at= this.at+1
                this.opponent.at = 0;
                this.opponent.ay = 0;
                this.opponent.az = 0;     
                drawPortrait(18,9,9,.1);
                drawPortrait(18,0,9,.1);
                drawPortrait(18,9,5,.1);
                drawPortrait(18,0,5,.1);
                MessageBox.show(.5,6,1.5,2,1,this.aMonster[0].name + ' cannot act!','jrpg',1,this.foe)
                if (this.at>69){
                  this.hasLunacy = this.hasLunacy - 1;
                  if (this.hasLunacy == 0) {
                      for (let i = 0; i < this.aMonster.length; i++) {
                          if (this.aMonster[i].index == 18) { // 12 is the Bind card ID
                              this.aMonster.splice(i, 1); // Remove it from the field
                              break; // Stop looking
                          }
                      }
                  }
                  if (this.turnOrder == 1){
                    this.option = 7;
                    this.opponent.option = 8;
                  }
                  if (this.turnOrder == 2){
                    this.option = 11;
                    this.opponent.option = 11;
                  }
                  this.at = 0;
                  this.ay = 0;
                  this.az = 0;
                }
                if (this.foe == 1){this.flip()}
                return;
              }
              /////////
              this.defStat = 1; //0 str, 1 con, 2, int, 3, agi 
              if (this.at < 69) {//Draw USE/CAST on Border
                drawPortrait(-21, 9, 9, .1);
                drawPortrait(-21, 0, 9, .1);
                //drawPortrait(-21, 9, 5, .1);
                //drawPortrait(-21, 0, 5, .1);
              }
              if(this.at <100&&this.opponent.option != 6.1){this.at = this.at+tick;}
              else if (this.at >=106){this.at = this.at+tick;}
              else if (this.at <106 &&this.at>100){this.at = 101;}
              this.aMonster[0].place(3.88, 5.5, 1);

              //STEP 1. move card from hand to center of field
              if (this.at <= 30) {this.hand[this.look[eLOOK.H]].place(1 + ((2.875 / 30) * this.at), 7.5 - ((2 / 30) * this.at), 1);}
              //STEP 2. GLOW ANIMATION
              if (this.at > 30 && this.at <= 60) {
                this.hand[this.look[eLOOK.H]].place(3.88, 5.5, 1);
                drawShape('rec', 3.88, 5.5, 1, 0, 0, 2.25, 3.55, 0, 0, 0, 0, `rgba(255,255,0,${.1+this.at*.01})`, 1);
              }
              //STEP 3. Draw Spell Graphics & Logic
              if (this.at > 69) {
                if (this.opponent.hasReroll == 1){
                  this.at = 69; this.ay = 0; this.az = 0;
                  this.opponent.hasReroll = 2;
                }
                drawPortrait(-12, 9, 9, .1);
                drawPortrait(-12, 0, 9, .1);
                //drawPortrait(-12, 9, 5, .1);
                //drawPortrait(-12, 0, 5, .1);
                this.diceType = this.aMonster[0].stat[eSTAT.I][eDICE.MAX];
                //check for subtype - debuff, buff, cast
                switch (this.hand[this.look[eLOOK.H]].subType) {
                  case 'buff':
                    //ANIMATION LOGIC
                    this.aMonster[0].place(3.88, 5.5, 1);
                    // Dice Move UP Closer to Player
                    if (this.ay < 3 && this.at < 100) {this.ay = this.ay + SPEED_Y;this.az = this.az + SPEED_Z;}
                    //Dice Moves down toward table
                    if (this.ay >= 3 && this.az > 1 && this.at < 100) { this.az = this.az - SPEED_Z;}
                    //Dice stops rolling after it finishes its up and down motion
                    if (this.ay >= 3 && this.az <= 1 && this.at < 100) {
                      // DICE STOP
                      this.setDice(this.diceType, 8, 6, 1.5, .0001, dt); 
                      drawText(7.7, 5.6, 1, 1, '' + this.look[eLOOK.R], 'white', 1);
                      
                    } 
                    //animate dice roll while it moves up and down
                    else {if (this.at < 100) {
                      // DICE Animate
                      this.setDice(this.diceType, 8, 9 - this.ay, this.az, 99, dt);
                      this.look[eLOOK.R] = 0;
                      this.look[eLOOK.R] = this.aMonster[0].rollStat(eSTAT.I);
                      //Battle message and graphic    
                      if (this.foe == 1&&this.isCPU == 1){this.flip();}
                      MessageBox.show(.5,6,1.5,2,1,this.aMonster[0].name + ' mutters an incantation...','jrpg',1,0)     
                      if (this.foe == 1&&this.isCPU == 1){this.flip();}
                      //Strength Spell Graphic..
                      if (this.hand[this.look[eLOOK.H]].index == 8) {
                        drawPortrait(8, 4.5 - this.at * .005, 7 - this.at * .003, .1 + this.at * .001);
                      }
                      //add graphics for other spells here also
                      }
                    }
                    //Roll Results
                    if (this.at > 100) {
                      //Dice Stop
                      this.setDice(this.diceType, 8, 6, 1.5, .0001, dt);
                      drawText(7.7, 5.6, 1, 1, '' + this.look[eLOOK.R], 'white', 1);
                      
                      // Star Pendant Activate
                      if (this.hasStarPendant == 1) {
                        for (let i = 0; i < this.aMonster.length; i++) {
                          if (this.aMonster[i].index == 17 && this.aMonster[i].effectTriggered == 0) {
                            this.preOpt = this.option;
                            this.option = 6.1;
                            if (this.foe == 1){this.flip()}
                            return;
                          }
                        }
                      }
                      ////////////////                  
                      if (this.at == 101) {
                        //Spell Message (&& Wait for click for AT+1?)
                        if (this.foe == 1&&this.isCPU == 1){this.flip();}
                        
                        if (this.hand[this.look[eLOOK.H]].index == 8) {MessageBox.show(.5,6,1.5,2,1,this.aMonster[0].name + ' gains + ' + this.look[eLOOK.R] + ' to STR rolls !','jrpg',1,0)  }
                        if (this.foe == 1&&this.isCPU == 1){this.flip();}
                        if (this.foe == 1){this.flip();}
                        drawText(2.15, 4.75, 6, 1, "Tap Screen To Continue", `rgba(${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)})`, 1);
                        if (this.foe == 1){this.flip();}
                      }
                      //Apply effect and clean up
                      if (this.at >= 102) {
                        // Apply specific stats based on Index
                        if (this.hand[this.look[eLOOK.H]].index == 8) {
                          this.aMonster[0].stat[eSTAT.S][eDICE.MOD] = this.aMonster[0].stat[eSTAT.S][eDICE.MOD] + this.look[eLOOK.R];
                        }
                        //Cleanup

                          if (this.turnOrder == 1){this.option = 7;}
                          if (this.turnOrder == 2){this.option = 11;}
                          this.hand.splice(this.look[eLOOK.H], 1);
                          this.look[eLOOK.H] = 0;
                          this.ay = 0; this.az = 0; this.at = 0;
                          if (this.foe == 1){this.flip()}
                          return;
                        
                      }
                    }
                break; // End Buff
                  case 'debuff':
                    this.flip();
                    drawPortrait(-12, 9, 9, .1);
                    drawPortrait(-12, 0, 9, .1);
                    //drawPortrait(-12, 9, 5, .1);
                    //drawPortrait(-12, 0, 5, .1);
                    this.flip();
                    //ANIMATION LOGIC
                    this.diceType = this.aMonster[0].stat[eSTAT.I][eDICE.MAX];
                    this.opponent.diceType = this.opponent.aMonster[0].stat[eSTAT.I][eDICE.MAX];
                    this.aMonster[0].place(3.88, 5.5, 1);
                    if (this.ay < 3 && this.at < 100) {this.ay = this.ay + SPEED_Y;this.az = this.az + SPEED_Z;}
                    if (this.ay > 3 && this.az > 1 && this.at < 100) {this.az = this.az - SPEED_Z;}
                    // DICE STOPPED
                    if (this.ay > 3 && this.az <= 1 && this.at < 100) {
                      if (this.opponent.hasReroll == 0){
                      this.setDice(this.diceType, 8, 6, 1.5, .0001, dt);
                      drawText(7.7, 5.6, 1, 1, '' + this.look[eLOOK.R], 'white', 1);
                      }
                      this.flip();
                      this.opponent.setDice(this.opponent.diceType, 8, 6, 1.5, .0001, dt);
                      drawText(7.7, 5.6, 1, 1, '' + this.opponent.look[eLOOK.R], 'white', 1);
                      this.flip()
                    } 
                    // DICE ROLLING
                    else {if (this.at < 100) {
                      // Player Roll
                      if (this.opponent.hasReroll == 0){
                      this.setDice(this.diceType, 8, 9 - this.ay, this.az, 99, dt);
                      this.look[eLOOK.R] = 0;
                      this.look[eLOOK.R] = this.aMonster[0].rollStat(eSTAT.I);}
                      // Foe Roll
                      this.flip();
                      this.opponent.setDice(this.opponent.diceType, 8, 9 - this.ay, this.az, 99, dt);
                      this.flip();
                      this.opponent.look[eLOOK.R] = 0;
                      this.opponent.look[eLOOK.R] = this.opponent.aMonster[0].rollStat(eSTAT.I);
                      //Battle Message && Spell Graphic (on foe)
                      if (this.foe == 1&&this.isCPU == 1){this.flip();}
                      MessageBox.show(.5,6,1.5,2,1,this.aMonster[0].name + ' mutters an incantation...','jrpg',1,0)  
                      if (this.foe == 1&&this.isCPU == 1){this.flip();}
                      this.flip();
                      if (this.hand[this.look[eLOOK.H]].index == 15) drawPortrait(15, 4.5 - this.at * .005, 5 - this.at * .003, .1 + this.at * .001); //Curse
                      if (this.hand[this.look[eLOOK.H]].index == 12) drawPortrait(15, 4.5 - this.at * .005, 5 - this.at * .003, .1 + this.at * .001); //Bind
                      if (this.hand[this.look[eLOOK.H]].index == 13) drawPortrait(13, 4.5 - this.at * .005, 5 - this.at * .003, .1 + this.at * .001); //Death
                      if (this.hand[this.look[eLOOK.H]].index == 16) drawPortrait(13, 4.5 - this.at * .005, 5 - this.at * .003, .1 + this.at * .001); //Ruin
                      if (this.hand[this.look[eLOOK.H]].index == 18) drawPortrait(15, 4.5 - this.at * .005, 5 - this.at * .003, .1 + this.at * .001); //Lunacy
                      this.flip();
                      }
                    }
                    //Roll Results
                    if (this.at > 100) {
                      //DICE STOP
                      this.setDice(this.diceType, 8, 6, 1.5, .0001, dt);
                      drawText(7.7, 5.6, 1, 1, '' + this.look[eLOOK.R], 'white', 1);
                      //DICE STOP FOE
                      this.flip();
                      this.opponent.setDice(this.opponent.diceType, 8, 6, 1.5, .0001, dt);
                      drawText(7.7, 5.6, 1, 1, '' + this.opponent.look[eLOOK.R], 'white', 1);
                      this.flip();
                      //Star Pendant Check////NEED TO ADD FOR OPPONENT AS WELL
                      if (this.hasStarPendant == 1) {
                        for (let i = 0; i < this.aMonster.length; i++) {
                          if (this.aMonster[i].index == 17 && this.aMonster[i].effectTriggered == 0) {
                            this.preOpt = this.option;
                            this.option = 6.1;
                            if (this.foe == 1){this.flip()}
                            return;
                          }
                        }
                      }
                      ////////////
                      
                      if (this.opponent.hasReroll == 2){this.opponent.hasReroll = 0;}
                      if (this.at >= 101&&this.at <106&&this.opponent.option!= 6.1){
                        
                        
                        if (this.foe == 1){this.flip();}
                        drawText(2.15, 4.75, 6, 1, "Tap Screen To Continue", `rgba(${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)})`, 1);
                        if (this.foe == 1){this.flip();}
                        
                        if (this.foe == 1&&this.isCPU == 1){this.flip();}
                        if (this.look[eLOOK.R] > this.opponent.look[eLOOK.R]) {
                          // Success Messages
                          
                          if (this.hand[this.look[eLOOK.H]].index == 15) MessageBox.show(.5,6,1.5,2,1,this.opponent.aMonster[0].name + ' suffers - ' + (this.look[eLOOK.R] - Foe.look[eLOOK.R]),'jrpg',1,0);
                          if (this.hand[this.look[eLOOK.H]].index == 12) MessageBox.show(.5,6,1.5,2,1,this.opponent.aMonster[0].name + ' cannot act!','jrpg',1,0);
                          if (this.hand[this.look[eLOOK.H]].index == 13) MessageBox.show(.5,6,1.5,2,1,this.opponent.aMonster[0].name + ' succumbs to the spell!','jrpg',1,0);
                          if (this.hand[this.look[eLOOK.H]].index == 16) MessageBox.show(.5,6,1.5,2,1,this.opponent.aMonster[0].name + ' succumbs to the spell!','jrpg',1,0);
                          if (this.hand[this.look[eLOOK.H]].index == 18)  MessageBox.show(.5,6,1.5,2,1,this.opponent.aMonster[0].name + ' falls under a spell!','jrpg',1,0);
                        } 
                        else {MessageBox.show(.5,6,1.5,2,1,this.opponent.aMonster[0].name + ' resists the spell!','jrpg',1,0)}
                        if (this.foe == 1&&this.isCPU == 1){this.flip();}
                      }
                      ////////////
                      if (this.at >= 106) {
                        
                        
                        
                      }
                      //Apply Effect
                      if (this.at >= 109) {
                        if (this.look[eLOOK.R] > this.opponent.look[eLOOK.R]) {
                          // Curse (15)
                          if (this.hand[this.look[eLOOK.H]].index == 15) {
                              this.opponent.aMonster[0].stat[eSTAT.S][eDICE.MOD] = this.aMonster[0].stat[eSTAT.S][eDICE.MOD] - (this.look[eLOOK.R] - this.opponent.look[eLOOK.R]);
                              this.opponent.aMonster[0].stat[eSTAT.C][eDICE.MOD] = this.aMonster[0].stat[eSTAT.C][eDICE.MOD] - (this.look[eLOOK.R] - this.opponent.look[eLOOK.R]);
                              this.opponent.aMonster[0].stat[eSTAT.I][eDICE.MOD] = this.aMonster[0].stat[eSTAT.I][eDICE.MOD] - (this.look[eLOOK.R] - this.opponent.look[eLOOK.R]);
                              this.opponent.aMonster[0].stat[eSTAT.A][eDICE.MOD] = this.aMonster[0].stat[eSTAT.A][eDICE.MOD] - (this.look[eLOOK.R] - this.opponent.look[eLOOK.R]);
                          }
                          // Bind (12)
                          if (this.hand[this.look[eLOOK.H]].index == 12) {
                            this.draw = 0;
                            this.look[eLOOK.INDEX] = 12;
                            this.opponent.aMonster.push(this.hand.splice(this.look[eLOOK.H], 1)[0])
                            this.look[eLOOK.H] = 0;
                            this.opponent.aMonster[this.opponent.aMonster.length - 1].location = "field";
                            this.opponent.aMonster[this.opponent.aMonster.length - 1].locCount = this.opponent.aMonster.length - 1;
                            this.opponent.aMonster[this.opponent.aMonster.length - 1].locIndex = this.opponent.aMonster.length - 1;
                            this.opponent.aMonster[this.opponent.aMonster.length - 1].foe = this.foe;
                            this.opponent.hasBind = this.look[eLOOK.R] - this.opponent.look[eLOOK.R];
                          }
                          // Death (13) - Special return case
                          if (this.hand[this.look[eLOOK.H]].index == 13) {
                            this.hand.splice(this.look[eLOOK.H], 1);
                            this.look[eLOOK.H] = 0;
                            this.opponent.option = 10;
                            this.option = 9;
                            this.ay = 0; this.az = 0; this.at = 0;
                            if (this.foe == 1){this.flip()}
                            return; // Death exits early
                          }
                          // Ruin (16)
                          if (this.hand[this.look[eLOOK.H]].index == 16) {
                            let tempindex = this.opponent.aMonster[0].index
                            this.opponent.aMonster.length = 0;
                            this.opponent.aMonster[0] = new Card(tempindex, 1)
                            this.opponent.aMonster[0].location = 'field';
                            this.opponent.aMonster[0].foe = this.opponent.foe;
                            this.opponent.look[eLOOK.M] = 0;
                            this.opponent.aMonster[0].locIndex = 0;
                            this.opponent.aMonster[0].locCount = 1;
                            this.opponent.hand.length = 0;
                            this.opponent.look[eLOOK.A] = 0;
                            this.opponent.hasTreasureChest = 0;
                            this.opponent.hasWingedBoots = 0;
                            this.opponent.hasStarPendant = 0;
                            this.opponent.hasScalesOfJustice = 0;
                            this.opponent.hasLovers = 0;
                            this.opponent.hasBind = 0;
                            if (sRune.owner == this.opponent.foe) {sRune.changeOwner(this.opponent.foe)}
                            if (cRune.owner == this.opponent.foe) {cRune.changeOwner(this.opponent.foe)}
                            if (iRune.owner == this.opponent.foe) {iRune.changeOwner(this.opponent.foe)}
                            if (aRune.owner == this.opponent.foe) {aRune.changeOwner(this.opponent.foe)}
                          }
                          // Lunacy (18)
                          if (this.hand[this.look[eLOOK.H]].index == 18) {
                            this.draw = 0;
                            this.look[eLOOK.INDEX] = 18
                            this.opponent.aMonster.push(this.hand.splice(this.look[eLOOK.H], 1)[0])
                            this.look[eLOOK.H] = 0;
                            this.opponent.aMonster[this.opponent.aMonster.length - 1].location = "field";
                            this.opponent.aMonster[this.opponent.aMonster.length - 1].locCount = this.opponent.aMonster.length - 1;
                            this.opponent.aMonster[this.opponent.aMonster.length - 1].locIndex = this.opponent.aMonster.length - 1;
                            this.opponent.aMonster[this.opponent.aMonster.length - 1].foe = this.foe;
                            this.opponent.hasLunacy = this.look[eLOOK.R] - this.opponent.look[eLOOK.R];
                          }
                        }
                        //Cleanup
                        
                            if (this.turnOrder == 1){this.option = 7;}
                            if (this.turnOrder == 2){this.option = 11;}
                            //Exclude Lunacy and Bind because these 'equip' to monster 
                            if (this.look[eLOOK.INDEX] != 12 && this.look[eLOOK.INDEX]!= 18) {
                              this.hand.splice(this.look[eLOOK.H], 1);
                              this.look[eLOOK.H] = 0;
                            }else{this.look[eLOOK.INDEX] = 0}
                            this.ay = 0; this.az = 0; this.at = 0;
                            if (this.foe == 1){this.flip()}
                            return;
                        
                      }//end at>102
                    }//at>100
                    break; // End Debuff
                  case 'cast':
                    //Alchemy
                    if (this.hand[this.look[eLOOK.H]].index == 14) {
                      this.hasScalesOfJustice = 2;
                      this.look[eLOOK.A] = 0;
                      this.at = 0;
                      if (this.foe == 1){this.flip()}
                      return;
                    }
                    break; // End Cast
                } //switch subtype
              } //>69
            break; //spell        
          }//switch action
          break;//opt 8       
        case 9://Triumph if opponent monster is  get runes,
          if (startGame == 6){
            MusicEngine.stop();
            MusicEngine.play(8); 
            startGame = 7         
          }
          // --- CPU RUNE LOGIC START ---
          // If I am CPU and haven't selected yet (at <= 0 is the "waiting" state)
          if (this.isCPU === 1 && this.at <= 0) {
              this.cpuRuneSelect(); // Pick the best rune
              this.at = 1;          // Start the "Grab" animation immediately
          }
          // --- CPU RUNE LOGIC END ---
          if (this.at <= 0){
            if (this.at < -613){this.at = 0}
            this.at = this.at - 1;
            if (this.at % 5 == 0||this.at % 3 == 0||this.at % 2 == 0||this.at % 7 == 0||this.at % 9 == 0){
              drawText(2.1,6,6,.75,"Please Select Runestone",`rgba(${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)})`,1);
            }
          }
          if (this.at>0){
            this.at = this.at+tick;
          }
          
          switch(this.look[eLOOK.S]){
            case eSTAT.S:
              if (this.at > 31) sRune.changeOwner(this.foe); // Trigger movement
              break;
            case eSTAT.C:
              if (this.at > 31) cRune.changeOwner(this.foe);
              break;
            case eSTAT.I:
              if (this.at > 31) iRune.changeOwner(this.foe);
              break;
            case eSTAT.A:
              if (this.at > 31) aRune.changeOwner(this.foe);
              break;
          }

          // Wait for animation to finish
          if (this.at > 31){
            this.at = 0;
            this.option = 11;
            
            }
          break;//end case 11 TRIUMPH
        case 10://Defeat if monster is  draw til new monster,
          if (this.draw == 0){
            this.aMonster.length = 0;
            this.hasWingedBoots = 0;
            this.hasStarPendant = 0;
            this.hasScalesOfJustice = 0;
            this.hasTreasureChest = 0;
            this.hasLovers = 0;
            this.hasBind = 0;
            this.hasLunacy = 0;
            this.draw = 1;
            this.option = 11;
            
          }
          
          break;//end case 12
        case 11://check for victory and defeat. if no victory or defeat go back to option 0
          if (this.foe == 1 &&this.option == 11 && this.opponent.option == 11){
            this.option = 0;
            this.opponent.option = 0;
          }
          break;
        case 'DEFEAT':
          
          this.opponent.option = "TRIUMPH";
          
          //vscpu
          if (this.foe == 0 && this.opponent.isCPU == 1){
            ctx.fillStyle = "rgba(39,39,39,1)";
	          ctx.fillRect(0,0,wX,wY);
            drawShape('rec',0,0,1,0,0,10,10,0,0,0,0,'black',1)
            drawText(2.5,4,5,3,'DEFEAT','white',1);
            drawText(2.65, 8, 8, 0.8, "Tap to Restart", `rgba(255,255,255,${0.6 + 0.4 * Math.sin(Date.now() / 400)})`, 1);
          }

          //vs human
          if (this.foe == 0 && this.opponent.isCPU == 0){
            ctx.fillStyle = "rgba(39,39,39,1)";
	          ctx.fillRect(0,0,wX,wY);
            drawShape('rec',0,0,1,0,0,10,10,0,0,0,0,'black',1)
            drawText(2.5,7.5,5,3,'DEFEAT','white',1);
            this.flip();
            drawText(2.5,7.5,5,3,'TRIUMPH','gold',1);
            this.flip()
            drawText(2.5, 5, 8, 0.8, "Tap to Restart", `rgba(255,215,0,${0.6 + 0.4 * Math.sin(Date.now() / 400)})`, 1);
          }
          
          if (this.foe == 0 && startGame == 6){
            MusicEngine.stop();
            MusicEngine.play(6); 
            startGame = 7         
          }
            
          
          
          break;
        case "TRIUMPH":
          
          this.opponent.option = "DEFEAT";
          
          //vscpu
          if (this.foe == 0 && this.opponent.isCPU == 1){
            ctx.fillStyle = "rgba(39,39,39,1)";
	          ctx.fillRect(0,0,wX,wY);
            drawShape('rec',0,0,1,0,0,10,10,0,0,0,0,'black',1)
            drawText(2.5,4,5,3,'TRIUMPH','gold',1);
            drawText(2.65, 8, 8, 0.8, "Tap to Restart", `rgba(255,215,0,${0.6 + 0.4 * Math.sin(Date.now() / 400)})`, 1);
          
          }
          //vs human
          if (this.foe == 0 && this.opponent.isCPU == 0){
            ctx.fillStyle = "rgba(39,39,39,1)";
	          ctx.fillRect(0,0,wX,wY);
            drawShape('rec',0,0,1,0,0,10,10,0,0,0,0,'black',1)
            drawText(2.5,7.5,5,3,'TRIUMPH','gold',1);
            this.flip();
            drawText(2.5,7.5,5,3,'DEFEAT','gold',1);
            this.flip()
            drawText(2.5, 5, 8, 0.8, "Tap to Restart", `rgba(255,215,0,${0.6 + 0.4 * Math.sin(Date.now() / 400)})`, 1);
          }
          
          if (this.foe == 0&&startGame == 6){
            MusicEngine.stop();
            MusicEngine.play(3); 
            startGame = 7         
            }
            
          break;
        case 6.1://reroll
          // --- CPU REROLL LOGIC START ---
          if (this.isCPU === 1) {
              this.cpuHandleReroll();
              if (this.foe == 1){this.flip()}
              return; // Exit this frame so we don't draw the menu
          }
          // --- CPU REROLL LOGIC END ---
          
          this.aMonster[0].place(3.88,6.5,1);
            for (let i = 0; i < this.aMonster.length; i++){
              if (this.aMonster[i].index == 17 && this.aMonster[i].effectTriggered == 0){
                this.setDice(this.diceType,8,6,1,.001,dt)
                drawText(7.7,5.6,1,1,''+this.look[eLOOK.R],'white',1);
                drawText(3.75,5,5,.75,'Re-roll?','white',1)
                drawText(2.6,5.75,5,1,'Yes        No','white',1)
                drawPortrait(17,9,9,.1);
                drawPortrait(17,0,9,.1);
                drawPortrait(17,9,5,.1);
                drawPortrait(17,0,5,.1);
                
              }    
            }        
          break;
        case 6.2://winged boots/prompt between turns
        // --- CPU WINGED BOOTS LOGIC ---
          if (this.isCPU === 1 && this.at == 0) {
             let myAGI = this.aMonster[0].stat[3][1] + this.aMonster[0].stat[3][2]; // Max + Mod
             let myCON = this.aMonster[0].stat[1][1] + this.aMonster[0].stat[1][2];
             
             if (myAGI > myCON) {
                 this.defStat = 3; // Switch to AGI
             } else {
                 this.defStat = 1; // Stay CON
             }
             
             // Mark used
             for (let i = 0; i < this.aMonster.length; i++){
                if (this.aMonster[i].index == 7) this.aMonster[i].effectTriggered = 1;
             }
             this.option = this.preOpt;
             if (this.foe == 1){this.flip()}
             return;
          }
          // -----------------------------
        this.aMonster[0].place(3.88,6.5,1);
          if (this.hasWingedBoots == 1){
            for (let i = 0; i < this.aMonster.length; i++){
              if (this.aMonster[i].index == 7 && this.aMonster[i].effectTriggered == 0&& this.at == 0){
                drawText(3.4,5,4,1,'Defend with AGI ?','white',1)
                drawText(2.6,5.75,5,1,'Yes        No','white',1)
                drawPortrait(7,9,9,.1);
                drawPortrait(7,0,9,.1);
                //drawPortrait(7,9,5,.1);
                //drawPortrait(7,0,5,.1);
              }    
            }
          }else{this.option = this.preOpt}
        break;
        case 6.3://Alchemy stat pick
         this.aMonster[0].place(3.88,5.5,1);
          // --- CPU ALCHEMY LOGIC ---
         if (this.isCPU === 1 && this.at == 0) {
             // 1. Pick MY Best Stat (Attack)
             let bestStat = eSTAT.S;
             let maxVal = -999;
             for(let s=0; s<4; s++) {
                 let val = this.aMonster[0].stat[s][eDICE.MAX] + this.aMonster[0].stat[s][eDICE.MOD];
                 if(val > maxVal) { maxVal = val; bestStat = s; }
             }
             this.look[eLOOK.STAT] = bestStat;
             this.hasScalesOfJustice = 3; // Advance phase

             // 2. Pick OPPONENT'S Worst Stat (Defend)
             let worstStat = eSTAT.S;
             let minVal = 999;
             for(let s=0; s<4; s++) {
                 let val = this.opponent.aMonster[0].stat[s][eDICE.MAX] + this.opponent.aMonster[0].stat[s][eDICE.MOD];
                 if(val < minVal) { minVal = val; worstStat = s; }
             }
             this.opponent.look[eLOOK.STAT] = worstStat;
             
             // Finalize
             this.hasScalesOfJustice = 4;
             this.option = this.preOpt;
             if (this.foe == 1){this.flip()}
             return;
         }
         // -------------------------
          
          if (this.hasScalesOfJustice == 2||this.hasScalesOfJustice == 3){
            if (this.hand[this.look[eLOOK.H]].effectTriggered == 0&& this.at == 0){
                
              if (this.hasScalesOfJustice == 2){
                drawText(2.25,5,6,1,'Choose Caster Attack Stat:','white',1)
              }
                if (this.hasScalesOfJustice == 3){
                  if (this.look[eLOOK.STAT] == eSTAT.A){
                  //agi
                  drawShape('arc',1.25,6.5,2, .45,.47, .4,0, 2,0, .0,0,'rgba(0,0,255,.5)',1);
                  drawShape('arc',1.25,6.5,2, .45,.47, .4,0, 2,0, .0,0,'rgba(0,0,255,.5)',1);
                  drawShape('arc',1.25,6.5,2, .5,.47, .36,0, 2,0, .0,0,'rgba(255,255,255,.075)',1);
                  drawShape('arc',1.25,6.5,2, .55,.47, .3,0, 2,0, .0,0,'rgba(255,255,255,.075)',1);
                  drawShape('arc',1.25,6.5,2, .65,.47, .2,0, 2,0, .0,0,'rgba(255,255,255,.075)',1);
                  drawShape('arc',1.25,6.5,2, .75,.47, .1,0, 2,0, .0,0,'rgba(255,255,255,.075)',1);
                  drawShape('arc',1.25,6.5,2, .45,.47, .4,0, 2,0, .0,0,'rgba(0,0,0,.15)',1);
                  drawShape('arc',1.25,6.5,2, .45,.47, .4,0, 2,0, .0,0,'rgba(255,255,255,.075)',1);
                  //drawShape('qua',this.x,this.y,this.z*.9, .5,0, 0,.5, .5,1, 1,.5,'rgba(255,255,255,.25)',1);
                  drawPortrait(-7,1.25+.5,6.5+.5,.084)
                  }
                else if(this.look[eLOOK.STAT] == eSTAT.S){
                  //STR
                  drawShape('qua',1.25,6.5,1.8, .5,0, 0,.5, .5,1, 1,.5,'yellow',1);
                  drawShape('qua',1.25,6.5,1.8, .5,0, 0,.5, .5,1, 1,.5,'rgba(255,255,255,.25)',1);
                  drawShape('tri',1.25,6.5,1.8, 0,.5, .5,1, 1,.5, 0,0,'rgba(0,0,0,.15)',1);
                  drawShape('tri',1.25,6.5,1.8, .5,0, 1,.5, .5,1, 0,0,'rgba(255,255,255,.25)',1);
                  drawPortrait(-4,1.25+.5,6.5+.5,.0840)
                }
                else if(this.look[eLOOK.STAT] == eSTAT.C){
                  //con
                  drawShape('qua',1.25,6.5,1.5, 0,0.1, .5,0, 1,.1, .5,.2,'green',1);
                  drawShape('qua',1.25,6.5,1.5, 0,0.1, .5,0, 1,.1, .5,.2,'rgba(0,0,0,.25)',1);
                  drawShape('qua',1.25,6.5,1.5, 0,0.1, 0,.9, .5,1, .5,.2,'green',1);
                  drawShape('qua',1.25,6.5,1.5, 1,0.1, 1,.9, .5,1, .5,.2,'green',1);
                  drawShape('qua',1.25,6.5,1.5, 1,0.1, 1,.9, .5,1, .5,.2,'rgba(255,255,255,.25)',1);
                  drawPortrait(-6,1.25+.33,6.5+.33,.0840)
                  }
                else if(this.look[eLOOK.STAT] == eSTAT.I){
                  //int
                  drawShape('qua',1.25,6.5,1.8, 0,.9, 0.5,0.1, 1,.9, .5,1,'red',1);
                  drawShape('tri',1.25,6.5,1.8, .5,0.1, 1,.9, .5,1, 1,.5,'rgba(255,255,255,.45)',1);
                  drawPortrait(-5,1.25+.44,6.5+.76,.0720)
                  }
                
                drawText(2.25,5,6,1,'Choose Target Defend Stat:','white',1)
                this.flip();
              }
                //STR
                drawShape('qua',2,6,.9, .5,0, 0,.5, .5,1, 1,.5,'yellow',1);
                drawShape('qua',2,6,.9, .5,0, 0,.5, .5,1, 1,.5,'rgba(255,255,255,.25)',1);
                drawShape('tri',2,6,.9, 0,.5, .5,1, 1,.5, 0,0,'rgba(0,0,0,.15)',1);
                drawShape('tri',2,6,.9, .5,0, 1,.5, .5,1, 0,0,'rgba(255,255,255,.25)',1);
                drawPortrait(-4,2+.25,6+.25,.0420)
                //con
                drawShape('qua',7,6,.75, 0,0.1, .5,0, 1,.1, .5,.2,'green',1);
                drawShape('qua',7,6,.75, 0,0.1, .5,0, 1,.1, .5,.2,'rgba(0,0,0,.25)',1);
                drawShape('qua',7,6,.75, 0,0.1, 0,.9, .5,1, .5,.2,'green',1);
                drawShape('qua',7,6,.75, 1,0.1, 1,.9, .5,1, .5,.2,'green',1);
                drawShape('qua',7,6,.75, 1,0.1, 1,.9, .5,1, .5,.2,'rgba(255,255,255,.25)',1);
                drawPortrait(-6,7+.165,6+.165,.0420)
                //int
                drawShape('qua',2,8.5,.9, 0,.9, 0.5,0.1, 1,.9, .5,1,'red',1);
                drawShape('tri',2,8.5,.9, .5,0.1, 1,.9, .5,1, 1,.5,'rgba(255,255,255,.45)',1);
                drawPortrait(-5,2+.22,8.5+.38,.0360)
                //agi
                drawShape('arc',7,8.5,1, .45,.47, .4,0, 2,0, .0,0,'rgba(0,0,255,.5)',1);
                drawShape('arc',7,8.5,1, .45,.47, .4,0, 2,0, .0,0,'rgba(0,0,255,.5)',1);
                drawShape('arc',7,8.5,1, .5,.47, .36,0, 2,0, .0,0,'rgba(255,255,255,.075)',1);
                drawShape('arc',7,8.5,1, .55,.47, .3,0, 2,0, .0,0,'rgba(255,255,255,.075)',1);
                drawShape('arc',7,8.5,1, .65,.47, .2,0, 2,0, .0,0,'rgba(255,255,255,.075)',1);
                drawShape('arc',7,8.5,1, .75,.47, .1,0, 2,0, .0,0,'rgba(255,255,255,.075)',1);
                drawShape('arc',7,8.5,1, .45,.47, .4,0, 2,0, .0,0,'rgba(0,0,0,.15)',1);
                drawShape('arc',7,8.5,1, .45,.47, .4,0, 2,0, .0,0,'rgba(255,255,255,.075)',1);
                //drawShape('qua',this.x,this.y,this.z*.9, .5,0, 0,.5, .5,1, 1,.5,'rgba(255,255,255,.25)',1);
                drawPortrait(-7,7+.25,8.5+.25,.0420)
                ///
                drawPortrait(14,9,9,.1);
                drawPortrait(14,0,9,.1);
                drawPortrait(14,9,5,.1);
                drawPortrait(14,0,5,.1);
                if (this.hasScalesOfJustice == 3){this.flip();}
              }    
            
          }else{this.option = this.preOpt}
        break;
        }//end switch.option
    if (this.foe == 1){this.flip()}
  }//end react
	cardID(index){//card zoom
    //Player.cardID(Player.deck[0].index);//example of using card zoom
		 this.view = new Card(index,613);
		 this.view.place(1.9,.2,2.75);
		 drawShape('arc',this.view.x,this.view.y,2.75,0,1.69,.3,0,6,0,0,0,'rgba(255,255,255,.5)',1);//left
		 drawShape('tri',this.view.x,this.view.y,2.75,.1,1.45,.1,1.9,-.25,1.69,0,0,'rgba(0,0,0,.5)',1);//left
		 drawShape('arc',this.view.x,this.view.y,2.75,2.25,1.69,.3,0,6,0,0,0,'rgba(255,255,255,.5)',1);//right
		 drawShape('tri',this.view.x,this.view.y,2.75,2.15,1.45,2.15,1.9,2.5,1.69,0,0,'rgba(0,0,0,.5)',1);//right
     drawText(8.25,.2,1,1,'X','white',1.63);
   }
	refresh(dt){//refresh the screen graphics
    if (this.foe == 1){this.flip()}
    for(let i=this.deck.length-1;i>=this.draw;i--){	//place deck on right side of field
      this.deck[i].place(7-(tL/10)*(i*.000136),6.45,1);
      this.deck[i].locCount = this.deck.length-1;
    }

	  for(let i=0;i<this.hand.length;i++){//stack hand on left side of field
          
          if (this.hand.length -1 > 0){
          drawShape('rec',1-(i*.0536),6.45,1,0,0,2.25,3.55,0,0,0,0,'rgba(255, 255, 255,.03)',1);//gray border
          drawShape('rec',1-(i*.0536),6.45,1,0,0,2.25,3.55,0,0,0,0,'rgb(0, 0, 0)',0);//gray border
            }
      // LOGIC CHANGE: Check isCPU
      if (this.isCPU === 1) {
          // Force Face Down for CPU
          this.hand[this.look[eLOOK.H]].place(.875, 6.5, 1, true); 
      } else {    
      this.hand[this.look[eLOOK.H]].place(.875,6.5,1);
      }
       this.hand[i].locCount = this.hand.length-1;
      this.hand[i].locIndex = i;
    }

		for(let i=0;i<this.aMonster.length;i++){//stack monster and any equipped cards in center of field
      this.aMonster[this.look[eLOOK.M]].place(3.875,6.5,1);
      this.aMonster[i].locCount = this.aMonster.length-1;
      this.aMonster[i].locIndex = this.i;
    }
    
    let arrowWidth = 0;
    let arrowOffsetX = 0;
    let arrowOffsetY = 0;
    if (this.option == 1){
      arrowWidth = .1
      arrowOffsetX = .75
      arrowOffsetY =1;
    }else{arrowWidth = .057
      arrowOffsetX = .35
      arrowOffsetY =1.3;
    }
    //hand menu open
    if (this.hand.length>0&&this.option < 5&& this.hand.length > 1&& this.isCPU == 0){//Hand Arrow Buttons
      drawPortrait(-1,this.hand[0].x-arrowOffsetX,this.hand[0].y+arrowOffsetY,arrowWidth);//left
      drawPortrait(-2,this.hand[0].x+2.04,this.hand[0].y+arrowOffsetY,arrowWidth);//right
      drawText(this.hand[0].x+(this.hand[0].l/3.6),5.8,1,.8,(this.look[eLOOK.H]+1) + "/" + this.hand.length,'white',1);//Hand Counter
    }
    if (this.option == 3){
      arrowWidth = .1
      arrowOffsetX = .75
      arrowOffsetY = 1;
    }else{
      arrowWidth = .057
      arrowOffsetX = .37
      arrowOffsetY = 1.3;
    }//monster menu open
    if (this.aMonster.length>0&&this.option < 5&& this.aMonster.length > 1){//Monster Arrow Button
      drawPortrait(-1,this.aMonster[0].x-arrowOffsetX,this.aMonster[0].y+arrowOffsetY,arrowWidth);//left
      drawPortrait(-2,this.aMonster[0].x+2.04,this.aMonster[0].y+arrowOffsetY,arrowWidth);//right
      drawText(this.aMonster[0].x+(this.aMonster[0].l/3.6),5.8,1,.8,(this.look[eLOOK.M]+1) + "/" + this.aMonster.length,'white',1);//Hand Counter
      
    }
    //CARD MENUS (Use Item, Cast Spell, Examine) (try to add menu for monster card as well)
    
    if (this.draw == 1){//CARD DRAW ANIMATION
      const DRAW_SPEED = 30;
      if(this.deck.length>0){//check if card available in deck (***can add game over condition here)
        let moveAmount = DRAW_SPEED * dt;
        this.deck[0].place(this.deck[0].x - moveAmount, this.deck[0].y);
        if (this.deck[0].type == 0 && (tL/10)*this.deck[0].x < (tL/10)*4 ){//if monster, move card from deck array to aMonster array and end draw
          this.draw = 0;
          this.aMonster.push(this.deck[0]);
          this.deck.shift();
          this.aMonster[this.aMonster.length-1].location = 'field';
          this.aMonster[this.aMonster.length-1].locIndex = this.aMonster.length-1;
          this.aMonster[this.aMonster.length-1].locCount = this.aMonster.length-1;
          if (sRune.owner == this.foe){sRune.changeOwner(this.foe)};
          if (cRune.owner == this.foe){cRune.changeOwner(this.foe)};
          if (iRune.owner == this.foe){iRune.changeOwner(this.foe)};
          if (aRune.owner == this.foe){aRune.changeOwner(this.foe)};
        }else {//else item or spell
          if ((tL/10)*this.deck[0].x < (tL/10)*.1 ) {//move card from deck array to hand array
            this.draw = 1;
            this.hand.push(this.deck[0]);
            this.deck.shift();
            this.hand[this.hand.length-1].location = 'hand';
            this.hand[this.hand.length-1].locIndex = this.hand.length-1;
            this.hand[this.hand.length-1].locCount = this.hand.length-1;
            this.look[eLOOK.H] = this.hand.length - 1;
          }
        }//end else (if item or spell)
      }//end if (check if card avail)
    }//end if draw == 1 (draw animation)and execution


    if (this.aMonster.length == 0 && this.draw == 0 && this.deck.length > 0&&this.option == 11) {//auto draw on startup
      this.draw = 1;
    }
    //this.d2.animate(2,5,1,5);
      //this.d4.animate(3,5,1,5);
      //this.d6.animate(4,5,1,5);
      //this.d8.animate(5,5,1,5);
      //this.d10.animate(6,5,1,5);
      //this.d12.animate(7,5,1,5);
      //this.d20.animate(8,5,1,5);


    if (this.foe == 1){this.flip()}
    }//end refresh
  btnDo(index){//execute button click
    switch(index){
      case 'mc'://menu close
        this.option = 0;
        break;
      case 'hm'://hand menu
        if (this.hand.length > 0){
          this.option = 1
        }
        break;
      case 'hra'://hand right arrow
        if(this.hand.length > 1){
          if (this.look[eLOOK.H] + 1 > this.hand.length-1){
            this.look[eLOOK.H] = 0;
          }
          else{
            this.look[eLOOK.H] = this.look[eLOOK.H] + 1;
          }
          if (this.option != 2){
            this.option = 1;
          }
        }
        break;
      case 'hla'://hand left arrow
        if (this.hand.length>1){
          if (this.look[eLOOK.H] - 1 < 0){
            this.look[eLOOK.H] = this.hand.length-1;
          }
          else{
            this.look[eLOOK.H] = this.look[eLOOK.H]-1;
          }
          if (this.option != 2){
            this.option = 1;
          }
        }
        break;
      case 'use'://hand use
        if (this.hand.length > 0){
          this.look[eLOOK.A] = this.hand[this.look[eLOOK.H]].type;
          this.option = 5;
        }
        break;
      case 'hex'://hand examine
        if (this.hand.length > 0){
          this.option = 2;
        }
      break;
      case 'hec'://hand examine close
        this.option = 1;
      break;
      case 'mmo'://monster menu
        if (this.aMonster.length>0){
          this.option =3;
        }
        break;
      case 'mra'://monster right arrow
        if (this.aMonster.length > 1){
          if (this.look[eLOOK.M] + 1 > this.aMonster.length-1){
            this.look[eLOOK.M] = 0;
          }
          else{
            this.look[eLOOK.M] = this.look[eLOOK.M]+1;
          }
          if (this.option != 4){
            this.option = 3;
          }
        }
        break;
      case 'mla'://monster left arrow
        if (this.aMonster.length > 1){
          if (this.look[eLOOK.M] - 1 < 0){
            this.look[eLOOK.M] = this.aMonster.length-1;
          }
          else{
            this.look[eLOOK.M] = this.look[eLOOK.M]-1;
          }
          if (this.option != 4){
            this.option = 3;
          }
        }
        break;
      case 'me'://monster examine
        if (this.aMonster.length > 0){
          this.option = 4;
        }
        break;
      case 'mec'://monster examine close
        this.option = 3;
      break;
      case 'atk':
        if (this.aMonster.length >0){
            this.option = 5;
            this.look[eLOOK.A] = 0;
        }
        break;
      case 'rex'://ready close
          this.look[eLOOK.A] = -1
          this.option = 0;
      break;
      }
  }
}//end class field
class Card{
	constructor(index,foe){
		this.index = index;
		this.foe = foe; //passed from field class (set in constructor)
		this.location = '';
		this.locIndex = 0;
		this.locCount = 0;
    this.stat = [[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0]];//0-STR,1-CON,2-INT,3-AGI; 0-MIN,1-MAX,2-MOD,3-TEXT(min +'d' +max + '+' + mod)
		this.subType = 0;
    this.hasEffect = 0;
    this.buffApplied = 0;
    //ITEM: 7 - USE: 4, EQUIP: 3
    //MONSTER: 6
    //SPELL:8 - DEBUFF: 5, BUFF: 1, CAST: 3
    switch (this.index){//CARD ENCYCLOPEDIA - set card info using index set in Field class constructor
      case 0://Fool//                             MONSTER
        this.name = 'Fool';
        this.portrait = 0;
        this.type = 0;//0-monster, 1-item, 2-spell
        this.desc = 'Curiosity, Naivety, Potential, Freedom';
        this.stat[0][0]=1;//minSTR
        this.stat[0][1] = 4;//maxSTR
        this.stat[0][2]= 0;//modSTR
        this.stat[0][3] = '' + this.stat[0][0] +'d'+ this.stat[0][1];//STRlabel
        this.stat[1][0]=1;//minCON
        this.stat[1][1] = 4;//maxCON
        this.stat[1][2]= 0;//modCON
        this.stat[1][3] = '' + this.stat[1][0] +'d'+ this.stat[1][1];
        this.stat[2][0]=1;//minINT
        this.stat[2][1] = 4;//maxINT
        this.stat[2][2]= 0;//modINT
        this.stat[2][3] = '' + this.stat[2][0] +'d'+ this.stat[2][1];
        this.stat[3][0]=1;//minAGI
        this.stat[3][1] = 8;//maxAGI
        this.stat[3][2]= 0;//modAGI
        this.stat[3][3] = '' + this.stat[3][0] +'d'+ this.stat[3][1];
        break;
      case 1://Magician//                         MONSTER
			  this.name = 'Magician';
			  this.portrait = 1;
			  this.type = 0;//0-monster, 1-item, 2-spell
        this.subtype = 0;//normal monster 1-effect monster
			  this.desc = 'Implementing INT , Transforming Reality, Master of Elements';
        this.stat[0][0]=1;//minSTR
        this.stat[0][1] = 6;//maxSTR
        this.stat[0][2]= 0;//modSTR
 		    this.stat[0][3] = '' + this.stat[0][0] +'d'+ this.stat[0][1];
        this.stat[1][0]=1;//minCON
        this.stat[1][1] = 6;//maxCON
        this.stat[1][2]= 0;//modCON
        this.stat[1][3] = '' + this.stat[1][0] +'d'+ this.stat[1][1];
        this.stat[2][0]=1;//minINT
        this.stat[2][1] = 12;//maxINT
        this.stat[2][2]= 0;//modINT
        this.stat[2][3] = '' + this.stat[2][0] +'d'+ this.stat[2][1];
        this.stat[3][0]=1;//minAGI
        this.stat[3][1] = 6;//maxAGI
        this.stat[3][2]= 0;//modAGI
        this.stat[3][3] = '' + this.stat[3][0] +'d'+ this.stat[3][1];
		    break;
		  case 2://High Priestess//                   MONSTER
				this.name = 'High Priestess';
				this.type = 0; //0-monster, 1-item, 2-spell
        this.subtype = 0;//normal monster 1-effect monster
				this.portrait = 2;
				this.desc = 'Spiritual Insight, INT , Intuition';
        this.stat[0][0]=1;//minSTR
        this.stat[0][1] = 4;//maxSTR
        this.stat[0][2]= 0;//modSTR
        this.stat[0][3] = '' + this.stat[0][0] +'d'+ this.stat[0][1];
        this.stat[1][0]=1;//minCON
        this.stat[1][1] = 4;//maxCON
        this.stat[1][2]= 0;//modCON
        this.stat[1][3] = '' + this.stat[1][0] +'d'+ this.stat[1][1];
        this.stat[2][0]=1;//minINT
        this.stat[2][1] = 10;//maxINT
        this.stat[2][2]= 0;//modINT
        this.stat[2][3] = '' + this.stat[2][0] +'d'+ this.stat[2][1];
        this.stat[3][0]=1;//minAGI
        this.stat[3][1] = 8;//maxAGI
        this.stat[3][2]= 0;//modAGI
        this.stat[3][3] = '' + this.stat[3][0] +'d'+ this.stat[3][1];
				break;
			case 3://Empress//                          MONSTER
				this.name = 'Empress';
				this.portrait = 3;
				this.type = 0;//0-monster, 1-item, 2-spell
        this.subType = 0;//INT spell?
				this.desc = 'CON , Nature, Nurture';
        this.stat[0][0]=1;//minSTR
        this.stat[0][1] = 6;//maxSTR
        this.stat[0][2]= 0;//modSTR
        this.stat[0][3] = '' + this.stat[0][0] +'d'+ this.stat[0][1];
        this.stat[1][0]=1;//minCON
        this.stat[1][1] = 12;//maxCON
        this.stat[1][2]= 0;//modCON
        this.stat[1][3] = '' + this.stat[1][0] +'d'+ this.stat[1][1];
        this.stat[2][0]=1;//minINT
        this.stat[2][1] = 6;//maxINT
        this.stat[2][2]= 0;//modINT
        this.stat[2][3] = '' + this.stat[2][0] +'d'+ this.stat[2][1];
        this.stat[3][0]=1;//minAGI
        this.stat[3][1] = 6;//maxAGI
        this.stat[3][2]= 0;//modAGI
        this.stat[3][3] = '' + this.stat[3][0] +'d'+ this.stat[3][1];
				break;
      case 4://Emperor//                          MONSTER
        this.name = 'Emperor';
        this.portrait = 4;
        this.type = 0;//0-monster, 1-item, 2-spell
        this.subType = 0;//INT spell?
        this.desc = 'Domination, STR , Authority';
        this.stat[0][0]=1;//minSTR
        this.stat[0][1] = 12;//maxSTR
        this.stat[0][2]= 0;//modSTR
        this.stat[0][3] = '' + this.stat[0][0] +'d'+ this.stat[0][1];
        this.stat[1][0]=1;//minCON
        this.stat[1][1] = 8;//maxCON
        this.stat[1][2]= 0;//modCON
        this.stat[1][3] = '' + this.stat[1][0] +'d'+ this.stat[1][1];
        this.stat[2][0]=1;//minINT
        this.stat[2][1] = 4;//maxINT
        this.stat[2][2]= 0;//modINT
        this.stat[2][3] = '' + this.stat[2][0] +'d'+ this.stat[2][1];
        this.stat[3][0]=1;//minAGI
        this.stat[3][1] = 4;//maxAGI
        this.stat[3][2]= 0;//modAGI
        this.stat[3][3] = '' + this.stat[3][0] +'d'+ this.stat[3][1];
        break;
      case 5://Heirophant//                       MONSTER
        this.name = 'Heirophant';
        this.portrait = 5;
        this.type = 0;//0-monster, 1-item, 2-spell
        this.subType = 0;//INT spell?
        this.desc = 'Tradition, Wisdom, INT , Guidance';
        this.stat[0][0]=1;//minSTR
        this.stat[0][1] = 4;//maxSTR
        this.stat[0][2]= 0;//modSTR
        this.stat[0][3] = '' + this.stat[0][0] +'d'+ this.stat[0][1];
        this.stat[1][0]=1;//minCON
        this.stat[1][1] = 10;//maxCON
        this.stat[1][2]= 0;//modCON
        this.stat[1][3] = '' + this.stat[1][0] +'d'+ this.stat[1][1];
        this.stat[2][0]=1;//minINT
        this.stat[2][1] = 10;//maxINT
        this.stat[2][2]= 0;//modINT
        this.stat[2][3] = '' + this.stat[2][0] +'d'+ this.stat[2][1];
        this.stat[3][0]=1;//minAGI
        this.stat[3][1] = 4;//maxAGI
        this.stat[3][2]= 0;//modAGI
        this.stat[3][3] = '' + this.stat[3][0] +'d'+ this.stat[3][1];           
        break;
      case 6://The Lovers//                         ITEM - EQUIP
        this.name = 'The Lovers';
        this.portrait = 6;
        this.type = 1;//null 0-monster, 1-item, 2-spell
        this.subType = 3; //0-none,1-monster effect, 2-use, 3-equip
        this.desc = 'While equipped, +1 to STR and CON rolls. Defeating a foe grants an additional +1 to STR and CON rolls ';
        this.hasEffect = 1;
        this.buffApplied = 0;
        this.stat[0][0]=1;//STR
        this.stat[0][1] = 0;
        this.stat[0][2]= 1;
        this.stat[0][3] = '' + this.stat[0][0] +'d'+ this.stat[0][1];
        this.stat[1][0]=1;//CON
        this.stat[1][1] = 0;
        this.stat[1][2]= 1;
        this.stat[1][3] = '' + this.stat[1][0] +'d'+ this.stat[1][1];
			  break;
      case 7://The Chariot/Winged Boots//           ITEM - EQUIP
        this.name = 'Winged Boots';
        this.portrait = 7;
        this.type = 1;//null 0-monster, 1-item, 2-spell
        this.subType = 3; //0-none,1-monster effect, 2-use, 3-equip
        this.desc = 'While equipped, +3 to AGI rolls. You may roll AGI instead of CON when defending.';
        this.effectTriggered = 0;
        this.buffApplied = 0;
        this.stat[3][2]= 3;//AGI mod + 3
        
			  break;
      case 8://Strength//                             SPELL - BUFF
        this.name = 'Strength';
        this.portrait = 8;
        this.type = 2;//null 0-monster, 1-item, 2-spell
        this.subType = 'buff'
        this.desc = 'Caster gains STR equal to INT roll. Lasts until caster is defeated.';
        
			  break;
      case 9://Hermit//                           MONSTER
          this.name = 'Hermit';
          this.portrait = 9;
          this.type = 0;//0-monster, 1-item, 2-spell
          this.subType = 0;//INT spell?
          this.desc = 'Solitude, INT , Rumination';
          this.stat[0][0]=1;//minSTR
          this.stat[0][1] = 4;//maxSTR
          this.stat[0][2]= 0;//modSTR
          this.stat[0][3] = '' + this.stat[0][0] +'d'+ this.stat[0][1];
          this.stat[1][0]=1;//minCON
          this.stat[1][1] = 4;//maxCON
          this.stat[1][2]= 0;//modCON
          this.stat[1][3] = '' + this.stat[1][0] +'d'+ this.stat[1][1];
          this.stat[2][0]=1;//minINT
          this.stat[2][1] = 20;//maxINT
          this.stat[2][2]= 0;//modINT
          this.stat[2][3] = '' + this.stat[2][0] +'d'+ this.stat[2][1];
          this.stat[3][0]=1;//minAGI
          this.stat[3][1] = 4;//maxAGI
          this.stat[3][2]= 0;//modAGI
          this.stat[3][3] = '' + this.stat[3][0] +'d'+ this.stat[3][1];
        break;
      case 10://Wheel of Fortune/Treasure Chest//   ITEM - USE
        this.name = 'Treasure Chest';
        this.portrait = 10;
        this.type = 1;//null 0-monster, 1-item, 2-spell
        this.subType = 2; //0-none,1-monster effect, 2-use, 3-equip
        this.desc = 'Reveal cards from the top of your deck until you reveal a monster card. Put all revealed spells and items into your hand. You may switch your active monster with the revealed monster, or discard it.';
			  break;
      case 11://Justice/Scales of Justice//         ITEM - USE
        this.name = 'Scales of Justice';
        this.portrait = 11;
        this.type = 1;//null 0-monster, 1-item, 2-spell
        this.subType = 2; //0-none,1-monster effect, 2-use, 3-equip
        this.desc = 'Instead of normal battle rolls, both players roll 1d12. If player roll > foe roll, foes monster is destroyed. Ignore all buffs, debuffs, items, and special effects. If this monster is destroyed before its next turn, the foes monster is destroyed as well.';
        
			  break;
      case 12://Hanged Man//bind                      SPELL - DEBUFF
        this.name = 'Bind';
        this.portrait = 12;
        this.type = 2;//0-monster, 1-item, 2-spell
        this.subType = 0;//INT spell?
        this.desc = 'If caster INT roll > foe INT roll, foe cannot attack or use items for (caster INT roll - foe INT roll) turns. Foe may still cast spells and defend. ';
        this.subType = 'debuff';
        break; 
      case 13://Death//                               SPELL - CAST
        this.name = 'Death';
        this.portrait = 13;
        this.type = 2;//null 0-monster, 1-item, 2-spell
        this.desc = 'If caster INT roll > target INT roll, target is defeated. This effect cannot be blocked or prevented by special effects.';
        this.subType = 'debuff'
			  break;
      case 14://Temperance/Alchemy//                  SPELL - CAST
        this.name = 'Alchemy';
        this.portrait = 14;
        this.type = 2;//null 0-monster, 1-item, 2-spell
        this.desc = 'Caster may choose which stat they roll to attack, and which stat the foe must roll to defend.'
			  this.subType = 'cast';
        this.effectTriggered = 0;
        break;
      case 15://Curse//                               SPELL - DEBUFF
        this.name = 'Curse';
        this.portrait = 15;
        this.type = 2;//null 0-monster, 1-item, 2-spell
        this.desc = 'If caster INT roll > foe INT roll, foe suffers a penalty to all stat rolls equal to the difference (caster INT roll - foe INT roll). Lasts until caster is defeated.';
        this.subType = 'debuff';
			  break;
      case 16://The Tower/Ruin//                      SPELL - DEBUFF
        this.name = 'Ruin';
        this.portrait = 16;
        this.type = 2;//null 0-monster, 1-item, 2-spell
        this.desc = 'If caster INT roll > target INT roll, the foe must discard all cards in their hand and field. Target monster remains unaffected.';
        this.subType = 'debuff';
			  break;
      case 17://The Star/Star Pendant//             ITEM - EQUIP
        this.name = 'Star Pendant';
        this.portrait = 17;
        this.type = 1;//null 0-monster, 1-item, 2-spell
        this.subType = 3; //0-none,1-monster effect, 2-use, 3-equip
        this.hasEffect = 1;
        this.effectTriggered = 0;
        this.desc = 'While equipped, once per roll, you may re-roll. You must use the results of the re-roll.';
			  break;
      case 18://The Moon/Lunacy//                     SPELL - DEBUFF
        this.name = 'Lunacy';
        this.portrait = 18;
        this.type = 2;//null 0-monster, 1-item, 2-spell
        this.desc = 'If caster INT roll > foe INT roll, foe cannot cast spells or use items for caster INT roll - foe INT roll turns. Foe may still attack and defend. ';
			  this.subType = 'debuff';
        break;
      case 19://The Sun/Solar Rite//                ITEM - USE
        this.name = 'Solar Rite';
        this.portrait = 19;
        this.type = 1;//null 0-monster, 1-item, 2-spell
        this.subType = 2; //0-none,1-monster effect, 2-use, 3-equip
        this.desc = 'Discard all spell and item cards on the field. Remove all stat buffs, debuffs, and lingering effects from all monsters. (May be activated even if unable to act. Cannot be prevented by effects that block item effects.)';
        this.stat[0][0]=1;//STR
        this.stat[0][1] = 0;
        this.stat[0][2]= 0;
        this.stat[0][3] = '' + this.stat[0][0] +'d'+ this.stat[0][1];
        this.stat[1][0]=1;//CON
        this.stat[1][1] = 0;
        this.stat[1][2]= 0;
        this.stat[1][3] = '' + this.stat[1][0] +'d'+ this.stat[1][1];
        this.stat[2][0]=0;//INT
        this.stat[2][1] = 0;
        this.stat[2][2]= 0;
        this.stat[2][3] = '' + this.stat[2][0] +'d'+ this.stat[2][1];
        this.stat[3][0]=0;//INT
        this.stat[3][1] = 0;
        this.stat[3][2]= 0;
        this.stat[3][3] = '' + this.stat[3][0] +'d'+ this.stat[3][1];
			  break;
      case 20://Judgement//Horn of Judgement//      ITEM - USE
        this.name = 'Horn of Judgement';
        this.portrait = 20;
        this.type = 1;//null 0-monster, 1-item, 2-spell
        this.subType = 2; //0-none,1-monster effect, 2-use, 3-equip
        this.desc = 'Destroy all monsters, items, and spells on the field. (Cannot be prevented by effects that block item effects. No runes awarded for destroyed monsters.)';
			  break;
      case 21://The World/The World Serpent//     MONSTER
        this.name = 'World Serpent';
        this.portrait = 21;
        this.type = 0;//null 0-monster, 1-item, 2-spell
        this.desc = '';
        this.stat[0][0]=1;//STR
        this.stat[0][1] = 4;
        this.stat[0][2]= 0;
        this.stat[0][3] = '' + this.stat[0][0] +'d'+ this.stat[0][1];
        this.stat[1][0]=1;//CON
        this.stat[1][1] = 20;
        this.stat[1][2]= 0;
        this.stat[1][3] = '' + this.stat[1][0] +'d'+ this.stat[1][1];
        this.stat[2][0]=1;//INT
        this.stat[2][1] = 4;
        this.stat[2][2]= 0;
        this.stat[2][3] = '' + this.stat[2][0] +'d'+ this.stat[2][1];
        this.stat[3][0]=1;//AGI
        this.stat[3][1] = 4;
        this.stat[3][2]= 0;
        this.stat[3][3] = '' + this.stat[3][0] +'d'+ this.stat[3][1];
			  break;
       
			default:
        this.name = '';
        this.portrait = 0;
        this.type = 3;//null 0-monster, 1-item, 2-spell
        this.desc = '';
        this.stat[0][0]=1;//STR
        this.stat[0][1] = 0;
        this.stat[0][2]= 0;
        this.stat[0][3] = '' + this.stat[0][0] +'d'+ this.stat[0][1];
        this.stat[1][0]=1;//CON
        this.stat[1][1] = 0;
        this.stat[1][2]= 0;
        this.stat[1][3] = '' + this.stat[1][0] +'d'+ this.stat[1][1];
        this.stat[2][0]=0;//INT
        this.stat[2][1] = 0;
        this.stat[2][2]= 0;
        this.stat[2][3] = '' + this.stat[2][0] +'d'+ this.stat[2][1];
        this.stat[3][0]=0;//INT
        this.stat[3][1] = 0;
        this.stat[3][2]= 0;
        this.stat[3][3] = '' + this.stat[3][0] +'d'+ this.stat[3][1];
			  break;
		}//end switch
	}//end constructor
  rollStat (stat){//call x: player.aMonster[0].rollStat(0), stat ex:0-STR, 1 - CON, 2 - INT, 3 - AGI
    let temprunestat = 0;
    if(stat == 0){
      if (sRune.owner == this.foe) {temprunestat = 1;}
    }
    
    if(stat == 1){
      if (cRune.owner == this.foe) {temprunestat = 1;}
    }
    if(stat == 2){
      if (iRune.owner == this.foe) {temprunestat = 1;}
    }
    if(stat == 0){
      if (aRune.owner == this.foe) {temprunestat = 1;}
    }
    let tempstatroll = rnd(this.stat[stat][0]+temprunestat,this.stat[stat][1])+this.stat[stat][2]+temprunestat;
    if (tempstatroll <0) {return 0;}
    else{
      return tempstatroll;
    }
  }
	place(x,y,z,faceDown = false){
		var color = 0;
			this.x = x;
			this.y = y;
			this.l = 2.25;
			this.h = 3.5;
		
    if (this.foe == 0){y = y-.03;}else{y = y -.055;}
		// LOGIC CHANGE: Check for deck location OR faceDown flag
		if (this.location == 'deck' || faceDown){ 
			drawShape('rec',0,0,1,x-.05,y-.05,2.26,3.6,0,0,0,0,'rgba(255,255,255,.03)',1);
            drawShape('rec',0,0,1,x-.05,y-.05,2.26,3.6,0,0,0,0,'rgba(0,0,0,1)',0);
            // Optional: Draw a logo on the back if you want
            // drawPortrait(eIMG.LOGO, x+0.5, y+1, 0.5); 
		}else{//for top card draw all details
      ctx.textAlign= 'left';
			switch(this.type){//check for card type (0 - monster, 1 - item, 2 - spell)
				case 0: //monster
					color = 'rgb(255, 214, 0)';
          drawShape('rec',x,y,z,0-.05,0-.05,this.l+.1,this.h+.1,0,0,0,0,'rgb(48, 48, 48)',1);//border
					drawShape('rec',x,y,z,0,0,this.l,this.h,0,0,0,0,color,1);//card
			    //STATS
					drawShape('rec',x,y,z, .225, .275,     1.8,   .89, 0,0,0,0,'rgba(255,255,255,.5)',1);//stat frame fill
					//stat portraits
					drawPortrait(-11,x+(.24*z),                y+(.29*z),     .042*z);//str
					drawPortrait(-12,x+(.24*z),                y+(.285+.45)*z,.042*z);//int
					drawPortrait(-13,x+(.24*z) + ((1.8/4)*2)*z,y+(.29*z),      .042*z);//con
					drawPortrait(-14,x+(.24*z) + ((1.8/4)*2)*z,y+(.285+.45)*z,.042*z);//agi
          let temprunestat = 0;
          
					//stat text
          if (sRune.owner == this.foe) {temprunestat = 1;}
          if (this.stat[eSTAT.S][eDICE.MOD]+temprunestat > 0){drawText((x+.25*z) + ((1.8/4)*1)*z, y+.59*z,1.8/4.3,1.8/4, '+'+   `${this.stat[0][2]+temprunestat}`,'green',z);}//str
          if (this.stat[eSTAT.S][eDICE.MOD]+temprunestat < 0){drawText((x+.25*z) + ((1.8/4)*1)*z, y+.59*z,1.8/4.3,1.8/4, `${this.stat[0][2]+temprunestat}`,'red',z);}//str
          drawText((x+.24*z) + ((1.8/4)*1)*z, y+.4*z,1.8/4.3,1.8/4,       this.stat[0][3],'black',z);//str
          temprunestat = 0;
          if (iRune.owner == this.foe) {temprunestat = 1;}
          if (this.stat[eSTAT.I][eDICE.MOD]+temprunestat > 0){drawText((x+.35*z) + ((1.8/4)*1)*z, y+(.375+.63)*z,1.8/4.3,1.8/4, '+'+   `${this.stat[2][2]+temprunestat}`,'green',z);}//int
          if (this.stat[eSTAT.I][eDICE.MOD]+temprunestat < 0){drawText((x+.35*z) + ((1.8/4)*1)*z, y+(.375+.63)*z,1.8/4.3,1.8/4,  `${this.stat[2][2]+temprunestat}`,'red',z);}//int
          drawText((x+.24*z) + ((1.8/4)*1)*z,y+(.4+.45)*z,1.8/4.3,1.8/4, this.stat[2][3],'black',z);//int
          temprunestat = 0;
          if (cRune.owner == this.foe) {temprunestat = 1;}
          if (this.stat[eSTAT.C][eDICE.MOD]+temprunestat > 0){drawText((x+.35*z) + ((1.8/4)*3)*z, y+.62*z,1.8/4.3,1.8/4, '+'+   `${this.stat[1][2]+temprunestat}`,'green',z);}//con
          if (this.stat[eSTAT.C][eDICE.MOD]+temprunestat < 0){drawText((x+.35*z) + ((1.8/4)*3)*z, y+.62*z,1.8/4.3,1.8/4,  `${this.stat[1][2]+temprunestat}`,'red',z);}//con
          drawText((x+.24*z) + ((1.8/4)*3)*z,y+.4*z,1.8/4.3,1.8/4,      this.stat[1][3],'black',z);//con
          temprunestat = 0;
          if (aRune.owner == this.foe) {temprunestat = 1;}
          if (this.stat[eSTAT.A][eDICE.MOD]+temprunestat > 0){drawText((x+.35*z) + ((1.8/4)*3)*z, y+(.4+.62)*z,1.8/4.3,1.8/4, '+' + `${this.stat[3][2]+temprunestat}`,'green',z);}//agi
          if (this.stat[eSTAT.A][eDICE.MOD]+temprunestat < 0){drawText((x+.35*z) + ((1.8/4)*3)*z, y+(.4+.62)*z,1.8/4.3,1.8/4,  `${this.stat[3][2]+temprunestat}`,'red',z);}//agi
          drawText((x+.24*z) + ((1.8/4)*3)*z,y+(.4+.45)*z,1.8/4.3,1.8/4,this.stat[3][3],'black',z);//agi
          //divider lines
          drawShape('lin',x,y,z, .23, .7235, 2.02, .7235 ,0,0,0,0,'rgba(48,48,48,.5)',0);//half across
          for (let i =0 ;i<4;i++){
            drawShape('lin',x,y,z, .225+(1.8/4)*i, .275, .225+(1.8/4)*i, 1.16 ,0,0,0,0,'rgba(48,48,48,.5)',0);
          }
          drawShape('rec',x,y,z, .225, .275,     1.8,   .89, 0,0,0,0,'rgba(48,48,48,.5)',0);//stat frame border
					//DESCRIPTION
					drawShape('rec',x,y,1*z,.225, 1.2, 1.8, .425, 0,0,0,0,'rgba(255,255,255,.5)',1);//desc box
          drawShape('rec',x,y,1*z,.225, 1.2, 1.8, .425, 0,0,0,0,'rgba(48,48,48,.5)',0);//desc box border
					drawText(x+.24*z,y+1.1975*z,1.8,.425,this.desc,'black',z);//desc text
					break;
				case 1: //item
					color = 'rgb(0, 183, 235)';
          // card red layer
          drawShape('rec',x,y,z,0-.05,0-.05,this.l+.1,this.h+.1,0,0,0,0,'black',0);//gray border
          drawShape('rec',x,y,z,0-.05,0-.05,this.l+.1,this.h+.1,0,0,0,0,'rgb(48, 48, 48)',1);//gray border
					drawShape('rec',x,y,z,0,0,this.l,this.h,0,0,0,0,color,1);  // card red layer
          drawShape('rec',x,y,z,.225, .3, 1.8, 1.3, 0,0,0,0,'rgba(255,255,255,.6)',1);//desc box
          drawShape('rec',x,y,z,.225, .3, 1.8, 1.3, 0,0,0,0,'rgba(48,48,48,.5)',0);//desc box
					drawText(x+(.3*z),y+(.34*z),1.75,1.25,this.desc,'black',z);//desc text
					break;
				case 2: //spell
					color = 'rgb(212, 45, 158)';
          drawShape('rec',x,y,z,0-.05,0-.05,this.l+.1,this.h+.1,0,0,0,0,'black',0);//gray border

          drawShape('rec',x,y,z,0-.05,0-.05,this.l+.1,this.h+.1,0,0,0,0,'rgb(48, 48, 48)',1);
					drawShape('rec',x,y,z,0,0,this.l,this.h,0,0,0,0,color,1);//card
					drawShape('rec',x,y,z,.225, .3, 1.8, 1.3, 0,0,0,0,'rgba(255,255,255,.4)',1);//desc box
          drawShape('rec',x,y,z,.225, .3, 1.8, 1.3, 0,0,0,0,'rgba(48,48,48,.5)',0);//desc box
					drawText(x+.24*z,y+.3*z,1.8,1.3,this.desc,'black',z);
					break;
				default:
					color = 'black'
					break;
			}//end switch
			//NAME
			ctx.textAlign= 'center';
			drawText(x+(this.l*z/1.9),y+(this.h-this.h*.989),this.l*.8,this.h*.0857,this.name,'black',z);
			ctx.textAlign= 'left';
			//PORTRAIT
      drawShape('rec',x,y,z,.221,1.66, 1.809, 1.75, 0,0,0,0,'rgba(48,48,48,.5)',1);//portrait box
      drawShape('rec',x,y,z,.25,1.66, 1.75, 1.75, 0,0,0,0,'black',1);//portrait box
			drawPortrait(this.portrait,x+.25*z,y+ 1.66*z,(((tL/10)*1.75)/tL)*z);
		}//end else
		
	}//end place
  
}//end class
class Dice {
  constructor(type = 'd6') {
    this.targetRx = 0;
    this.targetRy = 0;
    this.targetRz = 0;
    this.type = type;
    this.vertices = [];
    this.faces = [];
    this.faceNormals = [];
    this.rx = 0;
    this.ry = 0;
    this.rz = 0;
    this.rs = 0;
    this.beamDirection = [-1, 0, 0]; // Light from left
    
    // Type-specific properties
    this.colors = this.getColors();
    this.scale = this.getScale();
    
    // Generate geometry based on type
    this.generateGeometry();
  }
  setColor(r, g, b) {
    this.colors = { r, g, b };
}
  getColors() {
    const colors = {
      'd2': { r: 1, g: 0.85, b: 0.3 },
      'd4': { r: 1, g: 0.1, b: 0.2 },
      'd6': { r: 0.1, g: 1, b: 0.3 },
      'd8': { r: 0.8, g: 0.8, b: 1 },
      'd10': { r: 0.8, g: 0.4, b: 0.2 },
      'd12': { r: 1, g: 0.2, b: 0.6 },
      'd20': { r: 0.2, g: 0.4, b: 1 }
    };
    return colors[this.type] || { r: 1, g: 1, b: 1 };
  }
  // Inside class Dice...
setGlow(color) {
    this.glowColor = color;
}
  getScale() {
    const scales = {
      'd2': 1.9,
      'd4': 1.9,
      'd6': 1,
      'd8': 1.9,
      'd10': 2.8,
      'd12': 1,
      'd20': 2.3
    };
    return scales[this.type] || 1;
  }
  
  generateGeometry() {
    switch(this.type) {
      case 'd2':
        this.generateD2();
        break;
      case 'd4':
        this.generateD4();
        break;
      case 'd6':
        this.generateD6();
        break;
      case 'd8':
        this.generateD8();
        break;
      case 'd10':
        this.generateD10();
        break;
      case 'd12':
        this.generateD12();
        break;
      case 'd20':
        this.generateD20();
        break;
      default:
        this.generateD6();
    }
    
    // Compute face normals for all non-d2 types
    if (this.type !== 'd2') {
      this.computeFaceNormals();
    }
  }
  
  generateD2() {
    const slices = 32;
    const radius = 1;
    const thickness = 0.1;
    
    // Edge ring
    for (let i = 0; i < slices; i++) {
      const angle = 2 * Math.PI * i / slices;
      const x = radius * Math.cos(angle);
      const y = radius * Math.sin(angle);
      this.vertices.push([x, y, thickness]);  // front
      this.vertices.push([x, y, -thickness]); // back
    }
    
    // Center points
    this.frontCenter = this.vertices.length;
    this.vertices.push([0, 0, thickness]);
    this.backCenter = this.vertices.length;
    this.vertices.push([0, 0, -thickness]);
    
    // Side quads
    for (let i = 0; i < slices; i++) {
      const i1 = i * 2;
      const i2 = (i * 2 + 2) % (slices * 2);
      const i3 = i2 + 1;
      const i4 = i1 + 1;
      this.faces.push([i1, i2, i3, i4]);
    }
    
    // Front fan
    for (let i = 0; i < slices; i++) {
      const v1 = i * 2;
      const v2 = (i * 2 + 2) % (slices * 2);
      this.faces.push([this.frontCenter, v1, v2]);
    }
    
    // Back fan
    for (let i = 0; i < slices; i++) {
      const v1 = i * 2 + 1;
      const v2 = (i * 2 + 3) % (slices * 2);
      this.faces.push([this.backCenter, v2, v1]);
    }
    
    // Precompute normals for d2
    this.faceNormals = this.faces.map(face => {
      const [p0, p1, p2] = face.map(i => this.vertices[i]);
      const ux = p1[0]-p0[0], uy = p1[1]-p0[1], uz = p1[2]-p0[2];
      const vx = p2[0]-p0[0], vy = p2[1]-p0[1], vz = p2[2]-p0[2];
      const nx = uy*vz - uz*vy;
      const ny = uz*vx - ux*vz;
      const nz = ux*vy - uy*vx;
      const len = Math.hypot(nx,ny,nz);
      return [nx/len, ny/len, nz/len];
    });
  }
  
  generateD4() {
    // Tetrahedron vertices
    this.vertices = [
      [1, 1, 1],
      [-1, -1, 1],
      [-1, 1, -1],
      [1, -1, -1]
    ];
    
    // Normalize vertices
    for (let i = 0; i < this.vertices.length; i++) {
      const [x, y, z] = this.vertices[i];
      const length = Math.hypot(x, y, z);
      this.vertices[i] = [x/length, y/length, z/length];
    }
    
    // Faces
    this.faces = [
      [0, 1, 2],
      [0, 3, 1],
      [0, 2, 3],
      [1, 3, 2]
    ];
  }
  
  generateD6() {
    // Cube vertices
    this.vertices = [
      [-1, -1, -1],
      [-1, -1, 1],
      [-1, 1, -1],
      [-1, 1, 1],
      [1, -1, -1],
      [1, -1, 1],
      [1, 1, -1],
      [1, 1, 1]
    ];
    
    // Faces (quads)
    this.faces = [
      [0, 1, 3, 2], // Left
      [4, 6, 7, 5], // Right
      [0, 4, 5, 1], // Bottom
      [2, 3, 7, 6], // Top
      [0, 2, 6, 4], // Back
      [1, 5, 7, 3]  // Front
    ];
  }
  
  generateD8() {
    // Octahedron vertices
    this.vertices = [
      [ 1,  0,  0], // Right
      [-1,  0,  0], // Left
      [ 0,  1,  0], // Top
      [ 0, -1,  0], // Bottom
      [ 0,  0,  1], // Front
      [ 0,  0, -1]  // Back
    ];
    
    // Faces
    this.faces = [
      [0, 2, 4],
      [2, 1, 4],
      [1, 3, 4],
      [3, 0, 4],
      [2, 0, 5],
      [1, 2, 5],
      [3, 1, 5],
      [0, 3, 5]
    ];
  }
  
  generateD10() {
    const shrink = 0.7;
    const flatZ = 0.515;
    const tiltAmount = 0.75;
    const tiltAmount2 = -0.75;
    
    // Top ring (tilting inward)
    for (let i = 0; i < 5; i++) {
      const angle = (i / 5) * Math.PI * 2;
      const x = Math.cos(angle) * shrink;
      const y = Math.sin(angle) * shrink;
      const z = flatZ - Math.hypot(x, y) * tiltAmount;
      this.vertices.push([x, y, z]);
    }
    
    // Bottom ring (tilting outward)
    for (let i = 0; i < 5; i++) {
      const angle = (i / 5) * Math.PI * 2;
      const x = Math.cos(angle) * shrink;
      const y = Math.sin(angle) * shrink;
      const z = -flatZ - Math.hypot(x, y) * tiltAmount2;
      this.vertices.push([x, y, z]);
    }
    
    // Poles
    this.vertices.push([0, 0, 0.65]);
    this.vertices.push([0, 0, -0.65]);
    
    // Faces
    // Top faces
    for (let i = 0; i < 5; i++) {
      this.faces.push([10, i, (i+1)%5]);
    }
    
    // Bottom faces
    for (let i = 0; i < 5; i++) {
      this.faces.push([11, (i+5), (i+6)%5 + 5]);
    }
  }
  
  generateD12() {
    const phi = (1 + Math.sqrt(5)) / 2;
    
    // Dodecahedron vertices
    this.vertices = [
      [1,1,1], [1,1,-1], [1,-1,1], [1,-1,-1],
      [-1,1,1], [-1,1,-1], [-1,-1,1], [-1,-1,-1],
      [0,1/phi,phi], [0,1/phi,-phi], [0,-1/phi,phi], [0,-1/phi,-phi],
      [1/phi,phi,0], [1/phi,-phi,0], [-1/phi,phi,0], [-1/phi,-phi,0],
      [phi,0,1/phi], [phi,0,-1/phi], [-phi,0,1/phi], [-phi,0,-1/phi]
    ];
    
    // Build edges
    const edges = [];
    const threshold = 0.05;
    const idealDistance = Math.hypot(
      this.vertices[0][0]-this.vertices[8][0],
      this.vertices[0][1]-this.vertices[8][1],
      this.vertices[0][2]-this.vertices[8][2]
    );
    
    for (let i = 0; i < this.vertices.length; i++) {
      for (let j = i+1; j < this.vertices.length; j++) {
        const [x1,y1,z1] = this.vertices[i];
        const [x2,y2,z2] = this.vertices[j];
        const d = Math.hypot(x2-x1, y2-y1, z2-z1);
        if (Math.abs(d - idealDistance) < threshold) {
          edges.push([i,j]);
        }
      }
    }
    
    // Build neighbor map
    const neighbors = {};
    for (let [a,b] of edges) {
      if (!neighbors[a]) neighbors[a] = [];
      if (!neighbors[b]) neighbors[b] = [];
      neighbors[a].push(b);
      neighbors[b].push(a);
    }
    
    // Find pentagonal faces
    this.faces = [];
    const seen = new Set();
    
    const walk = (path) => {
      const current = path[path.length-1];
      if (path.length === 6) {
        if (path[0] === path[5]) {
          const face = path.slice(0,5);
          const key = face.slice().sort((a,b) => a-b).join('-');
          if (!seen.has(key)) {
            this.faces.push(face);
            seen.add(key);
          }
        }
        return;
      }
      for (let neighbor of neighbors[current]) {
        if (path.length > 1 && neighbor === path[path.length-2]) continue;
        if (path.includes(neighbor) && !(path.length===5 && neighbor===path[0])) continue;
        walk([...path, neighbor]);
      }
    };
    
    for (let v = 0; v < this.vertices.length; v++) {
      walk([v]);
    }
  }
  
  generateD20() {
    // Icosahedron vertices
    const t = (1 + Math.sqrt(5)) / 2;
    this.vertices = [
      [-1, t, 0], [1, t, 0], [-1, -t, 0], [1, -t, 0],
      [0, -1, t], [0, 1, t], [0, -1, -t], [0, 1, -t],
      [t, 0, -1], [t, 0, 1], [-t, 0, -1], [-t, 0, 1]
    ];
    
    // Normalize vertices
    for (let i = 0; i < this.vertices.length; i++) {
      const [x, y, z] = this.vertices[i];
      const length = Math.hypot(x, y, z);
      this.vertices[i] = [x/length, y/length, z/length];
    }
    
    // Faces
    this.faces = [
      [0, 11, 5], [0, 5, 1], [0, 1, 7], [0, 7, 10], [0, 10, 11],
      [1, 5, 9], [5, 11, 4], [11, 10, 2], [10, 7, 6], [7, 1, 8],
      [3, 9, 4], [3, 4, 2], [3, 2, 6], [3, 6, 8], [3, 8, 9],
      [4, 9, 5], [2, 4, 11], [6, 2, 10], [8, 6, 7], [9, 8, 1]
    ];
  }
  
  computeFaceNormals() {
    this.faceNormals = this.faces.map(face => {
      const [p0, p1, p2] = face.map(i => this.vertices[i]);
      const ux = p1[0]-p0[0], uy = p1[1]-p0[1], uz = p1[2]-p0[2];
      const vx = p2[0]-p0[0], vy = p2[1]-p0[1], vz = p2[2]-p0[2];
      const nx = uy*vz - uz*vy;
      const ny = uz*vx - ux*vz;
      const nz = ux*vy - uy*vx;
      const len = Math.hypot(nx,ny,nz);
      return [nx/len, ny/len, nz/len];
    });
  }
  
  rotateVertex([x, y, z], rx, ry, rz) {
    let cosa = Math.cos(rx), sina = Math.sin(rx);
    let y1 = y * cosa - z * sina, z1 = y * sina + z * cosa;
    let cosb = Math.cos(ry), sinb = Math.sin(ry);
    let x2 = x * cosb + z1 * sinb, z2 = -x * sinb + z1 * cosb;
    let cosc = Math.cos(rz), sinc = Math.sin(rz);
    let x3 = x2 * cosc - y1 * sinc, y3 = x2 * sinc + y1 * cosc;
    return [x3, y3, z2];
  }
  
  project([x, y, z], size, cx, cy, d) {
    const scale = size / (z + d);
    return [cx + x * scale, cy + y * scale, z];
  }
  
  stepRotation(dt) {
    // Safety check: if dt is missing, assume 60fps (0.016)
    if (!dt) dt = 0.016;
    
    // We multiply by 60 to match your original speed settings (like '99')
    // 0.02 * 60 = 1.2 multiplier
    const speed = 1.2 * this.rs * dt;

    if (this.type === 'd2' && this.rs === 'stop') {
      this.rx = 0;
      this.ry = 0;
      this.rz = 0;
    } else {
      this.rx += speed;
      this.ry += (speed * 0.75); // Maintains your original ratio
      this.rz += (this.type === 'd2' ? 0 : (speed * 0.5)); 
    }
  }
  
  draw(ctx, cx, cy, size, d, light) {
    if (!light) light = this.beamDirection;
    
    const verts3d = this.vertices.map(v => this.rotateVertex(v, this.rx, this.ry, this.rz));
    const verts2d = verts3d.map(v => this.project(v, size, cx, cy, d));
    
    const faceDepths = this.faces.map((face, idx) => {
      const depth = face.reduce((sum, i) => sum + verts3d[i][2], 0) / face.length;
      return { face, depth, idx };
    }).sort((a, b) => b.depth - a.depth);
    
    ctx.save();
    ctx.lineWidth = 1;
    // --- NEW GLOW LOGIC START ---
    if (this.glowColor) {
        // 1. Set the Glow Color
        ctx.shadowColor = this.glowColor;
        
        // 2. Scale the Blur based on size (so it doesn't look huge when far away)
        ctx.shadowBlur = size * 0.6; 

        // 3. (Optional) "Lighter" mode makes overlapping faces blindingly bright (FIRE EFFECT)
        // If you want a solid neon object instead of fire, remove this line.
        ctx.globalCompositeOperation = 'lighter';
    }
    for (let { face, idx } of faceDepths) {
      const pts2d = face.map(i => verts2d[i]);
      const normal = this.faceNormals[idx];
      const rotatedNormal = this.rotateVertex(normal, this.rx, this.ry, this.rz);
      
      let dot = rotatedNormal[0] * light[0] + rotatedNormal[1] * light[1] + rotatedNormal[2] * light[2];
      dot = Math.max(0, dot);
      const shade = Math.floor(30 + dot * 225);
      
      // Draw face
      ctx.beginPath();
      ctx.moveTo(pts2d[0][0], pts2d[0][1]);
      for (let p of pts2d.slice(1)) ctx.lineTo(p[0], p[1]);
      ctx.closePath();
      
      // Apply color based on type
      const c = this.colors;
      ctx.fillStyle = `rgb(${Math.floor(shade*c.r)},${Math.floor(shade*c.g)},${Math.floor(shade*c.b)})`;
      ctx.strokeStyle = `rgb(${Math.floor((15+shade)*c.r)},${Math.floor((15+shade)*c.g)},${Math.floor((20+shade)*c.b)})`;
      ctx.fill();
      ctx.stroke();
      
      // Draw number (skip entirely for d2/coin)
      if (this.type == 'd100') {
        const centerX = pts2d.reduce((sum,p) => sum + p[0], 0) / pts2d.length;
        const centerY = pts2d.reduce((sum,p) => sum + p[1], 0) / pts2d.length;
        
        ctx.fillStyle = dot > 0.3 ? "#000" : "#fff";
        ctx.font = `bold ${this.type === 'd20' ? 14 : 18}px sans-serif`;
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText((idx+1).toString(), centerX, centerY);
      }
    }
    
    ctx.restore();
  }
  
  // New helper to set the "landing" angles
  setStaticPosition(rx, ry, rz) {
    this.targetRx = rx;
    this.targetRy = ry;
    this.targetRz = rz;
  }

  animate(x, y, z, rs, dt) {
    this.rs = rs;
    if (!dt) dt = 0.016;

    if (rs === 0) {
      // Snap to the specific defined position
      this.rx = this.targetRx || 0;
      this.ry = this.targetRy || 0;
      this.rz = this.targetRz || 0;
    } else {
      // Standard rotation logic
      if (this.type === 'd2') {
        this.stepRotation(dt);
      } else {
        const speed = 1.2 * rs * dt;
        this.rx += speed;
        this.ry += speed * 0.75;
        this.rz += speed * 0.5;
      }
    }
    
    const scale = this.scale * (tL / 10) * z;
    const posX = tX + (tL / 10) * x;
    const posY = tY + (tH / 10) * y;
    
    this.draw(ctx, posX, posY, scale, 4);
  }
}
class stone{
  constructor(x,y,z,stat){
    this.applied = 0;
    //current position
    this.x = x;
    this.y = y;
    this.z = z;
    //target position
    this.tx = x;
    this.ty = y;

    this.stat = stat;
    this.owner = 2; //0-player, 1-foe,2-field

    this.tSX = 1.545; this.tSY = 4.545;
    this.tCX = 7.625; this.tCY = 4.625;
    this.tIX = 3.545; this.tIY = 4.49;
    this.tAX = 5.545; this.tAY = 4.53;

    this.pSX = 3.23; this.pSY = 6.48;
    this.pCX = 6.12; this.pCY = 6.48;
    this.pIX = 3.19; this.pIY = 9.1;
    this.pAX = 6.10; this.pAY = 9.1;

    this.fSX = this.pSX; this.fSY = this.pSY;
    this.fCX = this.pCX; this.fCY = this.pCY;
    this.fIX = this.pIX; this.fIY = this.pIY;
    this.fAX = this.pIX+2.9; this.fAY = this.pIY;
    }
  refresh(dt){
    //Movement logic
    const speed = 6*dt;
    if (Math.abs(this.tx - this.x) > 0.01) 
    {this.x += (this.tx - this.x)*speed}
    else{this.x = this.tx;}
    if (Math.abs(this.ty - this.y) > 0.01){
      this.y +=(this.ty - this.y)*speed}
    else{this.y = this.ty}
    //Drawing logic
    if (this.owner == 1){
      ctx.translate(wX/2,wY/2);
      ctx.rotate(Math.PI);
      ctx.translate(-wX/2,-wY/2);
    }
    switch(this.stat){
      case eSTAT.S:
            drawShape('qua',this.x,this.y,this.z*.9, .5,0, 0,.5, .5,1, 1,.5,'yellow',1);
            drawShape('qua',this.x,this.y,this.z*.9, .5,0, 0,.5, .5,1, 1,.5,'rgba(255,255,255,.25)',1);
            drawShape('tri',this.x,this.y,this.z*.9, 0,.5, .5,1, 1,.5, 0,0,'rgba(0,0,0,.15)',1);
            drawShape('tri',this.x,this.y,this.z*.9, .5,0, 1,.5, .5,1, 0,0,'rgba(255,255,255,.25)',1);
            drawPortrait(-4,this.x+.25,this.y+.25,.0420)
          
            break;
      case eSTAT.C:
         drawShape('qua',this.x,this.y,this.z*.75, 0,0.1, .5,0, 1,.1, .5,.2,'green',1);
         drawShape('qua',this.x,this.y,this.z*.75, 0,0.1, .5,0, 1,.1, .5,.2,'rgba(0,0,0,.25)',1);
         drawShape('qua',this.x,this.y,this.z*.75, 0,0.1, 0,.9, .5,1, .5,.2,'green',1);
         drawShape('qua',this.x,this.y,this.z*.75, 1,0.1, 1,.9, .5,1, .5,.2,'green',1);
         drawShape('qua',this.x,this.y,this.z*.75, 1,0.1, 1,.9, .5,1, .5,.2,'rgba(255,255,255,.25)',1);
          //drawShape('rec',this.x,this.y,this.z*.75,0,0,1,1,0,0,0,0,'green',1);
          //drawShape('rec',this.x,this.y,this.z*.75,0,0,1,1,0,0,0,0,'rgba(255,255,255,.45)',1);
          //drawShape('rec',this.x,this.y,this.z*.5,.5,.5,1,1,0,0,0,0,'rgba(255,255,255,.45)',1);
          drawPortrait(-6,this.x+.165,this.y+.165,.0420)
        

         break;
      case eSTAT.I:
        drawShape('qua',this.x,this.y,this.z*.9, 0,.9, 0.5,0.1, 1,.9, .5,1,'red',1);
        drawShape('tri',this.x,this.y,this.z*.9, .5,0.1, 1,.9, .5,1, 1,.5,'rgba(255,255,255,.45)',1);
        drawPortrait(-5,this.x+.22,this.y+.38,.0360)
       
        break;
      case eSTAT.A:
        drawShape('arc',this.x,this.y,this.z, .45,.47, .4,0, 2,0, .0,0,'rgba(0,0,255,.5)',1);
        drawShape('arc',this.x,this.y,this.z, .45,.47, .4,0, 2,0, .0,0,'rgba(0,0,255,.5)',1);
        drawShape('arc',this.x,this.y,this.z, .5,.47, .36,0, 2,0, .0,0,'rgba(255,255,255,.075)',1);
        drawShape('arc',this.x,this.y,this.z, .55,.47, .3,0, 2,0, .0,0,'rgba(255,255,255,.075)',1);
        drawShape('arc',this.x,this.y,this.z, .65,.47, .2,0, 2,0, .0,0,'rgba(255,255,255,.075)',1);
        drawShape('arc',this.x,this.y,this.z, .75,.47, .1,0, 2,0, .0,0,'rgba(255,255,255,.075)',1);
        drawShape('arc',this.x,this.y,this.z, .45,.47, .4,0, 2,0, .0,0,'rgba(0,0,0,.15)',1);
        drawShape('arc',this.x,this.y,this.z, .45,.47, .4,0, 2,0, .0,0,'rgba(255,255,255,.075)',1);
        //drawShape('qua',this.x,this.y,this.z*.9, .5,0, 0,.5, .5,1, 1,.5,'rgba(255,255,255,.25)',1);
        drawPortrait(-7,this.x+.25,this.y+.25,.0420)
     
        break;
    }
    if (this.owner == 1){
      ctx.translate(wX/2,wY/2);
      ctx.rotate(Math.PI);
      ctx.translate(-wX/2,-wY/2);
    }
  }
  changeOwner(newowner){
    switch (this.owner){
      case 0://player currently owns
        switch (this.stat){
          case eSTAT.S:
            if (newowner == 2){//if table takes ownership from player
              this.tx =this.tSX;
              this.ty = this.tSY;
              Player.runeStat[0]= 0;
            }
            if (newowner == 1){//if foe takes ownership of stone from player
              this.tx =this.fSX;
              this.ty = this.fSY;
              
              Foe.runeStat[0]= 1;
              Player.runeStat[0] = 0;
              
            }
            if (newowner == 0){//if Player monster dies while owning stone, the next monster gets the effect applied
              Player.runeStat[0] = 1;
            }
            break;//end case eSTAT.S
          case eSTAT.C:
            if (newowner == 2){//if table takes ownership from player
              this.tx = this.tCX;
              this.ty = this.tCY;
              Player.runeStat[1]= 0;
            }
            if (newowner == 1){//if foe takes ownership of stone from player
              this.tx = this.fCX;
              this.ty = this.fCY;
              Foe.runeStat[1]= 1;
              Player.runeStat[1] = 0;
            }
            if (newowner == 0){//if Player monster dies while owning stone, the next monster gets the effect applied
              Player.runeStat[1] = 1;
            }
            break;
          case eSTAT.I:
            if (newowner == 2){//if table takes ownership from player
              this.tx = this.tIX;
              this.ty = this.tIY;
              Player.runeStat[2] = 0;
            }
            if (newowner == 1){//if foe takes ownership of stone from player
              this.tx = this.fIX;
              this.ty = this.fIY;
              Foe.runeStat[2] = 1;
              Player.runeStat[2] = 0;
            }
            if (newowner == 0){//if Player monster dies while owning stone, the next monster gets the effect applied
              Player.runeStat[2] = 1;
            }
            break;
          case eSTAT.A:
            if (newowner == 2){//if table takes ownership from player
              this.tx = this.tAX;
              this.ty = this.tAY;
             Player.runeStat[3]= 0;
            }
            if (newowner == 1){//if foe takes ownership of stone from player
              this.tx = this.fAX;
              this.ty = this.fAY;
              Player.runeStat[3] = 0;
              Foe.runeStat[3] = 1;
            }
            if (newowner == 0){//if Player monster dies while owning stone, the next monster gets the effect applied
              Player.runeStat[3] = 1;
            }
            break;
        }//end this.stat switch
        break;//end case 0 player currently owns
      case 1://foe currently owns
        switch (this.stat){
          case eSTAT.S:
            if (newowner == 2){//if table takes ownership from foe
              this.tx =this.tSX;
              this.ty = this.tSY;
              Foe.runeStat[0] = 0;
            }
            if (newowner == 0){//if player takes ownership of stone from foe
              this.tx =this.pSX;
              this.ty = this.pSY;
              Player.runeStat[0] = 1;
              Foe.runeStat[0] = 0;
            }
            if (newowner == 1){//if Foe monster dies while owning stone, the next monster gets the effect applied
              Foe.runeStat[0] = 1;
            }
            break;//end case eSTAT.S
          case eSTAT.C:
            if (newowner == 2){//if table takes ownership from foe
              this.tx =this.tCX;
              this.ty = this.tCY;
              Foe.runeStat[1] = 0;
            }
            if (newowner == 0){//if player takes ownership of stone from foe
              this.tx =this.pCX;
              this.ty = this.pCY;
              Player.runeStat[1] = 1;
              Foe.runeStat[1] = 0;
            }
            if (newowner == 1){//if Foe monster dies while owning stone, the next monster gets the effect applied
              Foe.runeStat[1] = 1;
            }
            break;
          case eSTAT.I:
            if (newowner == 2){//if table takes ownership from foe
              this.tx =this.tIX;
              this.ty = this.tIY;
              Foe.runeStat[2] = 0;
            }
            if (newowner == 0){//if player takes ownership of stone from foe
              this.tx =this.pIX;
              this.ty = this.pIY;
              Player.runeStat[2] = 1;
              Foe.runeStat[2] = 0;
            }
            if (newowner == 1){//if Foe monster dies while owning stone, the next monster gets the effect applied
              Foe.runeStat[2] = 1;
            }
            break;
          case eSTAT.A:
            if (newowner == 2){//if table takes ownership from foe
              this.tx =this.tAX;
              this.ty = this.tAY;
              Foe.runeStat[3] = 0;
            }
            if (newowner == 0){//if player takes ownership of stone from foe
              this.tx =this.pAX;
              this.ty = this.pAY;
              Player.runeStat[3] = 1;
              Foe.runeStat[3] = 0;
            }
            if (newowner == 1){//if Foe monster dies while owning stone, the next monster gets the effect applied
              Foe.runeStat[3] = 1;
            }
            break;
          }//end switch this.stat switch
        break;//end case 1 foe currently owns
      case 2://table currently owns
        switch(this.stat){
          case eSTAT.S:
            if (newowner == 0){//if player takes ownership from table
              this.tx =this.pSX;
              this.ty = this.pSY;
              Player.runeStat[0] = 1;
            }
            if (newowner == 1){//if foe takes ownership of stone from table
              this.tx =this.fSX;
              this.ty = this.fSY;
              Foe.runeStat[0] = 1;
            }
            break;//end case eSTAT.S
          case eSTAT.C:
            if (newowner == 0){//if player takes ownership from table
              this.tx =this.pCX;
              this.ty = this.pCY;
              Player.runeStat[1] = 1;
            }
            if (newowner == 1){//if foe takes ownership of stone from table
              this.tx =this.fCX;
              this.ty = this.fCY;
              Foe.runeStat[1] = 1;
            }
            break;
          case eSTAT.I:
            if (newowner == 0){//if player takes ownership from table
              this.tx =this.pIX;
              this.ty = this.pIY;
              Player.runeStat[2] = 1;
            }
            if (newowner == 1){//if foe takes ownership of stone from table
              this.tx =this.fIX;
              this.ty = this.fIY;
              Foe.runeStat[2] = 1;
            }
            if (newowner == 'tutorial'){
              this.tx =2.9;
              this.ty = 1;
            }
            break;
          case eSTAT.A:
            if (newowner == 0){//if player takes ownership from table
              this.tx =this.pAX;
              this.ty = this.pAY;
              Player.runeStat[3] = 1;
            }
            if (newowner == 1){//if foe takes ownership of stone from table
              this.tx =this.fAX;
              this.ty = this.fAY;
              Foe.runeStat[2] = 1;
            }
            break;
        }//end this.stat switch
        break;//case 2 this.owner break
      case 'tutorial':
              this.tx =this.tIX;
              this.ty = this.tIY;
      break;

      }//end this.ownerswitch
    this.owner = newowner;
  }//end changeowner
  
}//end class stone
var sRune = new stone(1.545,4.545,1,eSTAT.S);
var cRune = new stone(7.625,4.625,1,eSTAT.C);
var iRune = new stone(3.545,4.49,1,eSTAT.I);
var aRune = new stone(5.545,4.53,1,eSTAT.A);
var Player = new Field(0);
var Dungeon = new Explore();
var Foe = new Field(1,1);
var song = 0;
var cursong= 0;
var MessageBox = new btn(0,0,1,3,3,'Testing the message box','red','blue',0,1) //x,y,z,l,h,text,framecolor,textColor,visible = 0
var btnYes = new btn(0,0,1,3,3,'Yes','red','blue',1,1)
var btnNo = new btn(0,0,1,3,3,'No','red','blue',2,1)
//////////////////////[EVENT LISTENERS]////////////////////////////
//////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////
window.addEventListener('resize', resizeCanvas, false);
window.addEventListener("orientationchange", function() {setTimeout(resizeCanvas, 200);}, false);
window.addEventListener("deviceorientation", resizeCanvas, true);
function handleInput(e) {
  const now = Date.now();
  const clientX = e.clientX;
  const clientY = e.clientY;
  let tl = (tL/10);
  let newX = Dungeon.x;
    let newY = Dungeon.y;
    let isMoving = false;
 
  const pos = {x: clientX - (wX-tL)/2, y: clientY - (wY-tH)/2}
  if (startGame == 'dialogue'||startGame == 'tutorial'){
    if (startGame == 'dialogue' && Dungeon.dCounter == 1){}else{
      if (Dungeon.option != 7){
      Dungeon.dCounter = Dungeon.dCounter + 1;}
    }
    
  }
// Convert pixels to Grid Units so they match the MessageBox coordinates
const gridPos = {
  x: pos.x / (tL/10),
  y: pos.y / (tH/10)
};

// Now check collision using gridPos instead of pos
if (MessageBox.isTouched(gridPos.x, gridPos.y) && MessageBox.visible > 0&&MessageBox.type != 'jrpg') {
    MessageBox.press();
}
if (btnYes.isTouched(gridPos.x, gridPos.y) && btnYes.visible > 0&&btnYes.type != 'jrpg') {
    btnYes.press();
}
if (btnNo.isTouched(gridPos.x, gridPos.y) && btnNo.visible > 0&&btnNo.type != 'jrpg') {
    btnNo.press();
}
  //restart the game at end screen
  if (Player.option === 'DEFEAT' || Player.option === 'TRIUMPH') {
    window.location.reload();
    return;
  }
  //GAME START CLICKS///////////////
 //GAME START CLICKS///////////////
  if(startGame == 'jukebox'){
     
     // --- LEFT ARROW ---
     if (pos.x > (tL/10)*1 && pos.x <= (tL/10)*3  && 
         pos.y > (tH/10)*3 && pos.y < (tH/10)*5 ){
         
         if (song == 'shuffle') {
             song = 21;
         } else {
             song = song - 1;
         }

         MusicEngine.stop();

         if (song < 0) {
             song = 'shuffle';
             cursong = rnd(0,21)
             MusicEngine.play(cursong);
         } else {
             MusicEngine.play(song);
         }
         
         // CRITICAL FIX: Reset the timer so the game loop doesn't 
         // immediately try to play another song on top of this one.
         lastSongTime = Date.now(); 
         return; 
     }

     // --- RIGHT ARROW ---
     if (pos.x > (tL/10)*7 && pos.x <= (tL/10)*9  && 
         pos.y > (tH/10)*3 && pos.y < (tH/10)*5 ){
         
         if (song == 'shuffle') {
             song = 0;
         } else {
             song = song + 1;
         }

         MusicEngine.stop();

         if (song > 21) {
             song = 'shuffle';
             cursong = rnd(0,21);
             MusicEngine.play(cursong);
         } else {
             MusicEngine.play(song);
         }

         // CRITICAL FIX: Reset the timer here too
         lastSongTime = Date.now(); 
         return;
     }

     // --- STOP BUTTON ---
     if (pos.x > (tL/10)*4.4 && pos.x <= (tL/10)*5.6  && 
         pos.y > (tH/10)*3.4 && pos.y < (tH/10)*4.6 ){
         MusicEngine.stop();
         return;
     }

     // --- EXIT BUTTON ---
     if (pos.x > (tL/10)*0 && pos.x <= (tL/10)*2  && 
        pos.y > (tH/10)*8 && pos.y < (tH/10)*10 ){
         MusicEngine.stop();
         startGame = 0;
         return;
     }
  }
  if (startGame == 'explore'){
    Dungeon.registerClick(e.clientX, e.clientY);
      if(rnd(0,4)==.5) {startGame = 'battle';
        for (let i = 0; i < 4; i++) {
            let targetX = Math.floor(Dungeon.x);
            let targetY = Math.floor(Dungeon.y);

            // Calculate which tile we are currently facing
            if (Dungeon.dir === 0) targetY -= 1; // Facing North
            else if (Dungeon.dir === 1) targetX += 1; // Facing East
            else if (Dungeon.dir === 2) targetY += 1; // Facing South
            else if (Dungeon.dir === 3) targetX -= 1; // Facing West

            // Check if that tile is a wall
            if (!Dungeon.isWall(targetX, targetY)) {
                // It is NOT a wall (it's open space). We are good!
                break; 
            }

            // If it WAS a wall, turn right (clockwise) and the loop runs again
            Dungeon.dir = (Dungeon.dir + 1) % 4;
        }
        // -------------------------

        return;
      }
       if (pos.x > (tL/10)*-1   && pos.x <= (tL/10)*2.5  && //turn dir left
        pos.y > (tH/10)*0 && pos.y < (tH/10)*10 ){
        //0=N, 1=E, 2=S, 3=W
        Dungeon.dir = (Dungeon.dir + 3) % 4;
        return;
        
    }
    if (pos.x > (tL/10)*7.5   && pos.x <= (tL/10)*11  && //turn dir right
        pos.y > (tH/10)*0 && pos.y < (tH/10)*10 ){
        //0=N, 1=E, 2=S, 3=W
        Dungeon.dir = (Dungeon.dir + 1) % 4;
        return;
        
    }
  
    if (pos.x > (tL/10)*2.5   && pos.x <= (tL/10)*7.5  && //move forward
        pos.y > (tH/10)*0 && pos.y < (tH/10)*7 ){
          if (Dungeon.canInteract()) {
             // Pass the raw click to the Dungeon so sprites can check it
             Dungeon.registerClick(e.clientX, e.clientY);
             return; // STOP HERE. Do not set isMoving = true.
        }
        //0=N, 1=E, 2=S, 3=W
        isMoving = true;
        if (Dungeon.dir == 0) newY -= 1; // N
        if (Dungeon.dir == 1) newX += 1; // E
        if (Dungeon.dir == 2) newY += 1; // S
        if (Dungeon.dir == 3) newX -= 1; // W
    }
    if (pos.x > (tL/10)*2.5   && pos.x <= (tL/10)*7.5  && //move backwards
        pos.y > (tH/10)*7 && pos.y < (tH/10)*10 ){
        //0=N, 1=E, 2=S, 3=W
        isMoving = true;
        if (Dungeon.dir == 0) newY += 1; // Back from N is S (y+1)
        if (Dungeon.dir == 1) newX -= 1; // Back from E is W (x-1)
        if (Dungeon.dir == 2) newY -= 1; // Back from S is N (y-1)
        if (Dungeon.dir == 3) newX += 1; // Back from W is E (x+1)
    }
    if (isMoving) {
        // Use your Dungeon class's isWall method to check bounds
        // We floor the values just in case you use floats (like 1.5)
        if (!Dungeon.isWall(Math.floor(newX), Math.floor(newY))) {
            Dungeon.x = newX;
            Dungeon.y = newY;
        } else {
            console.log("Bonk! Wall hit.");
        }
    }
 
  }
  if (startGame == 3){
    if (pos.x > (tL/10)*1 && pos.x <= (tL/10)*4  && //CPU
        pos.y > (tH/10)*6 && pos.y < (tH/10)*8 ){
      Foe.isCPU = 1;
      MusicEngine.stop();
      MusicEngine.play(4);
      startGame = 4;
      MusicEngine.playSFX('heal');
      return;
    }
    else if (pos.x > (tL/10)*6 && pos.x <= (tL/10)*9.5  && //LOCAL
      pos.y > (tH/10)*6 && pos.y < (tH/10)*8 ){
      Foe.isCPU = 0;
      MusicEngine.stop();
      MusicEngine.play(4);
      startGame = 4;
      MusicEngine.playSFX('heal');
      return;
    }
    else if (pos.x > (tL/10)*1 && pos.x <= (tL/10)*4  && //Tutorial
      pos.y > (tH/10)*8.5 && pos.y < (tH/10)*10 ){
      Foe.isCPU = 0;
      MusicEngine.stop();
      MusicEngine.play(4);
      startGame = 'explore';
      MusicEngine.playSFX('heal');
      return;
    }
    else if (pos.x > (tL/10)*6&& pos.x <= (tL/10)*9.5  && //Jukebox
      pos.y > (tH/10)*8.5 && pos.y < (tH/10)*10 ){
      Foe.isCPU = 0;
      MusicEngine.stop();
      
      startGame = 'jukebox';
      MusicEngine.playSFX('heal');
      return;
    }
  }
  if (startGame == 2){
    lastSongTime = Date.now();
    lastTriggerTime = Date.now();
    startGame = 3
    MusicEngine.playSFX('click');
    return;
  }
  if (startGame == 1){
    lastTriggerTime = Date.now();
    lastSongTime = Date.now();
    startGame = 2;
    MusicEngine.playSFX('click');
    
    return;
  }
  if (startGame == 0){
    MusicEngine.init();
    
setTimeout(() => {
    song = rnd(0,10)
      MusicEngine.stop();
      if (song == 0) MusicEngine.play(8);
      if (song == 1) MusicEngine.play(15);
      if (song == 2) MusicEngine.play(5);
      if (song == 3) MusicEngine.play(17);
      if (song == 4) MusicEngine.play(6);
      if (song == 5) MusicEngine.play(9);
      if (song == 6) MusicEngine.play(13);
      if (song == 7) MusicEngine.play(16);
      if (song == 8) MusicEngine.play(11);
      if (song == 9) MusicEngine.play(20);
      if (song == 10) MusicEngine.play(21);
}, 1000);
MusicEngine.playSFX('warp');
    
    
    startGame = 1;
    lastSongTime = Date.now();
    lastTriggerTime = Date.now();
    return;
  }
  ////////////////////////
  if (Dungeon.option == 1){
    if (pos.x >= (tL/10)* mX && pos.x <= (tL/10)*(mX+cL) && pos.y > (tH/10)*cY  && pos.y < (tH/10)*(cY+cH)){
      Dungeon.option =2;Dungeon.dCounter = 0;
      MusicEngine.playSFX('heal')
    }
  }
   if (Dungeon.option == 3){
    if (pos.x >= (tL/10)*maX && pos.x <= (tL/10)*(maX+actLH) && pos.y > (tH/10)*actY   && pos.y < (tH/10)*(actY+actLH)){
      MusicEngine.stop();
      MusicEngine.playSFX('slash');
      MusicEngine.play(5)
      Dungeon.option = 4;
      Dungeon.dCounter = 0;
    }
  }
  if(Dungeon.option == 7){
    if (Dungeon.dCounter == 1){
      if (pos.x > (tL/10)*0 && pos.x < (tL/10)*1&& pos.y > (tH/10)*7.5   && pos.y < (tH/10)*9){Dungeon.dCounter = 2;MusicEngine.playSFX('heal')}//larrow
      if (pos.x > (tL/10)*3 && pos.x <= (tL/10)*4 && pos.y > (tH/10)*7.5   && pos.y < (tH/10)*9){Dungeon.dCounter = 2;MusicEngine.playSFX('heal')}//rarrow
    }
    if (Dungeon.dCounter == 3){if (pos.x > (tL/10)*.875 && pos.x < (tL/10)*(.875 + 2.25) && pos.y > (tH/10)*6.5   && pos.y < (tH/10)*10){Dungeon.dCounter = 4;MusicEngine.playSFX('heal')}}
    if(Dungeon.dCounter == 5){
if (pos.x >= (tL/10)*huX && pos.x <= (tL/10)*(huX+actLH) && //pHand use 5
            pos.y > (tH/10)*actY  && pos.y < (tH/10)*(actY+actLH)){Dungeon.dCounter =6; MusicEngine.stop();MusicEngine.playSFX('slash'); MusicEngine.play(16)}
      
    }
  }
  
  //MAIN GAME CLICKING////////////
  //Player non battle clicks
  if (Foe.option != 2 && Foe.option != 4 && Foe.option < 6 && Player.draw == 0 && Foe.draw == 0){//PLAYER CLICKING
    switch(Player.option){
      case 0://Initiate Click Menus and Buttons
        //PLAYER
          if (pos.x >= (tL/10)*hX   && pos.x <= (tL/10)*(hX+cL)  && //pHand menu visible 1
              pos.y > (tH/10)*cY && pos.y < (tH/10)*(cY+cH) ){
            Player.btnDo('hm');
          }
          if (pos.x >= (tL/10)*harX && pos.x <= (tL/10)*(harX+aLH)   && //pHand right arrow button
              pos.y > (tH/10)*arY  && pos.y < (tH/10)*(arY+aLH)){
            Player.btnDo('hra');
          }
          if (pos.x >= (tL/10)*halX  && pos.x <= (tL/10)*(halX+aLH)   && //pHand left arrow button
              pos.y > (tH/10)*arY  && pos.y < (tH/10)*(arY+aLH)){
              Player.btnDo('hla');
             // Player.hand[0] = new Card(17, 0);
              //Foe.hand[0] = new Card(13, 1);
             // Foe.hand[1] = new Card(13, 1);
              //Foe.aMonster[0] = new Card(9, 1);
          }

          if (pos.x >= (tL/10)*marX && pos.x <= (tL/10)*(marX+aLH)   && //pMon right arrow button
              pos.y > (tH/10)*arY  && pos.y < (tH/10)*(arY+aLH)){
              Player.btnDo('mra');
          }
          if (pos.x >= (tL/10)*malX  && pos.x <= (tL/10)*(malX+aLH)  && //pMon left arrow button
              pos.y > (tH/10)*arY  && pos.y < (tH/10)*(arY+aLH)){
              Player.btnDo('mla')
          }
          if (pos.x >= (tL/10)* mX   && pos.x <= (tL/10)*(mX+cL)  && //pMonster menu visible 3
              pos.y > (tH/10)*cY  && pos.y < (tH/10)*(cY+cH)){
              Player.btnDo('mmo')
          } 
          
      
      break;
      case 1://Player Hand Menu Visible
        //non redundant buttons
        if (pos.x <= (tL/10)*(hX-.8)  || pos.x >= (tL/10)*((hX+cL)+1) || //pHand menu close 0
            pos.y < (tH/10)*(cY) || pos.y > (tH/10)*(cY+cH)){
          Player.btnDo('mc')
        }
        if (pos.x >= (tL/10)*heX  && pos.x <= (tL/10)*(heX+actLH) && //pHand examine 2
            pos.y > (tH/10)*actY  && pos.y < (tH/10)*(actY+actLH)){
          Player.btnDo('hex')
        }
        if (pos.x >= (tL/10)*huX && pos.x <= (tL/10)*(huX+actLH) && //pHand use 5
            pos.y > (tH/10)*actY  && pos.y < (tH/10)*(actY+actLH)){
              for (let i = 0; i < Player.aMonster.length; i++){
                    if (Player.hand[Player.look[eLOOK.H]].index == Player.aMonster[i].index){//disallow duplicates.. not really necessary since decks only have 1 per card... But other versions might not.
    
                      return
                    }
                  }
          Player.btnDo('use')
        }
        //redundant
        if (pos.x >= (tL/10)*(harX-.5) && pos.x <= (tL/10)*((harX+aLH)+.5)   && //pHand right arrow button
            pos.y > (tH/10)*(arY-.5)  && pos.y < (tH/10)*((arY+aLH)+.5)){
            Player.btnDo('hra');
          }
        if (pos.x >= (tL/10)*(halX-.5)  && pos.x <= ((tL/10)*(halX+aLH)+.5)   && //pHand left arrow button
            pos.y > (tH/10)*(arY-.5)  && pos.y < (tH/10)*((arY+aLH)+.5)){
            Player.btnDo('hla');
        }
        if (pos.x >= (tL/10)*marX && pos.x <= (tL/10)*(marX+aLH)   && //pMon right arrow button
            pos.y > (tH/10)*arY  && pos.y < (tH/10)*(arY+aLH)){
            Player.btnDo('mra');
        }
        if (pos.x >= (tL/10)*malX  && pos.x <= (tL/10)*(malX+aLH)  && //pMon left arrow button
            pos.y > (tH/10)*arY  && pos.y < (tH/10)*(arY+aLH)){
              if(Player.hand.length <= 1){
                Player.btnDo('mla')
              }
            
        }
        if (pos.x >= (tL/10)* mX   && pos.x <= (tL/10)*(mX+cL)  && //pMonster menu visible 3
            pos.y > (tH/10)*cY  && pos.y < (tH/10)*(cY+cH)){
            Player.btnDo('mmo')
        }
        break;
      case 2://Player Hand Examine Visible
        if(pos.x >= (tL/10)*3 && pos.x <= (tL/10)*9  && //examine right arrow button
           pos.y > (tH/10)*4  && pos.y < (tH/10)*6){
          Player.btnDo('hra')
        }
        if(pos.x >= (tL/10)*1 && pos.x <= (tL/10)*3  && //examine left arrow button
           pos.y > (tH/10)*4  && pos.y < (tH/10)*6){
          Player.btnDo('hla')
        }
        if(pos.x >= (tL/10)*8.25 && pos.x <= (tL/10)*9.1 &&//exit from hand zoom
           pos.y > (tH/10)*0.5  && pos.y < (tH/10)*1.5){
          Player.btnDo('hec')
        }
          break;
      case 3://Player Monster Menu Visible
      //non redundant buttons
        if (pos.x <= (tL/10)*(mX-1)    || pos.x >= (tL/10)*((mX+cL)+.5)  || //pMonster menu close p0
            pos.y < (tH/10)*cY  || pos.y > (tH/10)*(cY+cL)){
          Player.btnDo('mc')
        }
        if (pos.x >= (tL/10)*meX    && pos.x <= (tL/10)*(meX+actLH)  && //pMonster examine click p4
            pos.y > (tH/10)*actY   && pos.y < (tH/10)*(actY+actLH)){
            Player.btnDo('me')
        }
        if (pos.x >= (tL/10)*maX    && pos.x <= (tL/10)*(maX+actLH)  && //pMonster attack click p6
            pos.y > (tH/10)*actY   && pos.y < (tH/10)*(actY+actLH)&&Player.aMonster[Player.look[eLOOK.M]].type == 0){
            Player.btnDo('atk')
            MusicEngine.playSFX('slash');
        }
        //redundant buttons


        if (pos.x >= (tL/10)*(marX-.5) && pos.x <= (tL/10)*((marX+aLH)+.5)   && //pMon right arrow button
            pos.y > (tH/10)*(arY-.5)  && pos.y < (tH/10)*((arY+aLH)+.5)){
            Player.btnDo('mra');
        }
        if (pos.x >= (tL/10)*(malX-.5)  && pos.x <= (tL/10)*((malX+aLH)+.5)  && //pMon left arrow button
            pos.y > (tH/10)*(arY-.5)  && pos.y < (tH/10)*((arY+aLH)+.5)){
            Player.btnDo('mla')
        }
        if (pos.x >= (tL/10)*hX   && pos.x <= (tL/10)*(hX+cL)  && //pHand menu visible 1
              pos.y > (tH/10)*cY && pos.y < (tH/10)*(cY+cH) ){
            Player.btnDo('hm');
          }
        if (pos.x >= (tL/10)*harX && pos.x <= (tL/10)*(harX+aLH)   && //pHand right arrow button
            pos.y > (tH/10)*arY  && pos.y < (tH/10)*(arY+aLH)){
              if (Player.aMonster.length == 1){
              Player.btnDo('hra');}
          }
        if (pos.x >= (tL/10)*halX  && pos.x <= (tL/10)*(halX+aLH)   && //pHand left arrow button
            pos.y > (tH/10)*arY  && pos.y < (tH/10)*(arY+aLH)){
            Player.btnDo('hla');
        }
        /*
        //Foe buttons
        if (Foe.option < 5){
          if (pos.x >= (tL/10)*4    && pos.x <= (tL/10)*6.25  && //fMonster menu visible f1
              pos.y > (tH/10)*0  && pos.y < (tH/10)*3.5 && Foe.aMonster.length >0){//foe monster
            Player.option =0;
            Foe.option = 3;
          }
          if (pos.x >= (tL/10)*6.8  && pos.x <= (tL/10)*9.1   && //fHand menu visible f3
              pos.y > (tH/10)*0 && pos.y < (tH/10)*3.5 && Foe.hand.length > 0){
            Player.option = 0;
            Foe.option = 1;
          }
        }*/
        break;
      case 4://Player Monster Examine
        if(pos.x >= (tL/10)*7 && pos.x <= (tL/10)*9  && //examine right arrow button
           pos.y > (tH/10)*4  && pos.y < (tH/10)*6){
          Player.btnDo('mra')
        }
        if(pos.x >= (tL/10)*1 && pos.x <= (tL/10)*3  && //examine left arrow button
           pos.y > (tH/10)*4  && pos.y < (tH/10)*6){
          Player.btnDo('mla')
        }
        if(pos.x >= (tL/10)*8.25 && pos.x <= (tL/10)*9.1 &&//exit from monster zoom
           pos.y > (tH/10)*0.5  && pos.y < (tH/10)*1.5){
          Player.btnDo('mec')
        }
        break;
      case 5://Player ready state
        if(pos.x >= (tL/10)*1.7 && pos.x <= (tL/10)*2.5  &&//clicking the x cancels the ready state and sets A to -1
           pos.y > (tH/10)*5  && pos.y < (tH/10)*6){
          Player.btnDo('rex')
        }
        break;
      }//end switch
  }//end player clicking
  //Player battle and after battle clicks
  if (Player.option >= 6){
    switch(Player.option){
      case 6:
        if (Player.at == 31&&Foe.at == 31 && Foe.option != 6.1){
          Player.at = 36;
          Foe.at = 36;
          
        }
        break;
      case 6.3://Alchemy
        if (Player.hasScalesOfJustice == 2){
          if (pos.x >= (tL/10)*7 && pos.x <= (tL/10)*8  &&//AGI
            pos.y > (tH/10)*8.5  && pos.y < (tH/10)*9.5){
              Player.look[eLOOK.STAT] = eSTAT.A;
              Player.hasScalesOfJustice = 3;
            return;
            }
          if (pos.x >= (tL/10)*2 && pos.x <= (tL/10)*3  &&//INT
            pos.y > (tH/10)*8.5  && pos.y < (tH/10)*9.5){
              Player.look[eLOOK.STAT] = eSTAT.I;
              Player.hasScalesOfJustice = 3;
            return;
            }
          if (pos.x >= (tL/10)*7 && pos.x <= (tL/10)*8  &&//CON
            pos.y > (tH/10)*6  && pos.y < (tH/10)*7){
              Player.look[eLOOK.STAT] = eSTAT.C;
              Player.hasScalesOfJustice = 3;
            return;
            }
          if (pos.x >= (tL/10)*2 && pos.x <= (tL/10)*3  &&//STR
            pos.y > (tH/10)*6  && pos.y < (tH/10)*7){
              Player.look[eLOOK.STAT] = eSTAT.S;
              Player.hasScalesOfJustice = 3;
              return;
            }
            
        }
        if (Player.hasScalesOfJustice == 3){
          if (pos.x >(tL/10)*2 && pos.x <(tL/10)*3  &&//AGI
            pos.y > (tH/10)*.5  && pos.y < (tH/10)*1.5){
              Foe.look[eLOOK.STAT] = eSTAT.A;
              Player.hasScalesOfJustice = 4;
            Player.option = Player.preOpt
            }
          if (pos.x >(tL/10)*7 && pos.x <(tL/10)*8  &&//INT
            pos.y > (tH/10)*.5  && pos.y < (tH/10)*1.5){
              Foe.look[eLOOK.STAT] = eSTAT.I;
              Player.hasScalesOfJustice = 4;
            Player.option = Player.preOpt
            }
          if (pos.x >= (tL/10)*2 && pos.x <= (tL/10)*3  &&//CON
            pos.y > (tH/10)*3  && pos.y < (tH/10)*4){
              Foe.look[eLOOK.STAT] = eSTAT.C;
              Player.hasScalesOfJustice = 4;
            Player.option = Player.preOpt
            }
          if (pos.x >= (tL/10)*7 && pos.x <= (tL/10)*8  &&//STR
            pos.y > (tH/10)*3  && pos.y < (tH/10)*4){
              Foe.look[eLOOK.STAT] = eSTAT.S;
              Player.hasScalesOfJustice = 4;
            Player.option = Player.preOpt
            }
            
        }
        break;
      case 6.2://Winged Boots
        if (Player.at == 0){
          if (pos.x >= (tL/10)*1 && pos.x <= (tL/10)*4.5  &&//yes
              pos.y > (tH/10)*5  && pos.y < (tH/10)*7){
              Player.defStat = 3
    
              if (Player.hasWingedBoots == 1){
                for (let i = 0; i < Player.aMonster.length; i++){
                  if (Player.aMonster[i].index == 7 && Player.aMonster[i].effectTriggered == 0){
                    Player.aMonster[i].effectTriggered = 1;
                    Player.option = Player.preOpt;
                  }
                }
              }
              //player.stat = agi
          }
          if (pos.x >= (tL/10)*6 && pos.x <= (tL/10)*9 &&//no
              pos.y > (tH/10)*5  && pos.y < (tH/10)*7){
              Player.defStat = 1;
             
              //if previous = defend 1 or 2
              if (Player.hasWingedBoots == 1){
                for (let i = 0; i < Player.aMonster.length; i++){
                  if (Player.aMonster[i].index == 7 && Player.aMonster[i].effectTriggered == 0){
                    Player.aMonster[i].effectTriggered = 1;
                    Player.option = Player.preOpt;
                    
                  }
                }
              }
              
          }          
        }
        break;
      case 6.1://Star Pendant   
        if (pos.x > (tL/10)*1 && pos.x < (tL/10)*4.5  &&//yes
            pos.y > (tH/10)*5 && pos.y < (tH/10)*8){
          for (let i = 0; i < Player.aMonster.length; i++){
            if (Player.aMonster[i].index == 17 && Player.aMonster[i].effectTriggered == 0){
              Player.ax = 0;
              Player.ay = 0;
              Player.az = 0;
              Player.at = 0
              Player.aMonster[i].effectTriggered = 1;
              Player.option = Player.preOpt;
              Player.hasReroll = 1;
            }
          }
        }
        if (pos.x >= (tL/10)*6 && pos.x <= (tL/10)*9 &&//no
            pos.y > (tH/10)*5  && pos.y < (tH/10)*8){
              //if previous = defend 1 or 2
          for (let i = 0; i < Player.aMonster.length; i++){
            if (Player.aMonster[i].index == 17 && Player.aMonster[i].effectTriggered == 0){
              Player.aMonster[i].effectTriggered = 1;
              Player.option = Player.preOpt;  
            }
          }
        }
      break; 
      case 7://1st defend
        if (Player.at == 31&&Foe.at == 31&&Foe.option != 6.1 && Foe.option != 6.2&& Foe.option != 6.3){
          Player.at = 36;
          Foe.at = 36;
        }
        if (Player.at == 101){
          Player.at = 106;
         }
         if (Foe.at == 101){
          Foe.at = 106;
         }
        break;
      case 8://1st atk
        //treasure chest
        if (pos.x > (tL/10)*1.5 && pos.x <= (tL/10)*3.88  &&//yes
          pos.y > (tH/10)*5.5  && pos.y < (tH/10)*10){
            if (Player.hasTreasureChest == 1){Player.hasTreasureChest = 2}
        }
        if (pos.x > (tL/10)*6 && pos.x <= (tL/10)*8.25 &&//no
            pos.y > (tH/10)*5.5  && pos.y < (tH/10)*10){
            if (Player.hasTreasureChest == 1){Player.hasTreasureChest = 3}
        }
        //Click to Continue item or spell
        if (Player.at == 101){
          Player.at = 106
        }
        //Continue
        if (Player.at == 31&&Foe.at == 31&& Foe.option != 6.1 && Foe.option != 6.2 && Foe.option != 6.3){
          Player.at = 36;
          Foe.at = 36;
        }
        
      break;
      case 9:
        let noneOnTable = 0;
        if (sRune.owner != 2){noneOnTable = noneOnTable+ 1};
        if (cRune.owner != 2){noneOnTable = noneOnTable+ 1};
        if (iRune.owner != 2){noneOnTable = noneOnTable+ 1};
        if (aRune.owner != 2){noneOnTable = noneOnTable+ 1};
        //str rune
        if(pos.x >= (tL/10)*1.5 && pos.x <= (tL/10)*2.6  &&//take STR rune from table
           pos.y > (tH/10)*4.5  && pos.y < (tH/10)*5.5 && sRune.owner == 2){
          Player.at = 1;
          Player.look[eLOOK.S] = eSTAT.S;
          startGame = 4;
          MusicEngine.playSFX('heal');
        }
        else if(pos.x >= (tL/10)*5.9 && pos.x <= (tL/10)*6.9  &&//take STR rune from foe
                pos.y > (tH/10)*2.5  && pos.y < (tH/10)*3.5 && sRune.owner == 1&& noneOnTable == 4){
          Player.at = 1;
          Player.look[eLOOK.S] = eSTAT.S;
          startGame = 4;
          MusicEngine.playSFX('heal');
        }
        //con rune
        else if(pos.x >= (tL/10)*7.5 && pos.x <= (tL/10)*8.6  &&//take CON rune from table
                pos.y > (tH/10)*4.5  && pos.y < (tH/10)*5.5 && cRune.owner == 2){
          Player.at = 1;
          Player.look[eLOOK.S] = eSTAT.C;
          startGame = 4;
          MusicEngine.playSFX('heal');
        }
        else if(pos.x >= (tL/10)*3 && pos.x <= (tL/10)*4  &&//take CON rune from foe
                pos.y > (tH/10)*2.5  && pos.y < (tH/10)*3.5 && cRune.owner == 1&& noneOnTable == 4){
          Player.at = 1;
          Player.look[eLOOK.S] = eSTAT.C;
          startGame = 4;
          MusicEngine.playSFX('heal');
        }
        //int rune
        else if(pos.x >= (tL/10)*3.5 && pos.x <= (tL/10)*4.6  &&//take int rune from table
                pos.y > (tH/10)*4.5  && pos.y < (tH/10)*5.5 && iRune.owner == 2){
          Player.at = 1;
          Player.look[eLOOK.S] = eSTAT.I;
          startGame = 4;
          MusicEngine.playSFX('heal');
        }
        else if(pos.x >= (tL/10)*5.9 && pos.x <= (tL/10)*6.9  &&//take int rune from foe
                pos.y > (tH/10)*0  && pos.y < (tH/10)*1 && iRune.owner == 1&& noneOnTable == 4){
          Player.at = 1;
          Player.look[eLOOK.S] = eSTAT.I;
          startGame = 4;
          MusicEngine.playSFX('heal');
        }
        //agi rune
        else if(pos.x >= (tL/10)*5.5 && pos.x <= (tL/10)*6.6  &&//take agi rune from table
                pos.y > (tH/10)*4.5  && pos.y < (tH/10)*5.5 && aRune.owner == 2){
          Player.at = 1;
          Player.look[eLOOK.S] = eSTAT.A;
          startGame = 4;
          MusicEngine.playSFX('heal');
        }
        else if(pos.x >= (tL/10)*3 && pos.x <= (tL/10)*4  &&//take agi rune from foe
                pos.y > (tH/10)*0  && pos.y < (tH/10)*1 && aRune.owner == 1&& noneOnTable == 4){
          Player.at = 1;
          Player.look[eLOOK.S] = eSTAT.A;
          startGame = 4;
          MusicEngine.playSFX('heal');
        }
        break;
    }
  }
  
  //Foe clicks
  //if cpu only allow examine field
  if (Foe.isCPU == 1){//CPU
    switch(Foe.option){
      case 0:
        if (pos.x >= (tL/10)*(10-marX-aLH) && pos.x <= (tL/10)*(10-marX)   && //fMon right arrow button
            pos.y > (tH/10)*(10-arY-cH)  && pos.y < (tH/10)*(10-arY)){
            Foe.btnDo('mra');
        }
        if (pos.x >= (tL/10)*(10-malX-aLH)  && pos.x <= (tL/10)*(10-aLH)  && //fMon left arrow button
            pos.y > (tH/10)*(10-arY-aLH)  && pos.y < (tH/10)*(10-arY)){
            Foe.btnDo('mla')
        }
        if (pos.x >= (tL/10)* (10-mX-cL)   && pos.x <= (tL/10)*(10-mX)  && //fMonster menu visible 3
            pos.y > (tH/10)*(10-cY-cH)  && pos.y < (tH/10)*(10-cY)){
            Foe.btnDo('mmo')
        } 
        break;
      case 3:
      if (pos.x <= (tL/10)*(10-mX-cL)    || pos.x >= (tL/10)*(10-mX)  || //fMonster menu close p0
          pos.y < (tH/10)*(10-cY-cH)  || pos.y > (tH/10)*(10-cY)){
          Foe.btnDo('mc')
        }
        if (pos.x >= (tL/10)*(10-meX-actLH)    && pos.x <= (tL/10)*(10-meX)  && //fMonster examine click p4
            pos.y > (tH/10)*(10-actY-actLH)   && pos.y < (tH/10)*(10-actY)){
            Foe.btnDo('me')
        }
        if (pos.x >= (tL/10)*(10-marX-aLH) && pos.x <= (tL/10)*(10-marX)   && //fMon right arrow button
            pos.y > (tH/10)*(10-arY-aLH)  && pos.y < (tH/10)*(10-arY)){
            Foe.btnDo('mra');
        }
        if (pos.x >= (tL/10)*(10-malX-aLH)  && pos.x <= (tL/10)*(10-aLH)  && //fMon left arrow button
            pos.y > (tH/10)*(10-arY-aLH)  && pos.y < (tH/10)*(10-arY)){
            Foe.btnDo('mla')
        }
    break;
      case 4:
        if (pos.x >= (tL/10)*7 && pos.x <= (tL/10)*9  && //examine right arrow button
            pos.y > (tH/10)*4  && pos.y < (tH/10)*6){
            Foe.btnDo('mra')
        }
        if (pos.x >= (tL/10)*1 && pos.x <= (tL/10)*3  && //examine left arrow button
            pos.y > (tH/10)*4  && pos.y < (tH/10)*6){
            Foe.btnDo('mla')
        }
        if (pos.x >= (tL/10)*8.25 && pos.x <= (tL/10)*9.1 &&//exit from monster zoom
            pos.y > (tH/10)*0.5  && pos.y < (tH/10)*1.5){
            Foe.btnDo('mec')
        }
    }
  }
  
  if(Foe.isCPU === 0){//HUMAN
    //FOE NON BATTLE CLICKS
    if (Player.option != 2 && Player.option != 4 && Player.option < 6 && Player.draw == 0 && Foe.draw == 0) {
      switch(Foe.option){//FOE SIDE CLICKING
        case 0://Initiate Click Menus and Buttons
        if (pos.x >= (tL/10)*(10-hX-cL)   && pos.x <= (tL/10)*(10-hX)  && //fHand menu visible 1
            pos.y > (tH/10)*(10-cY-cH) && pos.y < (tH/10)*(10-cY) ){
            Foe.btnDo('hm');
        }
        if (pos.x >= (tL/10)*(10-harX-aLH) && pos.x <= (tL/10)*(10-harX)   && //fHand right arrow button
            pos.y > (tH/10)*(10-arY-aLH)  && pos.y < (tH/10)*(10-arY)){
            Foe.btnDo('hra');
            return;
        }
        if (pos.x >= (tL/10)*(10-halX-aLH)  && pos.x <= (tL/10)*(10-halX)   && //fHand left arrow button
            pos.y > (tH/10)*(10-arY-aLH)  && pos.y < (tH/10)*(10-arY)){
            Foe.btnDo('hla');
            return;
        }
        if (pos.x >= (tL/10)*(10-marX-aLH) && pos.x <= (tL/10)*(10-marX)   && //fMon right arrow button
            pos.y > (tH/10)*(10-arY-cH)  && pos.y < (tH/10)*(10-arY)){
            Foe.btnDo('mra');
        }
        if (pos.x >= (tL/10)*(10-malX-aLH)  && pos.x <= (tL/10)*(10-aLH)  && //fMon left arrow button
            pos.y > (tH/10)*(10-arY-aLH)  && pos.y < (tH/10)*(10-arY)){
            Foe.btnDo('mla')
        }
        if (pos.x >= (tL/10)* (10-mX-cL)   && pos.x <= (tL/10)*(10-mX)  && //fMonster menu visible 3
            pos.y > (tH/10)*(10-cY-cH)  && pos.y < (tH/10)*(10-cY)){
            Foe.btnDo('mmo')
        } 
        break;
        case 1://Foe Hand Menu Visible
        //non redundant buttons
        if (pos.x <= (tL/10)*(10-hX-cL)    || pos.x >= (tL/10)*(10-hX) || //pHand menu close 0
            pos.y < (tH/10)*(10-cY-cH) || pos.y > (tH/10)*(10-cY)){
            Foe.btnDo('mc')
        }
        if (pos.x >= (tL/10)*(10-heX-actLH)  && pos.x <= (tL/10)*(10-heX) && //pHand examine 2
            pos.y > (tH/10)*(10-actY-actLH)  && pos.y < (tH/10)*(10-actY)){
            Foe.btnDo('hex')
        }
        if (pos.x >= (tL/10)*(10-huX-actLH) && pos.x <= (tL/10)*(10-huX) && //pHand use 5
            pos.y > (tH/10)*(10-actY-actLH)  && pos.y < (tH/10)*(10-actY)){
            Foe.btnDo('use')
        }
        //redundant
        if (pos.x >= (tL/10)*(10-harX-aLH) && pos.x <= (tL/10)*(10-harX)   && //fHand right arrow button
            pos.y > (tH/10)*(10-arY-aLH)  && pos.y < (tH/10)*(10-arY)){
            Foe.btnDo('hra');
            return;
        }
        if (pos.x >= (tL/10)*(10-halX-aLH)  && pos.x <= (tL/10)*(10-halX)   && //fHand left arrow button
            pos.y > (tH/10)*(10-arY-aLH)  && pos.y < (tH/10)*(10-arY)){
            Foe.btnDo('hla');
            return;
        }
        if (pos.x >= (tL/10)*(10-marX-aLH) && pos.x <= (tL/10)*(10-marX)   && //fMon right arrow button
            pos.y > (tH/10)*(10-arY-aLH)  && pos.y < (tH/10)*(10-arY)){
            Foe.btnDo('mra');
        }
        if (pos.x >= (tL/10)*(10-malX-aLH)  && pos.x <= (tL/10)*(10-aLH)  && //fMon left arrow button
            pos.y > (tH/10)*(10-arY-aLH)  && pos.y < (tH/10)*(10-arY)){
            Foe.btnDo('mla')
        }
        if (pos.x >= (tL/10)* (10-mX-cL)   && pos.x <= (tL/10)*(10-mX)  && //fMonster menu visible 3
            pos.y > (tH/10)*(10-cY-cH)  && pos.y < (tH/10)*(10-cY)){
            Foe.btnDo('mmo')
        } 
          /*
        //PLAYER
        if (Player.option < 5){
          if (pos.x >= (tL/10)*1      && pos.x <= (tL/10)*3.25  && //pHand menu visible 1
              pos.y > (tH/10)*6.5 && pos.y < (tH/10)*10){
            Foe.btnDo('mmo')
          }
          if (pos.x >= (tL/10)*4      && pos.x <= (tL/10)*6.25  && //pmonster menu visible 3
              pos.y >  (tH/10)*6.5    && pos.y <  (tH/10)*10){
            Player.option =3;
            Foe.option = 0;
          }
          if (pos.x >= (tL/10)*2.9    && pos.x <= (tL/10)*3.5   && //pHandright arrow button
              pos.y > (tH/10)*7.9  && pos.y < (tH/10)*8.4){
            if (Player.look[eLOOK.H] + 1 > Player.hand.length-1){
              Player.look[eLOOK.H] = 0;
            }
            else{
              Player.look[eLOOK.H] = Player.look[eLOOK.H] + 1;
            }
            Player.option = 1;
            Foe.option = 0;
           }
          if (pos.x >= (tL/10)*.7     && pos.x <= (tL/10)*1.3   && //pHandleft arrow button
              pos.y > (tH/10)*7.9  && pos.y < (tH/10)*8.4){
            if (Player.look[eLOOK.H] - 1 < 0){
                Player.look[eLOOK.H] = Player.hand.length-1
              }
              else{
                Player.look[eLOOK.H] = Player.look[eLOOK.H]-1
              }
            Player.option = 1;//keep menu open while clicking arrows
            Foe.option = 0;
          }
        }*/
        break;
        case 2://Foe Hand Examine
        if (pos.x >= (tL/10)*7  && pos.x <= (tL/10)*9  && //examine right arrow button
            pos.y > (tH/10)*4  && pos.y < (tH/10)*6){
            Foe.btnDo('hra')
        }
        if (pos.x >= (tL/10)*1  && pos.x <= (tL/10)*3  && //examine left arrow button
            pos.y > (tH/10)*4  && pos.y < (tH/10)*6){
            Foe.btnDo('hla')
        }
        if (pos.x >= (tL/10)*8.25 && pos.x <= (tL/10)*9.1 && //exit from hand zoom
            pos.y > (tH/10)*0.5  && pos.y < (tH/10)*1.5){
            Foe.btnDo('hec')
        }
        break;
        case 3://Foe Monster Menu
          //non redundant buttons
          if (pos.x <= (tL/10)*(10-mX-cL)    || pos.x >= (tL/10)*(10-mX)  || //fMonster menu close p0
              pos.y < (tH/10)*(10-cY-cH)  || pos.y > (tH/10)*(10-cY)){
              Foe.btnDo('mc')
          }
          if (pos.x >= (tL/10)*(10-meX-actLH)    && pos.x <= (tL/10)*(10-meX)  && //fMonster examine click p4
              pos.y > (tH/10)*(10-actY-actLH)   && pos.y < (tH/10)*(10-actY)){
              Foe.btnDo('me')
          }
          if (pos.x >= (tL/10)*(10-maX-actLH)    && pos.x <= (tL/10)*(10-maX)  && //fMonster attack click p6
              pos.y > (tH/10)*(10-actY-actLH)   && pos.y < (tH/10)*(10-actY)){
              Foe.btnDo('atk')
          }
        
          //redundant buttons
          if (pos.x >= (tL/10)*(10-hX-cL)   && pos.x <= (tL/10)*(10-hX)  && //fHand menu visible 1
              pos.y > (tH/10)*(10-cY-cH) && pos.y < (tH/10)*(10-cY) ){
              Foe.btnDo('hm');
          }
          if (pos.x >= (tL/10)*(10-harX-aLH) && pos.x <= (tL/10)*(10-harX)   && //fHand right arrow button
              pos.y > (tH/10)*(10-arY-aLH)  && pos.y < (tH/10)*(10-arY)){
              Foe.btnDo('hra');
              return;
          }
          if (pos.x >= (tL/10)*(10-halX-actLH)  && pos.x <= (tL/10)*(10-halX)   && //fHand left arrow button
              pos.y > (tH/10)*(10-arY-aLH)  && pos.y < (tH/10)*(10-arY)){
              Foe.btnDo('hla');
              return;
          }
          if (pos.x >= (tL/10)*(10-marX-aLH) && pos.x <= (tL/10)*(10-marX)   && //fMon right arrow button
              pos.y > (tH/10)*(10-arY-aLH)  && pos.y < (tH/10)*(10-arY)){
              Foe.btnDo('mra');
          }
          if (pos.x >= (tL/10)*(10-malX-aLH)  && pos.x <= (tL/10)*(10-aLH)  && //fMon left arrow button
              pos.y > (tH/10)*(10-arY-aLH)  && pos.y < (tH/10)*(10-arY)){
              Foe.btnDo('mla')
          }
        break;
        case 4://Foe Monster Examine
          if(pos.x >= (tL/10)*7 && pos.x <= (tL/10)*9  && //m examine right arrow button
            pos.y > (tH/10)*4  && pos.y > (tH/10)*4){
              Foe.btnDo('mra')
          }
          if(pos.x >= (tL/10)*1 && pos.x <= (tL/10)*3  && //m examine left arrow button
            pos.y > (tH/10)*4  && pos.y < (tH/10)*6){
              Foe.btnDo('mla')
          }
          if(pos.x >= (tL/10)*8.25 && pos.x <= (tL/10)*9.1 &&//exit from monster zoom
            pos.y > (tH/10)*0.5  && pos.y < (tH/10)*1.5){
              Foe.btnDo('mec')
          }
        break;
        case 5://Foe ready state active
          if (pos.x >= (tL/10)*7.5 && pos.x <= (tL/10)*8.5  && //exit ready
              pos.y > (tH/10)*4  && pos.y < (tH/10)*5){
             Foe.btnDo('rex')
          }
        break
      }//end switch
    }//end foe clicking
    //FOE BATTLE and POST BATTLE CLICKS 
    if (Foe.option >= 6){
      switch(Foe.option){
        case 6:
          
          break;
        case 6.3://Alchemy
          if (Foe.hasScalesOfJustice == 2){
            if (pos.x >(tL/10)*2 && pos.x <(tL/10)*3  &&//AGI
              pos.y > (tH/10)*.5  && pos.y < (tH/10)*1.5){
                Foe.look[eLOOK.STAT] = eSTAT.A;
                Foe.hasScalesOfJustice = 3;
              return;
              }
            if (pos.x >(tL/10)*7 && pos.x <(tL/10)*8  &&//INT
              pos.y > (tH/10)*.5  && pos.y < (tH/10)*1.5){
                Foe.look[eLOOK.STAT] = eSTAT.I;
                Foe.hasScalesOfJustice = 3;
              return;
              }
            if (pos.x >= (tL/10)*2 && pos.x <= (tL/10)*3  &&//CON
              pos.y > (tH/10)*3  && pos.y < (tH/10)*4){
                Foe.look[eLOOK.STAT] = eSTAT.C;
                Foe.hasScalesOfJustice = 3;
              return;
              }
            if (pos.x >= (tL/10)*7 && pos.x <= (tL/10)*8  &&//STR
              pos.y > (tH/10)*3  && pos.y < (tH/10)*4){
                Foe.look[eLOOK.STAT] = eSTAT.S;
                Foe.hasScalesOfJustice = 3;
                return;
              }
              
          }
          if (Foe.hasScalesOfJustice == 3){
            if (pos.x >= (tL/10)*7 && pos.x <= (tL/10)*8  &&//AGI
              pos.y > (tH/10)*8.5  && pos.y < (tH/10)*9.5){
                Player.look[eLOOK.STAT] = eSTAT.A;
                Foe.hasScalesOfJustice = 4;
              Foe.option = Foe.preOpt
              }
            if (pos.x >= (tL/10)*2 && pos.x <= (tL/10)*3  &&//INT
              pos.y > (tH/10)*8.5  && pos.y < (tH/10)*9.5){
                Player.look[eLOOK.STAT] = eSTAT.I;
                Foe.hasScalesOfJustice = 4;
              Foe.option = Foe.preOpt
              }
            if (pos.x >= (tL/10)*7 && pos.x <= (tL/10)*8  &&//CON
              pos.y > (tH/10)*6  && pos.y < (tH/10)*7){
                Player.look[eLOOK.STAT] = eSTAT.C;
                Foe.hasScalesOfJustice = 4;
              Foe.option = Foe.preOpt
              }
            if (pos.x >= (tL/10)*2 && pos.x <= (tL/10)*3  &&//STR
              pos.y > (tH/10)*6  && pos.y < (tH/10)*7){
                Player.look[eLOOK.STAT] = eSTAT.S;
                Foe.hasScalesOfJustice = 4;
              Foe.option = Foe.preOpt
              }
              
          }
        break;
        case 6.2://Winged Boots
          if (Foe.at == 0){
            if (pos.x < (tL/10)*7 && pos.x > (tL/10)*6 &&//yes
                pos.y < (tH/10)*3.5  && pos.y > (tH/10)*2.5){
                Foe.defStat = 3
      
                if (Foe.hasWingedBoots == 1){
                  for (let i = 0; i < Foe.aMonster.length; i++){
                    if (Foe.aMonster[i].index == 7 && Foe.aMonster[i].effectTriggered == 0){
                      Foe.aMonster[i].effectTriggered = 1;
                      Foe.option = Foe.preOpt;
                    }
                  }
                }
                //player.stat = agi
            }
            if (pos.x < (tL/10)*4 && pos.x >= (tL/10)*3 &&//no
                pos.y < (tH/10)*3.5  && pos.y > (tH/10)*2.5){
                Foe.defStat = 1;
              
                //if previous = defend 1 or 2
                if (Foe.hasWingedBoots == 1){
                  for (let i = 0; i < Foe.aMonster.length; i++){
                    if (Foe.aMonster[i].index == 7 && Foe.aMonster[i].effectTriggered == 0){
                      Foe.aMonster[i].effectTriggered = 1;
                      Foe.option = Foe.preOpt;
                      
                    }
                  }
                }
                
            }
            
          }
          break;
        case 6.1://Star Pendant
          if (pos.x > (tL/10)*6 && pos.x < (tL/10)*7.5  &&//yes
              pos.y > (tH/10)*3 && pos.y < (tH/10)*4.5){
            for (let i = 0; i < Foe.aMonster.length; i++){
              if (Foe.aMonster[i].index == 17 && Foe.aMonster[i].effectTriggered == 0){
                Foe.ax = 0;
                Foe.ay = 0;
                Foe.az = 0;
                Foe.at = 0
                Foe.aMonster[i].effectTriggered = 1;
                Foe.option = Foe.preOpt;
              }
            }
          
            }
          if (pos.x > (tL/10)*2.5 && pos.x < (tL/10)*4  &&//no
              pos.y > (tH/10)*3 && pos.y < (tH/10)*4.5){
              //if previous = defend 1 or 2
                for (let i = 0; i < Foe.aMonster.length; i++){
                  if (Foe.aMonster[i].index == 17 && Foe.aMonster[i].effectTriggered == 0){
                    Foe.aMonster[i].effectTriggered = 1;
                    Foe.option = Foe.preOpt;
                  }
                }
          }
        break;
        case 7://1st defend
        
          break;
        case 8://1st atk//treasure chest/click to continue
          //treasure chest
          if (pos.x < (tL/10)*8 && pos.x > (tL/10)*7  &&//yes
              pos.y < (tH/10)*4.5  && pos.y > (tH/10)*3.5){
                if (Foe.hasTreasureChest == 1){Foe.hasTreasureChest = 2}
              }

          if (pos.x < (tL/10)*3.5 && pos.x > (tL/10)*2.5  &&//no
              pos.y < (tH/10)*4.5  && pos.y > (tH/10)*3.5){
              if (Foe.hasTreasureChest == 1){Foe.hasTreasureChest = 3}
            }
            
          
        break;
        case 9://triumph foe takes stones
          let noneOnTable = 0;
          if (sRune.owner != 2){noneOnTable = noneOnTable+ 1};
          if (cRune.owner != 2){noneOnTable = noneOnTable+ 1};
          if (iRune.owner != 2){noneOnTable = noneOnTable+ 1};
          if (aRune.owner != 2){noneOnTable = noneOnTable+ 1};
          
          //str rune
          if (pos.x >= (tL/10)*1.5 && pos.x <= (tL/10)*2.6  &&//take STR rune from table
              pos.y > (tH/10)*4.5  && pos.y < (tH/10)*5.5 && sRune.owner == 2 ){
            Foe.at = 1;
            Foe.look[eLOOK.S] = eSTAT.S;
            startGame = 4;
          }
          else if(pos.x >= (tL/10)*3.4 && pos.x <= (tL/10)*4.4  &&//take STR rune from player
                  pos.y > (tH/10)*6.5  && pos.y < (tH/10)*7.5 && sRune.owner == 0 && noneOnTable == 4){
            Foe.at = 1;
            Foe.look[eLOOK.S] = eSTAT.S;
            startGame = 3;
          }
          //con rune
          else if(pos.x >= (tL/10)*7.5 && pos.x <= (tL/10)*8.5  &&//take con rune from table
                  pos.y > (tH/10)*4.5  && pos.y < (tH/10)*5.5 && cRune.owner == 2){
            Foe.at = 1;
            Foe.look[eLOOK.S] = eSTAT.C;
            startGame = 4;
          }
          else if(pos.x >= (tL/10)*6 && pos.x <= (tL/10)*7  &&//take con rune from player
                  pos.y > (tH/10)*6.5  && pos.y < (tH/10)*7.5 && cRune.owner == 0&& noneOnTable == 4){
            Foe.at = 1;
            Foe.look[eLOOK.S] = eSTAT.C;
            startGame = 4;
          }
          //int rune
          else if(pos.x >= (tL/10)*3.4 && pos.x <= (tL/10)*4.4  &&//take int rune from table
                  pos.y > (tH/10)*4.5  && pos.y < (tH/10)*5.5 && iRune.owner == 2){
            Foe.at = 1;
            Foe.look[eLOOK.S] = eSTAT.I;
            startGame = 4;
          }
          else if(pos.x >= (tL/10)*3.5 && pos.x <= (tL/10)*4.5  &&//take int rune from player
                  pos.y > (tH/10)*9  && pos.y < (tH/10)*10 && iRune.owner == 0&& noneOnTable == 4){
            Foe.at = 1;
            Foe.look[eLOOK.S] = eSTAT.I;
            startGame = 4;
          }
          //agi rune
          else if(pos.x >= (tL/10)*5.5 && pos.x <= (tL/10)*6.5  &&//take agi rune from table
                  pos.y > (tH/10)*4.5  && pos.y < (tH/10)*5.5 && aRune.owner == 2){
            Foe.at = 1;
              Foe.look[eLOOK.S] = eSTAT.A;
              startGame = 4;
            }
          else if(pos.x >= (tL/10)*6 && pos.x <= (tL/10)*7  &&//take agi rune from player
                  pos.y > (tH/10)*9  && pos.y < (tH/10)*10 && aRune.owner == 0 && noneOnTable == 4){
            Foe.at = 1;
            Foe.look[eLOOK.S] = eSTAT.A;
            startGame = 4;
          }
        break;
      }
    }
  }

}
window.addEventListener('pointerdown', handleInput, { passive: false });
//////////////////////////[FUNCTIONS]/////////////////////////////
//////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////
function random(max){
	return Math.floor(Math.random()*Math.floor(max));
}
function rnd(min, max){
	min = Math.ceil(min);
	max = Math.floor(max);
	return Math.floor(Math.random() * (max - min + 1)+ min);
}
function resizeCanvas(){  //USED IN EVENT LISTENER TO GET NEW WINDOW X,Y(tX,tY)
	//after event handler detects window resize, sets canvas x,y to window x,y
	// 1. Get the scaling factor (2 or 3 for iPhones)
    var dpr = window.devicePixelRatio || 1;

    wX = window.innerWidth;
    wY = window.innerHeight;

    // 2. Set actual canvas memory size to scaled value
    canvas.width = wX * dpr;
    canvas.height = wY * dpr;

    // 3. Force the CSS size to match the window
    canvas.style.width = wX + "px";
    canvas.style.height = wY + "px";

    // 4. Normalize the coordinate system
    ctx.scale(dpr, dpr);

	//canvas redimensioned, so re-set values for playing table width and length
	tX = wX; //table length (actual x determined after funtion)
	tY = wY; //table height (actual y determined after function)

	//find largest dimension for tX and tY that is divisible by 2 without remainder
	for(let i = 0; tX%2 > 0; i++){
	  tX = tX - 1;
	}
	for(let i = 0; tY%2 > 0; i++){
	  tY = tY - 1;
  }
	//make sure table dimensions have ratio of 1:1 for x and y respectively
	//if table too wide make shorter
	if (tX > tY){
		tX = tY;
	}
	//if table too high make shorter
	else if(tY > tX){
		tY = tX;
	}

	//find difference between window dimensions and ratio'd table dims for padding
	var dX = wX - tX;
	var dY = wY - tY;
	tL = tX;
	tH = tY;

	//find table top-left(0,0) with table centered and equal padding on all sides
	tX = dX/2;
	tY = dY/2;

	//set x,y, width, height,length for all frames[to do]

	}
function drawShape(shape,x,y,z,x1,y1,x2,y2,x3,y3,x4,y4,color,fill,x5 = 0,y5 = 0){
	//frame
	let lx1 = 0;
	let ly1 = 0;
	let lx2 = 0;
	let ly2 = 0;
	let lx3 = 0;
	let ly3 = 0;
	let lx4 = 0;
	let ly4 = 0;
  let lx5 = 0;
	let ly5 = 0;
	let lDiv = (tL/10)*z;
	let hDiv = (tH/10)*z;
	x = tX + (tL/10) * x;
	y = tY + (tH/10) * y;
	//draw shape
	switch(shape){
    case 'pol':
			lx1 = x + (lDiv * x1);//x coord 1
			ly1 = y + (hDiv * y1);//y coord 1
			lx2 = x + (lDiv * x2);//x coord 2
			ly2 = y + (hDiv * y2);//y coord 2
			lx3 = x + (lDiv * x3);//x coord 3
			ly3 = y + (hDiv * y3);//y coord 3
			lx4 = x + (lDiv * x4);//x coord 4
			ly4 = y + (hDiv * y4);//y coord 4
      lx5 = x + (lDiv * x5);//x coord 4
			ly5 = y + (hDiv * y5);//y coord 4
			ctx.fillStyle = color;
			ctx.strokeStyle = color;
			ctx.beginPath();
			ctx.moveTo(lx1, ly1);
			ctx.lineTo(lx2, ly2);
			ctx.lineTo(lx3, ly3);
			ctx.lineTo(lx4, ly4);
      ctx.lineTo(lx5, ly5);
			ctx.lineTo(lx1, ly1);
			ctx.closePath();
			break;
		case 'qua':
			lx1 = x + (lDiv * x1);//x coord 1
			ly1 = y + (hDiv * y1);//y coord 1
			lx2 = x + (lDiv * x2);//x coord 2
			ly2 = y + (hDiv * y2);//y coord 2
			lx3 = x + (lDiv * x3);//x coord 3
			ly3 = y + (hDiv * y3);//y coord 3
			lx4 = x + (lDiv * x4);//x coord 4
			ly4 = y + (hDiv * y4);//y coord 4
			ctx.fillStyle = color;
			ctx.strokeStyle = color;
			ctx.beginPath();
			ctx.moveTo(lx1, ly1);
			ctx.lineTo(lx2, ly2);
			ctx.lineTo(lx3, ly3);
			ctx.lineTo(lx4, ly4);
			ctx.lineTo(lx1, ly1);
			ctx.closePath();
			break;
		case 'tri'://+x, +y, z, x1,y1,x2,y2,x3,x4,0,0,color,fill
			lx1 = x + (lDiv * x1);
			ly1 = y + (hDiv * y1);
			lx2 = x + (lDiv * x2);
			ly2 = y + (hDiv * y2);
			lx3 = x + (lDiv * x3);
			ly3 = y + (hDiv * y3);
			ctx.fillStyle = color;
			ctx.strokeStyle = color;
			ctx.beginPath();
			ctx.moveTo(lx1, ly1);
			ctx.lineTo(lx2, ly2);
			ctx.lineTo(lx3, ly3);
			ctx.lineTo(lx1, ly1);
			ctx.closePath();
			break;
		case 'lin': //Start x:X1,end y(Y1) ,? linewidth
			lx1 = x + (lDiv * x1);
			ly1 = y + (hDiv * y1);
			lx2 = x + (lDiv * x2);
			ly2 = y + (hDiv * y2);
			ctx.strokeStyle = color;
			ctx.fillStyle = color;
			ctx.beginPath();
			ctx.moveTo(lx1, ly1);
			ctx.lineTo(lx2, ly2);
			ctx.closePath();
			break;
		case 'arc': //ex: drawshape('arc',x,y,z,x1:1,y1:1,x2:1,y2:0,6
			lx1 = x + (lDiv * x1);//center x coord
			ly1 = y + (hDiv * y1);//center y coord
			lx2 = (hDiv * x2);//radius
			ly2 = Math.PI * y2; //start angle for partial circles?
			lx3 = Math.PI * x3; //end angle
			ctx.fillStyle = color;
			ctx.strokeStyle = color;
			ctx.beginPath();
			ctx.arc(lx1, ly1, lx2, ly2, lx3);
			break;
		case 'rec':
			lx1 =  x + (lDiv * x1);//upper left start x coord of rec
			ly1 =  y + (hDiv * y1);//upper left start y coord of rec
			lx2 = (lDiv * x2);//width
			ly2 = (hDiv * y2);//length
			ctx.strokeStyle = color;
			ctx.fillStyle = color;
			ctx.beginPath();
			ctx.rect(lx1,ly1,lx2,ly2);
			break;
		case 'ell'://center x, center y, x-rad, y-rad, rotation, start angle, end angle
			//if ellipse function doesnt exist for the browser define it
			if (CanvasRenderingContext2D.prototype.ellipse == undefined) {
				CanvasRenderingContext2D.prototype.ellipse = function(x, y, radiusX, radiusY, rotation, startAngle, endAngle, antiClockwise) {
					this.save();
					this.translate(x, y);
					this.rotate(rotation);
					this.scale(radiusX, radiusY);
					this.arc(0, 0, 1, startAngle, endAngle, antiClockwise);
					this.restore();
				}
			}
			lx1 =  x + (lDiv * x1);
			ly1 =  y + (hDiv * y1);
			lx2 = (lDiv * x2);
			ly2 = (hDiv * y2);
			ctx.strokeStyle = color;
			ctx.fillStyle = color;
			ctx.beginPath();
				ctx.ellipse(lx1, ly1, lx2, ly2, Math.PI / (x3+.0001), Math.PI*y3, Math.PI*x4);
			break;
	} //END SWITCH x,y,radX,radY,rotation,start angle,end angle[,anticlockwise])
	if(fill>0){ctx.fill();}else{ctx.stroke();}
}//end function
function drawText(x, y, boxW, boxH, text, color, z) {
  // 1. Setup Coordinates
  // Renamed arguments boxW/boxH to avoid shadowing local vars
  var zx = x, zy = y; // Store originals for portrait calculations
  var zl = boxW, zh = boxH;
  
  // Calculate Screen Coordinates
  var drawX = tX + (tL / 10) * x;
  var drawY = tY + (tH / 10) * y;
  var maxWidth = (tL / 10) * boxW * z;
  var maxHeight = (tH / 10) * boxH * z;

  // 2. Setup Font Initial State
  var fs = maxHeight; // Start with font size = full box height
  ctx.textBaseline = "hanging";
  
  // 3. Helper: The "Source of Truth" for wrapping
  // This ensures we wrap exactly the same way when checking size vs drawing
  function getWrappedLines(ctx, text, limit) {
    var words = text.split(" ");
    var lines = [];
    var currentLine = words[0];

    for (var i = 1; i < words.length; i++) {
      var word = words[i];
      var width = ctx.measureText(currentLine + " " + word).width;
      if (width < limit) {
        currentLine += " " + word;
      } else {
        lines.push(currentLine);
        currentLine = word;
      }
    }
    lines.push(currentLine);
    return lines;
  }

  // 4. Autosize Loop (First Pass)
  // We shrink the font until the wrapped lines fit inside maxHeight
  var linesArr = [];
  var fitFound = false;
  
  while (!fitFound && fs > 1) {
    ctx.font = fs + "px Franklin Gothic, Helvetica, Arial, sans-serif";
    linesArr = getWrappedLines(ctx, text, maxWidth);
    
    // Check if the total height of these lines fits
    // Note: This logic assumes 'tight' vertical packing (height/lines) like your original code.
    // Standard typography would use (linesArr.length * fs), but we'll stick to your requested fit.
    if ((linesArr.length * fs) > maxHeight) {
      fs = fs * 0.95; // Shrink font (0.95 is faster than 0.99)
    } else {
      fitFound = true;
    }
  }

  // 5. Render Loop (Second Pass)
  // We rely on 'linesArr' which is already wrapped correctly for this font size.
  
  // Determine vertical spacing to fill the box
  var lineHeight = maxHeight / linesArr.length;
  
  for (let i = 0; i < linesArr.length; i++) {
    let lineStr = linesArr[i];
    let yLine = drawY + (i * lineHeight);

    // --- Token Replacement & Portrait Drawing ---
    // We rebuild the string for drawing to handle INT/STR tokens
    let parts = lineStr.split(' ');
    let drawStr = '';
    
    for (let h = 0; h < parts.length; h++) {
      let part = parts[h];
      
      // Check for Tokens
      let p = 0;
      switch (part) {
        case 'INT': p = -5; break;
        case 'STR': p = -4; break;
        case 'CON': p = -6; break;
        case 'AGI': p = -7; break;
      }

      if (p !== 0) {
        // Calculate Portrait Position (k, j)
        // usage: k = current X cursor position
        let currentWidth = ctx.measureText(drawStr).width;
        let k = zx + (currentWidth / (tL / 10));
        let j = zy + (zh * z / linesArr.length) * i;
        let m = fs / tH;

        drawPortrait(p, k, j, m);
        part = '   '; // Replace token with spaces
      }
      
      drawStr += part + " ";
    }
    
    // Remove the trailing space from the loop
    drawStr = drawStr.trimEnd();

    // --- Final Draw (Scaling & Bolding) ---
    const diceRe = /^\s*\d+d\d+\s*$/;
    const hasToken = /\b(?:STR|CON|INT|AGI)\b/.test(lineStr); // Check original text for flags
    
    // Reset font to the calculated size (in case previous loop scaled it)
    ctx.font = fs + "px Franklin Gothic, Helvetica, Arial, sans-serif";
    
    // Only apply horizontal scaling/bolding if it's NOT a token line
    if (!hasToken) {
      let w = ctx.measureText(drawStr).width;
      
      // If a line is somehow still too wide (e.g. single long word), scale it to fit
      if (w > maxWidth) {
        let scale = maxWidth / w;
        if (diceRe.test(drawStr)) {
          ctx.font = "bold " + (fs * scale) + "px Franklin Gothic, Helvetica, Arial, sans-serif";
        } else {
          ctx.font = (fs * scale) + "px Franklin Gothic, Helvetica, Arial, sans-serif";
        }
      } else {
        // Fits normally
        if (diceRe.test(drawStr)) {
           ctx.font = "bold " + fs + "px Franklin Gothic, Helvetica, Arial, sans-serif";
        }
      }
    }
    
    ctx.fillStyle = color;
    ctx.fillText(drawStr, drawX, yLine);
  }
  
  // Restore font for safety
  ctx.font = fs + "px Franklin Gothic, Helvetica, Arial, sans-serif";
}
function drawPortrait(index,x,y,z){
  let sx = 0;
  let sy = 0;
  let sz = 0;
  switch(index){
    case 'wall':

    break;
    case -1: //L Arrow Button
      drawShape('arc',x,y,z,5,5,5,0,6,0,0,0,'rgba(255,255,255,.5)',1);//left
      drawShape('tri',x,y,z,7.5,1.5,7.5,8.5,1,5,0,0,'rgba(0,0,0,.5)',1);//left
      break;
    case -2: //R Arrow Button
      drawShape('arc',x,y,z,5,5,5,0,6,0,0,0,'rgba(255,255,255,.5)',1);//right
      drawShape('tri',x,y,z,2.5,8.5,2.5,1.5,9,5,0,0,'rgba(0,0,0,.5)',1);//right
      break;
    case -3: //green checkmark
      drawShape('tri',x,y,z,1,5, 1,7, 5,9, 0,0,'green',1);//right
      drawShape('tri',x,y,z,5,9, 4, 8, 10,2,0,0,'green',1);//right
      break
    case -4: //SWORD STR no yellow
      drawShape('qua',x,y,z,0,1, 2,3, 3,2, 1,0,'rgb(252,165,3)',1);//handle
      drawShape('qua',x,y,z,0,1, 2,3, 3,2, 1,0,'rgb(252,165,3)',0);//handle
      drawShape('tri',x,y,z,0,0, 1.4,0, 0,1.4 ,0,0,'darkgray',1);//pommel
      drawShape('tri',x,y,z,0,0, 1.4,0, 0,1.4 ,0,0,'rgb(252,165,3)',0);//pommel
      drawShape('qua',x,y,z,0,5, 1,5 ,5,1 ,5,0,'rgb(252,165,3)',1);//hilt guard
      drawShape('qua',x,y,z,2,4, 8,9, 8,8, 4,4,'gray',1);//lhalf blade
      drawShape('qua',x,y,z,4,2, 9,8, 8,8 ,4,4,'gray',1);//rhalf blade
      drawShape('tri',x,y,z,4,4, 4,2, 2,4, 0,0,'gray',1);//near hilt center
      drawShape('qua',x,y,z,9,8, 8,8, 8,9, 10,10,'gray',1);//sword tip
      drawShape('qua',x,y,z,0,5, 1,5, 5,1 ,5,0,'rgb(252,165,3)',0);//hilt guard outline
      drawShape('arc',x,y,z,3,3, .5,0, 6,0 ,0,0,'white',1);//hilt gem
      drawShape('arc',x,y,z,3,3 ,.51,0, 6,0, 0,0,'white',0);
      break;
    case -5://WAND INT NO RED
      drawShape('qua',x,y,z,0.2,9.5, 6.21,0, 10,3.77, .2,9.9,'rgba(85,43,0,1)',1);//handle
      drawShape('qua',x,y,z,0.2,9.5, 6.21,.1, 7,.8, .2,9.6,'rgba(0,0,0,.5)',1);//handle
      drawShape('qua',x,y,z,0.2,9.9, 6.5,4.5, 6.52,4.5, .2,9.9,'rgba(0,0,0,.5)',1);//handle
      //drawShape('tri',x,y,z,10,0, 6.21,0, 10,3.77, 0,0,'rgb(109,39,19)',1);//GFR
      drawShape('tri',x,y,z,10,0, 6.21,0, 8.2,2, 0,0,'rgba(255,0,0,.2)',1);//gfl
      drawShape('tri',x,y,z,10,0, 6.21,0, 10,3.77, 0,0,'rgba(209,70,47,.2)',1);//GFR
      //drawShape('tri',x,y,z,10,0, 6.21,0, 8.2,2, 0,0,'rgb(109,39,19)',1);//gfl
      drawShape('tri',x,y,z,6.21,0, 10,3.77, 9,1, 0,0,'rgba(255,0,0,.25)',1);//handle
      drawShape('tri',x,y,z,10,0, 6.21,0, 10,3.77, 0,0,'rgba(255,0,0,.3)',1);//gem mask
      break;
    case -6: //roundshield con no green
      drawShape('arc',x,y,z,4.8,5,4.5,0,6,0,0,0,'rgba(40,20,0,1)',1);
      drawShape('arc',x,y,z,5,5,4.5,0,6,0,0,0,'rgba(85,43,0,1)',1);
      drawShape('rec',x,y,z,0.5,5,9,.11,0,0,0,0,'rgba(0,0,0,.35)',1)
      drawShape('rec',x,y,z,.95,3,8.1,.11,0,0,0,0,'rgba(0,0,0,.35)',1)
      drawShape('rec',x,y,z,1,7,8,.11,0,0,0,0,'rgba(0,0,0,.35)',1)
      drawShape('qua',x,y,z,5,4,6,5,5,6,4,5,'green',1);
      drawShape('qua',x,y,z,3,1, 7,1.1, 2.8,1.2, 8,2,'rgba(0,0,0,.35)',1);
      drawShape('qua',x,y,z,3-1,1+1, 7-1,1.1+1, 2.8-1,1.2+1, 8-1,2+1,'rgba(0,0,0,.35)',1);
      drawShape('qua',x,y,z,1+3,1+2, 1+7,1.1+2, 1+2.8,1.2+2, 1+8,2+2,'rgba(0,0,0,.35)',1);
      drawShape('qua',x,y,z,1+3,1+5, 1+7,1.1+5, 1+2.8,1.2+5, 1+8,2+5,'rgba(0,0,0,.35)',1);
      drawShape('qua',x,y,z,3,1+6, 7,1.1+6, 2.8,1.2+6, 8,2+6,'rgba(0,0,0,.35)',1);
      drawShape('qua',x,y,z,3-1,1+7, 7-1,1.1+7, 2.8-1,1.2+7, 8-1,2+7,'rgba(0,0,0,.35)',1);
      //drawShape('qua',x,y,z,1,3, 7,1.1, 2.8,1.2, 8,2,'rgba(0,0,0,.35)',1);
      //drawShape('qua',x,y,z,1,3, 7,1.1, 2.8,1.2, 9,3,'rgba(0,0,0,.35)',1);
      break;
    case -7://hourglass agi no blue
      drawShape('qua',x,y,z,1,9,9,9,1,1,9,1,'white',1);//body
      drawShape('rec',x,y,z,1,.75,8,.25,0,0,0,0,'blue',1);
      drawShape('rec',x,y,z,1,9,8,.25,0,0,0,0,'blue',1);

      drawShape('tri',x,y,z,2.5,9,7.5,9,5,8.5,0,0,'blue',1);//bottom sand
      drawShape('tri',x,y,z,5,5,2.5,2.5,7.5,2.5,0,0,'blue',1);//top sand
      drawShape('qua',x,y,z,5,5, 4.9,6, 5.1,7, 4.9,8.5,'blue',1);//drip sand
      break;
    case -8://six sided star
      drawShape('tri',x,y,z,5,0,.5,7.5,9.5,7.5,0,0,'white',1);
      drawShape('tri',x,y,z,5,10,.5,2.5,9.5,2.5,0,0,'white',1);
      break;
    case -9://leaf
      drawShape('qua',x,y,z,0,10, 1,4, 3.5,1.5, 10,0,'green',1);
      drawShape('qua',x,y,z,10,0, 9,6, 6.5,8.5, 0,10,'green',1);
      drawShape('qua',x,y,z,0,10, 1,4, 3.5,1.5, 10,0,'rgba(0,0,0,.45)',0);
      drawShape('qua',x,y,z,0,10, 4,4, 5,3, 10,0,'rgba(0,0,0,.15)',1);
      break;
    case -10://yellow sphere
      drawShape('arc',x,y,z,9,1,.8,0,6,0,0,0,'gold',1);//bag
      drawShape('arc',x,y,z,8.95,.95,.75,0,6,0,0,0,'rgba(255,255,255,.15)',1);//bag
      drawShape('arc',x,y,z,8.9,1,.7,0,6,0,0,0,'rgba(255,255,255,.15)',1);//bag
      drawShape('arc',x,y,z,8.85,1,.65,0,6,0,0,0,'rgba(255,255,255,.15)',1);//bag
      drawShape('arc',x,y,z,8.8,1,.6,0,6,0,0,0,'rgba(255,255,255,.15)',1);//bag
    break;
    case -11: //YELLOW SWORD ICON STR STAT
      drawShape('rec',x,y,z,0,0,10,10,0,0,0,0,'yellow',1)
      drawShape('rec',x,y,z,0,0,10,10,0,0,0,0,'rgba(255,255,255,.45)',1)
  		drawShape('qua',x,y,z,0,1, 2,3, 3,2, 1,0,'rgb(252,165,3)',1);//handle
      drawShape('qua',x,y,z,0,1, 2,3, 3,2, 1,0,'rgb(252,165,3)',0);//handle
      drawShape('tri',x,y,z,0,0, 1.4,0, 0,1.4 ,0,0,'darkgray',1);//pommel
      drawShape('tri',x,y,z,0,0, 1.4,0, 0,1.4 ,0,0,'rgb(252,165,3)',0);//pommel
  		drawShape('qua',x,y,z,0,5, 1,5 ,5,1 ,5,0,'rgb(252,165,3)',1);//hilt guard
  		drawShape('qua',x,y,z,2,4, 8,9, 8,8, 4,4,'gray',1);//lhalf blade
  		drawShape('qua',x,y,z,4,2, 9,8, 8,8 ,4,4,'gray',1);//rhalf blade
  		drawShape('tri',x,y,z,4,4, 4,2, 2,4, 0,0,'gray',1);//near hilt center
  		drawShape('qua',x,y,z,9,8, 8,8, 8,9, 10,10,'gray',1);//sword tip
  		drawShape('qua',x,y,z,0,5, 1,5, 5,1 ,5,0,'rgb(252,165,3)',0);//hilt guard outline
  		drawShape('arc',x,y,z,3,3, .5,0, 6,0 ,0,0,'white',1);//hilt gem
  		drawShape('arc',x,y,z,3,3 ,.51,0, 6,0, 0,0,'white',0);
  		break;
    case -12://RED WAND ICON INT STAT
      drawShape('rec',x,y,z,0,0,10,10,0,0,0,0,'rgb(209,70,47)',1)
      drawShape('rec',x,y,z,0,0,10,10,0,0,0,0,'rgba(255,255,255,.13)',1)
                              //BASE    TL    tR
      drawShape('qua',x,y,z,0.2,9.5, 6.21,0, 10,3.77, .2,9.9,'rgba(85,43,0,1)',1);//handle
      drawShape('qua',x,y,z,0.2,9.5, 6.21,.1, 7,.8, .2,9.6,'rgba(0,0,0,.5)',1);//handle
      drawShape('qua',x,y,z,0.2,9.9, 6.5,4.5, 6.52,4.5, .2,9.9,'rgba(0,0,0,.5)',1);//handle
      //drawShape('tri',x,y,z,10,0, 6.21,0, 10,3.77, 0,0,'rgb(109,39,19)',1);//GFR
      drawShape('tri',x,y,z,10,0, 6.21,0, 8.2,2, 0,0,'rgba(255,0,0,.2)',1);//gfl
      drawShape('tri',x,y,z,10,0, 6.21,0, 10,3.77, 0,0,'rgba(209,70,47,.2)',1);//GFR
      //drawShape('tri',x,y,z,10,0, 6.21,0, 8.2,2, 0,0,'rgb(109,39,19)',1);//gfl
      drawShape('tri',x,y,z,6.21,0, 10,3.77, 9,1, 0,0,'rgba(255,0,0,.25)',1);//handle
      drawShape('tri',x,y,z,10,0, 6.21,0, 10,3.77, 0,0,'rgba(255,0,0,.3)',1);//gem mask
       break;
    case -13: //GREEN ROUNDSHIELD ICON CON STAT
      drawShape('rec',x,y,z,0,0,10,10,0,0,0,0,'green',1)
      drawShape('rec',x,y,z,0,0,10,10,0,0,0,0,'rgba(255,255,255,.35)',1)
      drawShape('arc',x,y,z,4.8,5,4.5,0,6,0,0,0,'rgba(40,20,0,1)',1);
			drawShape('arc',x,y,z,5,5,4.5,0,6,0,0,0,'rgba(85,43,0,1)',1);
      drawShape('rec',x,y,z,0.5,5,9,.11,0,0,0,0,'rgba(0,0,0,.35)',1)
      drawShape('rec',x,y,z,.95,3,8.1,.11,0,0,0,0,'rgba(0,0,0,.35)',1)
      drawShape('rec',x,y,z,1,7,8,.11,0,0,0,0,'rgba(0,0,0,.35)',1)
			drawShape('qua',x,y,z,5,4,6,5,5,6,4,5,'green',1);
      drawShape('qua',x,y,z,3,1, 7,1.1, 2.8,1.2, 8,2,'rgba(0,0,0,.35)',1);
      drawShape('qua',x,y,z,3-1,1+1, 7-1,1.1+1, 2.8-1,1.2+1, 8-1,2+1,'rgba(0,0,0,.35)',1);
      drawShape('qua',x,y,z,1+3,1+2, 1+7,1.1+2, 1+2.8,1.2+2, 1+8,2+2,'rgba(0,0,0,.35)',1);
      drawShape('qua',x,y,z,1+3,1+5, 1+7,1.1+5, 1+2.8,1.2+5, 1+8,2+5,'rgba(0,0,0,.35)',1);
      drawShape('qua',x,y,z,3,1+6, 7,1.1+6, 2.8,1.2+6, 8,2+6,'rgba(0,0,0,.35)',1);
      drawShape('qua',x,y,z,3-1,1+7, 7-1,1.1+7, 2.8-1,1.2+7, 8-1,2+7,'rgba(0,0,0,.35)',1);
      //drawShape('qua',x,y,z,1,3, 7,1.1, 2.8,1.2, 8,2,'rgba(0,0,0,.35)',1);
      //drawShape('qua',x,y,z,1,3, 7,1.1, 2.8,1.2, 9,3,'rgba(0,0,0,.35)',1);
			break;
    case -14://BLUE HOURGLASS ICON AGI STAT
      drawShape('rec',x,y,z,0,0,10,10,0,0,0,0,'blue',1)
      drawShape('rec',x,y,z,0,0,10,10,0,0,0,0,'rgba(255,255,255,.35)',1)
      drawShape('qua',x,y,z,1,9,9,9,1,1,9,1,'white',1);//body
      drawShape('rec',x,y,z,1,.75,8,.25,0,0,0,0,'rgb(128,64,0)',1);
      drawShape('rec',x,y,z,1,9,8,.25,0,0,0,0,'rgb(128,64,0)',1);
      drawShape('tri',x,y,z,2.5,9,7.5,9,5,8.5,0,0,'brown',1);//bottom sand
      drawShape('tri',x,y,z,5,5,2.5,2.5,7.5,2.5,0,0,'brown',1);//top sand
      drawShape('qua',x,y,z,5,5, 4.9,6, 5.1,7, 4.9,8.5,'brown',1);//drip sand
      break;
    case -15: //SWORD ATTACK ICON
    	drawShape('rec',x,y,z,0,0, 10,10, 0,0 ,0,0,'rgb(255,255,255)',0);

			drawShape('tri',x,y,z,0,8.6, 1.4,10, 0,10 ,0,0,'rgb(252,165,3)',1);
			drawShape('qua',x,y,z,0,9, 2,7, 3,8, 1,10,'rgb(252,165,3)',1);
			drawShape('qua',x,y,z,0,5, 1,5 ,5,9 ,5,10,'rgb(252,165,3)',1);
			drawShape('qua',x,y,z,2,6, 8,1, 8,2, 4,6,'gray',1);//
			drawShape('qua',x,y,z,4,8, 9,2, 8,2 ,4,6,'gray',1);
			drawShape('tri',x,y,z,2,6, 4,6, 4,8, 0,0,'gray',1);
			drawShape('qua',x,y,z,8,1, 8,2, 9,2, 10,0,'gray',1);
			drawShape('qua',x,y,z,0,5, 1,5, 5,9 ,5,10,'rgb(252,165,3)',0);
			drawShape('arc',x,y,z,3,7, .5,0, 6,0 ,0,0,'red',1);//pommel gem
			drawShape('arc',x,y,z,3,7 ,.5,0, 6,0, 0,0,'brown',0);
			break;
    case -16: //SHIELD
			drawShape('rec',x,y,z,1,1,8,5,0,0,0,0,'gray',1);
			drawShape('tri',x,y,z,1,6,5.1,9,9,6,0,0,'gray',1);
			drawShape('lin',x,y,z,5.1,1,5.1,9,0,0,0,0,'blue',0);
			drawShape('lin',x,y,z,1,3.5,9,3.5,0,0,0,0,'blue',0);
			break;
    case -17: //EXAMINE
      drawShape('qua',x,y,z,4.2,4.5, .8,9.25, 1.5,9.88, 5.25,5.5,'rgba(128,64,0,1)',1)
      drawShape('arc',x,y,z,6.85,2.75,2.75,0,6,0,0,0,'rgba(255,255,255,.5)',1);
      drawShape('arc',x,y,z,6.75,3,3,0,6,0,0,0,'rgba(255,255,255,.5)',1);
      break;
    case -18://Potion
      drawShape('qua',x,y,z, 4.4,0.75, 5.6,0.75, 5.25,2.45, 4.75,2.45,'rgba(186,103,0,1)',1)//cork
      drawShape('qua',x,y,z, 3.95,3.449, 6.0456,3.4488, 5.5,1.25, 4.5,1.25,'rgba(249,255,255,.28)',1);//bottleneck
      drawShape('arc',x,y,z,5,6.38,  2.8,  1.667,1.337,0,0,0,'rgba(255,0,0,1)',1);//liquid
      drawShape('arc',x,y,z,5,6.25,  3,  1.6163,1.3836,0,0,0,'rgba(249,255,255,.28)',1);//bottle
      drawShape('ell',x,y,z,5,3.95, 1.4,.3, 1, 1,2,0,'rgba(0,0,0,.2)',1);//surface liquid
      drawShape('ell',x,y,z,6.3,5.44, .55,.35, 1, 0,2,0,'rgba(255,255,255,.8)',1);//reflection
    break;
    case -19: //TOME
			// hourglass example drawShape('qua',x,y,z,0,10,10,10,2.5,5,7.5,5,'rgba(63,72,204,.45)',1);
			//drawShape('arc',x,y,z,5,5.25,5.3,0,6,0,0,0,'rgba(255,255,255,.45)',1);
			drawShape('qua',x,y,z,0,7.5,10,7.5,7.5,2.5,2.5,2.5,'rgba(128,64,0,.85)',1);
			drawShape('qua',x,y,z,.2,7.1,9.8,7.1,7.5,2.5,2.5,2.5,'rgba(255,255,128,1)',1);
			drawShape('lin',x,y,z,5,7.5,5,2.5,0,0,0,0,'rgba(128,64,0,.85)',1);
			drawShape('arc',x,y,z,3.75,3.8,1.75,1.25,1.75,0,0,0,'rgba(255,255,128,1)',1);
			drawShape('arc',x,y,z,6.25,3.8,1.75,1.25,1.75,0,0,0,'rgba(255,255,128,1)',1);
			drawShape('arc',x,y,z,2.5,7.9,2.4,1.1,1.9,0,0,0,'rgba(248,179,16,.85)',1);
			drawShape('arc',x,y,z,7.5,7.9,2.4,1.1,1.9,0,0,0,'rgba(248,179,16,.85)',1);
			break;
    case -20: //broken SWORD
			drawShape('tri',x,y,z,0,8.5,1.5,10,0,10,0,0,'gold',1);
			drawShape('qua',x,y,z,0,9,2,7,3,8,1,10,'gold',1);
			drawShape('qua',x,y,z,0,5,1,5,5,9,5,10,'gold',1);
			drawShape('qua',x,y,z,2,6,8,1,8,2,4,6,'gray',1);
			drawShape('qua',x,y,z,4,8,9,2,8,2,4,6,'gray',1);
			drawShape('tri',x,y,z,2,6,4,6,4,8,0,0,'white',1);
			drawShape('qua',x,y,z,8,1,8,2,9,2,10,9,'white',1);
			drawShape('arc',x,y,z,3,7,.5,0,6,0,0,0,'red',1);
			break;
    case -21://Use item/cast spell
    drawShape('rec',x,y,z,0,0,10,10,0,0,0,0,'rgb(255,255,255)',0);
      //tomearc
      sx = 1.5*z;
      sy = 1*z;
      sz = .75;
      drawShape('qua',x+sx,y+sy,z*sz,0,7.5,10,7.5,7.5,2.5,2.5,2.5,'rgba(128,64,0,1)',1);
			drawShape('qua',x+sx,y+sy,z*sz,.2,7.1,9.8,7.1,7.5,2.5,2.5,2.5,'rgba(255,255,128,1)',1);
			drawShape('lin',x+sx,y+sy,z*sz,5,7.5,5,2.5,0,0,0,0,'rgba(128,64,0,.85)',1);
			drawShape('arc',x+sx,y+sy,z*sz,3.75,3.8,1.79,1.25,1.75,0,0,0,'rgba(255,255,128,1)',1);
			drawShape('arc',x+sx,y+sy,z*sz,6.25,3.8,1.79,1.25,1.75,0,0,0,'rgba(255,255,128,1)',1);
      drawShape('qua',x+sx,y+sy,z*sz,4.77,7.2, 4.9,2.4, 4,6, 4.488,6.51,'rgba(0,0,0,.1)',1);
      drawShape('qua',x+sx,y+sy,z*sz,5.188,7.2, 5.1,2.4, 6,6, 5.512,6.51,'rgba(0,0,0,.1)',1);
			drawShape('arc',x+sx,y+sy,z*sz,2.5,7.9,2.4,1.1,1.9,0,0,0,'rgba(248,179,16,.85)',1);
			drawShape('arc',x+sx,y+sy,z*sz,7.5,7.9,2.4,1.1,1.9,0,0,0,'rgba(248,179,16,.85)',1);
      for (let i = 0;i<40;i++){
        drawShape('arc',x+sx,y+sy,z*sz,2.5,7.89, 2.39-i*.05,1.1,1.9,0,0,0,'rgba(0,0,0,.25)',0);
			  drawShape('arc',x+sx,y+sy,z*sz,7.5,7.89, 2.39-i*.05,1.1,1.9,0,0,0,'rgba(0,0,0,.25)',0);
      }
      drawShape('rec',x+sx,y+sy,z*sz,0.2,7.13,9.6,.35,0,0,0,0,'rgb(128,64,0)',1);
      drawShape('pol',x+sx,y+sy,z*sz,4.75,7.1, 4.9,2.42, 5.1,2.42, 5.2,7.2,'rgba(0,0,0,.45)',1, 5,7.1);
      
      //sword pommel
      sx = -.15*z;
      sy = -2*z;
      sz = 1;
      drawShape('arc',x+sx,y+sy,z*sz,.5,8.25, .3,.3, 0,2  ,0,0,'gold',1);//sword-pommel
      drawShape('arc',x+sx,y+sy,z*sz,.5,8.25, .3,.3, 0,2  ,0,0,'rgba(0,0,0,.3)',1);//sword-pommel
      drawShape('ell',x+sx,y+sy,z*sz,.5,8.15, .2,.13, 0, 2  ,0 ,0,'rgba(128,0,0,1)',1);//sword-pommel
      drawShape('arc',x+sx,y+sy,z*sz,.45,8.3, .275,0, 2,2  ,0,0,'rgba(0,0,0,.15)',1);//sword-pommel
      drawShape('arc',x+sx,y+sy,z*sz,.5,8.25, .3,.2, .95, 0  ,0 ,0,'rgba(0,0,0,.24)',1);//sword-pommel
      drawShape('arc',x+sx,y+sy,z*sz,.5,8.25, .3,0, 1.2, 0  ,0 ,0,'rgba(0,0,0,.24)',1);//sword-pommel

      //sword
      sx = -3.65*z;
      sy = -2.25*z;
      sz = 1.5;
      drawShape('qua',x+sx,y+sy,z*sz,4.1,5.5, 4.1,5.8, 2.8,5.81, 2.8,5.5,'gold',1);//sword-handle
      drawShape('qua',x+sx,y+sy,z*sz,4.1,5.9, 4.1,6,   2.8,5.81, 2.8,5.7,'rgba(0,0,0,.4)',1);//sword-handle
      drawShape('qua',x+sx,y+sy,z*sz,4.1,5.7, 4.1,5.8, 2.8,5.81, 2.8,5.5,'rgba(0,0,0,.4)',1);//sword-handle
			drawShape('tri',x+sx,y+sy,z*sz,9,5.8, 4.1,5.35, 3.9,6.15  ,0,0,'white',1);//sword-blade
      drawShape('tri',x+sx,y+sy,z*sz,9,5.8, 4.1,5.5,  3.9,5.8  ,0,0,'rgba(0,0,0,.15)',1);//sword-blade
			drawShape('tri',x+sx,y+sy,z*sz,9,5.8, 4.1,5.35, 3.9,6.1  ,0,0,'rgba(0,0,0,.15)',1);//sword-blade
			drawShape('tri',x+sx,y+sy,z*sz,9,5.8, 4.1,5.45, 3.9,6.15  ,0,0,'rgba(0,0,0,.15)',1);//sword-blade
			drawShape('qua',x+sx,y+sy,z*sz,4.2,4.5, 4.1,5.7, 3.7,6.8, 3.6,6,'gold',1);//sword-crossguard
      drawShape('qua',x+sx,y+sy,z*sz,4.2,4.5, 3.8,5.7, 3.7,6.8, 3.6,6,'rgba(0,0,0,.4)',1);//sword-crossguard
			drawShape('qua',x+sx,y+sy,z*sz,4.2,4.5, 4.1,5.7, 3.7,6.8, 3.6,6,'rgba(0,0,0,.4)',1);//sword-crossguard

      //potion
      sx = 5*z;
      sy = 3*z;
      sz = .5;
      drawShape('qua',x+sx,y+sy,z*sz, 4.4,0.75, 5.6,0.75, 5.25,2.45, 4.75,2.45,'rgba(186,103,0,1)',1)//cork
      drawShape('qua',x+sx,y+sy,z*sz, 4.4,0.75, 5.6,0.75, 5.25,.9, 4.75,.9,'rgba(255,255,255,.1)',1)//cork
      drawShape('qua',x+sx,y+sy,z*sz, 4.4,0.75, 4.5,0.75, 5.25,2.45, 4.75,2.45,'rgba(0,0,0,.40)',1)//cork
      drawShape('qua',x+sx,y+sy,z*sz, 3.95,3.449, 6.0456,3.4488, 5.5,1.25, 4.5,1.25,'rgba(249,255,255,.28)',1);//bottleneck
      drawShape('qua',x+sx,y+sy,z*sz, 3.95,3.449, 6.0456,3.4488, 5.5,1.25, 4.5,1.25,'rgba(0,0,0,.28)',1);//bottleneck
      drawShape('arc',x+sx,y+sy,z*sz,5,6.38,  2.8,  1.667,1.337,0,0,0,'rgba(255,0,0,1)',1);//liquid
      drawShape('arc',x+sx,y+sy,z*sz,5,6.25,  3,  1.6163,1.3836,0,0,0,'rgba(249,255,255,.28)',1);//bottle
      drawShape('arc',x+sx,y+sy,z*sz,5,6.25,  3,  1.6163,1.3836,0,0,0,'rgba(0,0,0,.28)',1);//bottle
      drawShape('ell',x+sx,y+sy,z*sz,5,3.95, 1.4,.3, 1, 1,2,0,'rgba(0,0,0,.2)',1);//surface liquid
      drawShape('ell',x+sx,y+sy,z*sz,6.3,5.44, .55,.35, 1, 0,2,0,'rgba(255,255,255,.8)',1);//reflection
      
      //coins
      sx = 3.5*z;
      sy = 4.5*z;
      sz = 1;
      for (let i = 10;i>0;i--){
        drawShape('ell',x+sx,y+sy,z*sz,2,2.1+i*.1,.5,.15,  0,2,0,0,'rgba(0,0,0,.4)',1);
        drawShape('ell',x+sx,y+sy,z*sz,2,2.1+i*.1,.5,.15,  0,2,0,0,'rgba(0,0,0,.4)',0);
        drawShape('ell',x+sx,y+sy,z*sz,2,2+i*.1,.5,.15,  0,2,0,0,'rgba(255,255,0,1)',1);
      }

      break;
    case -22://Examine (eye)
      drawShape('rec',x,y,z,0,0,10,10,0,0,0,0,'rgb(255,255,255)',0);
      sx = 2.8*z;
      sy = -7.2*z;
      sz = 2;
      for (let i = 0;i<64;i++){
        drawShape('ell',x+sx,y+sy,z*sz,    1+i*.001, 6+i*.001,        2-i*.01,   .5+i*.01,  0,    0,   2,    0,   `rgba(${255},${155},${155},1)`,1)
        drawShape('ell',x+sx,y+sy,z*sz,    1+i*.001, 6+i*.001,        2-i*.01,   .5+i*.01,  0,    1.1,   -.1,    0,   `rgba(${255},${179},${102},1)`,1)
        drawShape('ell',x+sx,y+sy,z*sz,    1+i*.001, 6+i*.001,        2-i*.01,   .5+i*.01,  0,    .1,  .9,    0,   `rgba(${255},${179},${102},1)`,1)
        drawShape('ell',x+sx,y+sy,z*sz,    1+i*.001, 6+i*.001,        2-i*.01,   .5+i*.01,  0,    1.1,   -.1,    0,   `rgba(${0},${0},${0},.2)`,1)
        drawShape('ell',x+sx,y+sy,z*sz,    1+i*.001, 6+i*.001,        2-i*.01,   .5+i*.01,  0,    .1,  .9,    0,   `rgba(${0},${0},${0},.2)`,1)
      }
      sz = .75;
      sx = 1.05*z;
      sy = 1.1*z;

      drawShape('ell',x+sx,y+sy,z*sz,    5.1, 5.1,        4.1,   2.1,  0,    2,  0,    0,   `rgba(${255},${255},${255},1)`,1)
      drawShape('ell',x+sx,y+sy,z*sz,    5.1, 5.1,        2,   2,  0,    2,  0,    0,   `rgba(${180},${180},${255},1)`,1)
      drawShape('ell',x+sx,y+sy,z*sz,    5.1, 5.1,        .5,   .5,  0,    2,  0,    0,   `rgba(${0},${0},${0},1)`,1)

      break;
    case 9.1: //Hermit monster
      drawShape('ell',x,y,z,4.59,.8,.65,.5,1,0,6,0,'gray',1);
      drawShape('qua',x,y,z,5.3,1, 6,2.5, 5.5,2.5, 5,1,'gray',1);//hair back
			
      sx = .15*z;
      sy = .49*z;
      sz=.95;
			drawShape('qua',x,y,z,4.4,8.5,/*tr*/4.75,9.5,/*br*/ 3,9.5,/*l*/4,9,/*tl*/'darkgray',1);//l-foot
			drawShape('qua',x+sx,y+sy,z*sz,4.5,9.5,/*br*/ 4.5,7.7,/*tr*/ 3.3,7.3,/*tl*/ 4.3,9,/*bl*/'darkgray',1);//l-calf
			//drawShape('qua',x+sx,y+sy,z*sz,4.5,9.5,/*br*/ 4.5,7.7,/*tr*/ 3.3,7.3,/*tl*/ 3.9,9,/*b*/'gray',0);//l-calf
			drawShape('qua',x+sx,y+sy,z*sz,4.7,2,5.5,1.5,6,2.5,4.25,2.5,'gray',1);//neck
			drawShape('qua',x+sx,y+sy,z*sz,5.5,7,/*tl*/6.25,7.25,/*tm*/6.75,7.2,/*tr*/ 6.25,9.5,/*b*/'darkgray',1);//r-calf
			//drawShape('qua',x,y,z,6.25,9,/*tl*/6.55,9.5,/*bl*/4.5,9.75,/*bm*/ 6,9,/*br*/'darkgray',1);//r-foot
			drawShape('qua',x,y,z,5.9,8.5,/*tr*/6.25,9.5,/*br*/ 4.8,9.6,/*l*/6,9,/*tl*/'darkgray',1);//l-foot
			drawShape('qua',x,y,z,/*tr*/ 4,2.5, /*tl*/3,1.5, /*bl*/2.5,5, 4,8,'gray',1);//l-arm
		  drawShape('qua',x,y,z,/*tr*/ 4,2.5, /*tl*/3,1.5, /*bl*/2.5,5, 4,8,'rgba(0,0,0,0.15)',1);//l-arm
			drawShape('tri',x+sx,y+sy,z*sz,/*tl*/ 5.55,3.55, /*tr*/6.3,2.5, /*br*/7.7,4, 0,0,'lightgray',1);//r-arm
			drawShape('tri',x+sx,y+sy,z*sz,/*tl*/ 5.6,3.5, /*tr*/6.3,2.5, /*br*/7.7,4, 0,0,'gray',0);//r-arm
			drawShape('arc',x+sx,y+sy,z*sz,6.2,5.75,.4,0,3,0,0,0,'darkgray',1);//r-hand
      drawShape('qua',x+sx,y+sy,z*sz,4,2, 4,4, 3,8, 7.25,7.25,'gray',1);//robeLShoulder
      drawShape('qua',x+sx,y+sy,z*sz,6,2.1, 7.5,3.5, 7.25,7.25, 4,2,'gray',1);//robeLShoulder
      drawShape('qua',x,y,z,7,9, 3,8.5, 3,8.1, 6,7.5,'gray',1);//robeLShoulder
      drawShape('tri',x+sx,y+sy,z*sz,/*br*/ 7.9,3.9, /*tr*/7.3,3.3, /*l*/6.5,5.5, 0,0,'lightgray',1);//r-forearm
			drawShape('tri',x+sx,y+sy,z*sz,/*br*/ 7.9,3.9, /*tr*/7.3,3.3, /*l*/6.5,5.5, 0,0,'gray',0);//r-forearm
      drawShape('qua',x,y,z,/*bl*/ 3,2.5, /*tl*/2.25,1.5, /*tr*/2.5,1, /*br*/ 3.5,2,'lightgray',1);//l-forearm
      drawShape('qua',x,y,z,2.5,1, 1.5,1, 2,1.5, 2.5,1.4,'rgb(185,122,87)',1);//hand left
      //drawShape('arc',x,y,z,2,2.75, .39,0, 3,0, 0,0,'gold',1);////gold orb
      drawShape('arc',x,y,z,2,2.75, .5,0, 3,0, 0,0,'rgba(255,255,0,.05)',1);////gold orb
      sx = 1.62*z;
      sy = 2.35*z;
      sz=.075;
      drawShape('tri',x+sx,y+sy,z*sz,5,0,.5,7.5,9.5,7.5,0,0,'black',0);
      drawShape('tri',x+sx,y+sy,z*sz,5,10,.5,2.5,9.5,2.5,0,0,'black',0);
      drawShape('tri',x+sx,y+sy,z*sz,5,0,.5,7.5,9.5,7.5,0,0,'gold',1);
      drawShape('tri',x+sx,y+sy,z*sz,5,10,.5,2.5,9.5,2.5,0,0,'gold',1);
      sx = 1.25*z;
      sy = 2*z;
      sz=.15;
      drawShape('tri',x+sx,y+sy,z*sz,5,0,.5,7.5,9.5,7.5,0,0,'rgba(255,255,0,.25)',1);
      drawShape('tri',x+sx,y+sy,z*sz,5,10,.5,2.5,9.5,2.5,0,0,'rgba(255,255,0,.25)',1);
      sx = 1.5*z;
      sy = 2.25*z;
      sz=.1;
      drawShape('tri',x+sx,y+sy,z*sz,5,0,.5,7.5,9.5,7.5,0,0,'rgba(255,255,0,.25)',1);
      drawShape('tri',x+sx,y+sy,z*sz,5,10,.5,2.5,9.5,2.5,0,0,'rgba(255,255,0,.25)',1);
      sx = .15*z;
      sy = .49*z;
      sz=.95;
      drawShape('arc',x,y,z,2,2.2, .6,1, 0,1, 1,0,'brown',1);//lantern top
      drawShape('rec',x,y,z,1.5,3.25, 1,.1, 0,1, 1,0,'brown',1);////lantern bottom
      drawShape('rec',x,y,z,1.5,1.99, .1,1.27, 0,1, 1,0,'brown',1);////lantern bottom
      drawShape('rec',x,y,z,1.95,1.99, .1,1.27, 0,1, 1,0,'brown',1);////lantern bottom
      drawShape('rec',x,y,z,2.4,1.99, .1,1.27, 0,1, 1,0,'brown',1);////lantern bottom
      drawShape('ell',x,y,z,2,2.17, .6,.1, 1,1, 0,6,'brown',0);//lantern top
      drawShape('ell',x,y,z,2,2.17, .6,.1, 1,1, 0,6,'rgba(255,255,0,.25)',1);//lantern top
      drawShape('ell',x,y,z,2,3.3, .5,.1, 1,1, 0,6,'brown',1);//lantern top
      drawShape('rec',x,y,z,1.975,1, .05,.6, 0,1, 1,0,'gray',1);////lantern bottom
      drawShape('arc',x,y,z,2,1.55, .1,0, 3,0, 0,0,'brown',1);////gold orb
      drawShape('qua',x,y,z,2.5,1, 1.7,1.1, 2,1.15, 2.5,1.4,'rgb(185,122,87)',1);//hand left
     	drawShape('arc',x+sx,y+sy,z*sz,6,3, .63,0, 3,0, 0,0,'rgba(0,0,0,0.025)',1);//r-shoulder
      drawShape('qua',x+sx,y+sy,z*sz,6,2.1, 7.5,3.5, 7.25,7.25, 4,2,'rgba(0,0,0,0.1)',1);//robeLShoulder
      drawShape('qua',x,y,z,2.5,1, 3,3.5, 7,9, 7,5.5,'gray',1);//crown
      drawShape('qua',x+sx,y+sy,z*sz,7,5, 6,4.75, 6.3,5.5, 6.5,5.5,'rgb(185,122,87)',1);//hand right
      drawShape('rec',x+sx,y+sy,z*sz,6.3,1, .19,8.9, 6.3,3, 0,0,'brown',1);//ankh
      drawShape('rec',x+sx,y+sy,z*sz,6.3,1, .19,8.9, 6.3,3, 0,0,'rgb(0,6,13)',0);//ankh
      drawShape('arc',x+sx,y+sy,z*sz,6.4,1, .25,0, 3,0, 0,0,'brown',1);//ankh circle outer
      drawShape('arc',x+sx,y+sy,z*sz,6.4,1, .25,0, 3,0, 0,0,'rgb(0,6,13)',0);//ankh circle outer
      drawShape('qua',x+sx,y+sy,z*sz,7,5, 6,5, 6.3,5.5, 6.5,5.5,'rgb(185,122,87)',1);//hand right
      drawShape('qua',x+sx,y+sy,z*sz,4.7,5.5,/*tr*/ 3.5,7.5,/*br*/ 4.4,7.7,/*bl*/ 5,6.5,'rgba(0,0,0,.05)',1);//l-thigh shadow
      drawShape('arc',x+sx,y+sy,z*sz,4.25,2.65, .63,0, 3,0, 0,0,'rgba(0,0,0,.025)',1);//l-shoulder
			drawShape('ell',x+sx,y+sy,z*sz,5.15,3.6,1.15,1.75,0,0,6,0,'rgba(0,0,0,.025)',1);//torso
			drawShape('qua',x+sx,y+sy,z*sz,4.5,5.5,/*tl*/6,4.5,/*tr*/ 6.5,7.7,/*br*/ 5.8,8,/*bl*/ 'rgba(0,0,0,.04)',1);//r-thigh
			drawShape('qua',x+sx,y+sy,z*sz,6.2,4.3,7.25,7.25,5.1,6.3,4.75,5.25,'rgba(0,0,0,.05)',1);//hip armor
		  drawShape('qua',x+sx,y+sy,z*sz,3,8, 3,2, 5.5,5.5, 7,7.3,'rgba(0,0,0,.05)',1);//groin armor
      drawShape('qua',x+sx,y+sy,z*sz,4,2, 3.5,2.5, 6.5,7.2, 4.2,5,'rbga(0,0,0,.05)',1);//robeLShoulder
      drawShape('qua',x+sx,y+sy,z*sz,4,2, 6.5,2.5, 3.5,7.2, 6.5,5,'rgba(0,0,0,.05)',1);//robeLShoulder
      drawShape('qua',x,y,z,5,1, 4.5,2, 4.75,2.5, 4.5,3,'rgba(255,255,255,.9)',1);//beard l
      drawShape('qua',x,y,z,4.75,2.5, 5.5,2, 5.25,.75, 4,1,'rgb(185,122,87)',1);//head
      drawShape('qua',x,y,z,4.75,2.5, 4.5,2, 4.5,3, 4.5,3,'rgba(255,255,255,.9)',1);//beard l
      drawShape('qua',x,y,z,4.5,2, 5,1.8, 5,1.9, 4.5,2.11,'rgba(255,255,255,.9)',1);//beard l
      drawShape('qua',x,y,z,5.3,1, 5.5,2, 5,3, 4.5,3,'rgba(255,255,255,.9)',1);//beard
      drawShape('tri',x,y,z,5,1.8, 4.5,2, 4.75,2.5, 4.75,2.5,'rgba(255,255,255,.9)',1);//beard
      drawShape('tri',x,y,z,4.5,1, 5.8,2.5, 5.3,1, 4.5,3,'gray',1);//beard
      drawShape('qua',x,y,z,4.1,1.3, 5.3,1, 5.25,.75, 3.9,.75,'gray',1);//crown
      drawShape('qua',x,y,z,4.5,1.5, 4.5,2, 4.7,2, 4.5,1.5,'rgba(0,0,0,.25)',1);//nose
      drawShape('qua',x,y,z,4.5,1.5, 4.9,1.45, 4.75,1.45, 4.7,1.45,'rgba(0,0,0,.25)',1);//eyesr
      drawShape('qua',x,y,z,4.5,1.5, 4.25,1.44, 4.3,1.5, 4.5,1.5,'rgba(0,0,0,.25)',1);//eyesl
      drawShape('qua',x,y,z,4.5,2, 4.7,2.2, 4.8,2, 4.6,2.1,'rgba(255,255,255,.25)',1);//mouth'
      drawShape('arc',x,y,z,4.25,1,.1,0,6,0,0,0,'gray',1);
      drawShape('arc',x,y,z,4.75,.9,.1,0,6,0,0,0,'gray',1);
      drawShape('arc',x,y,z,5.1,.87,.1,0,6,0,0,0,'gray',1);
      drawShape('qua',x,y,z,4.1,1.275, 4.75,1.1, 5.5,2.2, 4.6,1.25,'white',1);//hair back
      break;
    
    case 2.1:
      
      drawShape('tri',x,y,z, 3,0, 4,1, 5,1, 0,0,'lightblue',1);//veil top
      drawShape('tri',x,y,z, 7,0, 6,1, 5,1, 0,0,'lightblue',1);//veil top
      drawShape('rec',x,y,z, 4.2,1, 1.6,2.1, 0,0,0,0,'black',1);//face
      drawShape('qua',x,y,z, 4.5,3, 5,2.5, 5.5,3, 5,3.5,'rgb(174,111,77)',1);//neck
      drawShape('rec',x,y,z, 4.2,1, 1.6,1, 0,0,0,0,'rgb(185,122,87)',1);//face
      drawShape('tri',x,y,z, 4.23,1.9, 5.78,1.9, 5,3, 0,0,'rgb(185,122,87)',1);//face bottom
      drawShape('rec',x,y,z, 4,1, .2,2.2, 0,0,0,0,'lightblue',1);//veil l
      drawShape('rec',x,y,z, 4,1, .2,2.2, 0,0,0,0,'rgba(0,0,0,.1)',1);//veil l
      drawShape('rec',x,y,z, 5.8,1, .2,2.2, 0,0,0,0,'lightblue',1);//veil r
      drawShape('rec',x,y,z, 5.8,1, .2,2.2, 0,0,0,0,'rgba(0,0,0,.1)',1);//veil r
      drawShape('rec',x,y,z, 4,1, 2,.75, 0,0,0,0,'lightblue',1);//veil m
      drawShape('rec',x,y,z, 4,1, 2,.75, 0,0,0,0,'rgba(0,0,0,.1)',1);//veil m
      drawShape('tri',x,y,z, 5,1.75, 5.15,2.25, 5,2.25, 0,0,'rgba(0,0,0,.25)',1);//nose
      drawShape('tri',x,y,z, 4.7,2.5, 5.3,2.5, 5,2.59, 0,0,'rgba(255,0,0,.525)',1);//mouth
      drawShape('tri',x,y,z, 4.5,1.8, 4.9,1.8, 4.75,1.83, 0,0,'rgba(0,0,0,.25)',1);//left eye
      drawShape('tri',x,y,z, 5.5,1.8, 5.1,1.8, 5.25,1.83, 0,0,'rgba(0,0,0,.25)',1);//r eye
      drawShape('arc',x,y,z,5,    .85, .8,0,6,0,0,0,'lightblue',1);//bag
      drawShape('arc',x,y,z,4.95,.80,.75,0,6,0,0,0,'rgba(255,255,255,.25)',1);//bag
      drawShape('arc',x,y,z,4.9,  .85, .7,0,6,0,0,0,'rgba(255,255,255,.25)',1);//bag
      drawShape('arc',x,y,z,4.85, .85, .65,0,6,0,0,0,'rgba(255,255,255,.25)',1);//bag
      drawShape('arc',x,y,z,4.8,  .85, .6,0,6,0,0,0,'rgba(255,255,255,.25)',1);//bag

    break;
    case 0: //Fool monster 
      drawShape('qua',x,y,z, 6.5,8.5, .75,9.5, 6,4, 6.5,7.5,'cyan',1);//Cape Back
      drawShape('qua',x,y,z, 6.5,8.5, .75,9.5, 6,4, 6.5,7.5,'rgba(0,0,0,.8)',1);//Cape Back
      drawShape('qua',x,y,z, 2.75,7.5, 1.5,9.5, 1,9.5, 3.5,5.5,'rgb(185,122,87)',1);//left calf
      drawShape('qua',x,y,z, 5,5, 4,6, 5.5,8, 6.5,8,'gold',1);//right thigh
      //drawShape('qua',x,y,z,3.5,3.5,4.5,3,5,3,6,3.6,'darkblue',1);//head
      drawShape('qua',x,y,z,3.5,3.5,4.5,3,5,3,6,3.6,'white',1);//neck
      drawShape('qua',x,y,z,3.5,3.5,4.5,3,5,3,6,3.6,'white',1);//neck
      drawShape('qua',x,y,z, 3,3.4, 7,3.6, 1.2,9.3, .75,9.5,'cyan',1);//Cape Front
      drawShape('qua',x,y,z, 3,3.4, 7,3.6, 1.2,9.3, .75,9.5,'rgba(0,0,0,.7)',1);//body/left leg/cape?
      drawShape('qua',x,y,z, 7,3.6, 6.25,4, 7.5,6, 7.6,5.5,'white',1);//upper arm R
      //drawShape('qua',x,y,z, 7,3.6, 6.25,4, 7.5,6, 7.6,5.5,'rgba(0,0,0,.7)',1);//upper arm R
      drawShape('arc',x,y,z,2.8,2,.8,0,6,0,0,0,'darkred',1);//bag
      drawShape('arc',x,y,z,2.8,1.95,.75,0,6,0,0,0,'rgba(255,255,255,.15)',1);//bag
      drawShape('arc',x,y,z,9,1,.8,0,6,0,0,0,'gold',1);//bag
      drawShape('arc',x,y,z,8.95,.95,.75,0,6,0,0,0,'rgba(255,255,255,.15)',1);//bag
      drawShape('arc',x,y,z,8.9,1,.7,0,6,0,0,0,'rgba(255,255,255,.15)',1);//bag
      drawShape('arc',x,y,z,8.85,1,.65,0,6,0,0,0,'rgba(255,255,255,.15)',1);//bag
      drawShape('arc',x,y,z,8.8,1,.6,0,6,0,0,0,'rgba(255,255,255,.15)',1);//bag
      drawShape('qua',x,y,z, 9.1,5.7, 9.5,6, 9.25,6.25, 8.8,6,'rgb(185,122,87)',1);//rHand1
      drawShape('qua',x,y,z, 7.5,5.5, 7.5,6, 9,6, 9.1,5.7,'rgb(185,122,87)',1);//Forearm R
      drawShape('qua',x,y,z, 9.5,6.5, 2.5,1, 2.5,0.9, 9.5,6.4,'brown',1);////stick
      drawShape('qua',x,y,z, 9.5,6.5, 2.5,1, 2.5,0.9, 9.5,6.4,'rgba(0,0,0,.45)',1);////stick
      drawShape('qua',x,y,z, 9.1,5.7, 9.5,6, 9.25,6.25, 8.8,6,'rgb(185,122,87)',1);//rHand2
      drawShape('tri',x,y,z,2.75,1.25, 2.65,1, 3,1.25,0,0,'darkred',1);//knot
      drawShape('tri',x,y,z,2.75,1.25, 2.75,.8, 2.9,1.25,0,0,'darkred',1);//knot

      drawShape('qua',x,y,z,5,.9,3.5,1,4.5,3.5,7,2,'rgb(185,122,87)',1);//Head
      drawShape('tri',x,y,z,4.39,3.2, 5.2,3.1, 4.5,3.5,0,0,'rgba(0,0,0,.45)',1);//neck shadow

      drawShape('tri',x,y,z,4.75,2, 4.25,2.5, 4.5,2.5, 0,0,'rgba(0,0,0,.45)',1);//Nose
      drawShape('tri',x,y,z,4.25,2.75, 4.75,2.95, 4.8,2.87, 0,0,'rgba(255,0,0,.25)',1);//mouth
      drawShape('tri',x,y,z,5,2, 5.5,2.2, 5.45,2.12, 0,0,'rgba(0,0,0,.45)',1);//eye
      drawShape('tri',x,y,z,4,1.7, 4.5,1.9, 4.45,1.82, 0,0,'rgba(0,0,0,.45)',1);//eye
      drawShape('tri',x,y,z,3.5,1, 3.6,2, 5,1.4,0,0,'gold',1);//head
      drawShape('tri',x,y,z,5,1.4, 6.1,2.5, 7,2,0,0,'gold',1);//head
      drawShape('tri',x,y,z,3.5,1, 7,2, 5,.9,0,0,'cyan',1);//hat
      drawShape('tri',x,y,z,3.5,1, 7,2, 5,.9,0,0,'rgba(0,0,0,.7)',1);//hat
      drawShape('qua',x,y,z*1.4, 4.5,1.25, 5.5,.75, 5,1.25, 4.6,1.17,'darkred',1);//feather

      drawShape('qua',x,y,z, 6.5,8, 5,9.5, 4.5,9.5, 5.5,8,'rgb(185,122,87)',1);//right calf


      drawShape('qua',x,y,z, 3,3.42, 2.8,4.8, 1.75,6, 1.5,5.5,'white',1);//upper arm L

      drawShape('qua',x,y,z, 1.5,5.5, 1.4,7.1, 1.7,6.9, 2,5.5,'rgb(185,122,87)',1);//Forearm L
      drawShape('qua',x,y,z, 1.4,7.1, 1.4,7.5, 2,7, 1.7,6.8,'rgb(185,122,87)',1);//handL
      drawShape('qua',x,y,z, 1.4,7.5, 2,7.5, 2,7, 1.7,6.8,'rgb(185,122,87)',1);//handL
      drawShape('qua',x,y,z,4.5,9.5, 4.25,9.9, 7,9.9, 5,9.5,'gold',1);//rFoot
      drawShape('qua',x,y,z,1,9.5, .75,9.9, 3,9.9,1.5,9.5,'gold',1);//lfoot

      break;
    case 1: //Magician monster
      sx =-.6391*z;
      sy = -.30691*z;
      sz = 1.13;
      drawShape('qua',x+sx,y+sy,z*sz,  5.2,8.4,   5.1,8.8,    6.25,9,   5.75, 8.75,'white',1);//right foot
      drawShape('qua',x+sx,y+sy,z*sz,  4.8,8.4,   4.9,8.8,    3.75,9,   4.25, 8.75,'white',1);//left foot
      drawShape('qua',x+sx,y+sy,z*sz,  6,5.51,   6.1,8.5,    3.9,8.5,   4, 5.51,'white',1);//robe botto,
      let scaly = 0;
      let scalx = 1.26;
      let scalxt = 3.339;
      let scalxs = scalx;

      let scalz = .8;
      let scalzt = .6;
      let scalzs = scalz;
      let zratio = scalzt/scalzs;
      let xratio = (scalxt-scalxs)*zratio
      let scaly2 = 0;
      let scalx2 = 1.069*xratio
      let scalz2 = 1 * zratio;
      scalz = scalzt;
      scalx = scalxt;
      sx =-.6391*z;
      sy = -.30691*z;
      sz = 1.13;
      drawShape('qua',x+sx,y+sy,z*scalz*sz, 4.5+scalx,3.5+scaly, 4.5+scalx,4+scaly, 4.25+scalx,4+scaly,5+scalx,4.5+scaly,'rgb(185,122,87)',1);//neck left
      drawShape('qua',x+sx,y+sy,z*scalz*sz, 5.5+scalx,3.5+scaly, 5.5+scalx,4+scaly, 5.75+scalx,4+scaly,5+scalx,4.5+scaly,'rgb(185,122,87)',1);//neck right
      drawShape('qua',x+sx,y+sy,z*scalz*sz, 4.35+scalx,3.2+scaly, 5+scalx,3.9+scaly, 5.65+scalx,3.2+scaly, 5+scalx,4.52+scaly,'rgb(185,122,87)',1);//neck middle
      drawShape('qua',x+sx,y+sy,z*scalz*sz, 4.35+scalx,3.2+scaly, 5+scalx,3.9+scaly, 5.65+scalx,3.2+scaly, 5.02+scalx,4.52+scaly,'rgba(0,0,0,.2)',1);//neck middle
      drawShape('qua',x+sx,y+sy,z*scalz*sz, 5.02+scalx,2+scaly, 4.1+scalx,2.5+scaly, 4.25+scalx,3.25+scaly,5.02+scalx,3.9+scaly,'rgb(185,122,87)',1);//face left
      drawShape('qua',x+sx,y+sy,z*scalz*sz, 5.02+scalx,2+scaly, 5.9+scalx,2.5+scaly, 5.75+scalx,3.25+scaly,5+scalx,3.9+scaly,'rgb(185,122,87)',1);//face right

      drawShape('rec',x+sx,y+sy,z*scalz*sz, 4+scalx,2+scaly,2,.25,0,0,0,0,'white',1);//headband
      drawShape('qua',x+sx,y+sy,z*scalz*sz, 5+scalx,1.63+scaly, 4.3+scalx,1.75+scaly, 4+scalx,2+scaly,5+scalx,2+scaly,'rgb(0,0,0)',1);//top head
      drawShape('qua',x+sx,y+sy,z*scalz*sz, 5+scalx,1.63+scaly, 5.7+scalx,1.75+scaly, 6+scalx,2+scaly,5+scalx,2+scaly,'rgb(0,0,0)',1);//top head
      //DONOTDELETEdrawShape('qua',x,y,z,4,2.25, 3.9,3.5, 4.25,3,4.25,4.25,'rgb(119,43,79)',1);//lightning bolt

      drawShape('qua',x+sx,y+sy,z*scalz*sz, 4+scalx,2.25+scaly, 5+scalx,2.25+scaly, 4.25+scalx,2.5+scaly,4.25+scalx,4+scaly,'rgb(0,0,0)',1);//bangs left
      drawShape('qua',x+sx,y+sy,z*scalz*sz, 6+scalx,2.25+scaly, 5+scalx,2.25+scaly, 5.75+scalx,2.5+scaly,5.75+scalx,4+scaly,'rgb(0,0,0)',1);//bangs left

      drawShape('qua',x+sx,y+sy,z*scalz2*sz, 5.6+scalx2,3.2+scaly2,    5+scalx2,   3.6+scaly2,    6+scalx2,    6+scaly2, 5.75+scalx2, 3.2+scaly2,'white',1);//shirt right
      drawShape('qua',x+sx,y+sy,z*scalz2*sz,   5+scalx2, 3.6+scaly2,  4.5+scalx2,  3.25+scaly2, 4.25+scalx2,    6+scaly2,    6+scalx2,   6+scaly2,'white',1);//shirt left
      drawShape('qua',x+sx,y+sy,z*scalz2*sz, 5.6+scalx2,3.2+scaly2, 5.75+scalx2, 3.19+scaly2,    6+scalx2,  3.2+scaly2,  6.5+scalx2, 3.5+scaly2,'darkred',1);//right shoulder
      drawShape('rec',x+sx,y+sy,z*sz,4,4.65,2,.3,0,0,0,0,'rgba(0,0,0,.75)',0);

      drawShape('rec',x,y,z, 4,4.75, 2,.125, 0,0,0,0,'rgba(255,255,255,.75)',1);//belt/midsection
      drawShape('rec',x,y,z, 4,4.75, 2,.2499, 0,0,0,0,'rgba(255,255,255,.75)',1);//belt/midsection
      drawShape('rec',x,y,z, 4,4.875, 2,.2499, 0,0,0,0,'rgba(255,255,255,.75)',1);//belt/midsection
      drawShape('rec',x,y,z, 4,5, 2,.2499, 0,0,0,0,'rgba(255,255,255,.75)',1);//belt/midsection
      drawShape('rec',x,y,z, 4,5.125, 2,.2499, 0,0,0,0,'rgba(255,255,255,.75)',1);//belt/midsection
      drawShape('rec',x,y,z, 4,5.25, 2,.2499, 0,0,0,0,'rgba(255,255,255,.75)',1);//belt/midsection
      drawShape('rec',x,y,z, 4,5.375, 2,.2499, 0,0,0,0,'rgba(255,255,255,.75)',1);//belt/midsection
      drawShape('rec',x,y,z, 4,5.5, 2,.2499, 0,0,0,0,'rgba(255,255,255,.75)',1);//belt/midsection
      drawShape('rec',x,y,z, 4,5.625, 2,.2499, 0,0,0,0,'rgba(255,255,255,.75)',1);//belt/midsection
      drawShape('rec',x,y,z, 4,5.75, 2,.2499, 0,0,0,0,'rgba(255,255,255,.75)',1);//belt/midsection
      drawShape('rec',x,y,z, 4,5.875, 2,.2499, 0,0,0,0,'rgba(255,255,255,.75)',1);//belt/midsection
        
      drawShape('qua',x+sx,y+sy,z*scalz2*sz, 6.5+scalx2,3.5+scaly2,  6.9+scalx2,    4+scaly2,    8+scalx2,   5.5+scaly2,    8+scalx2,   9+scaly2,'darkred',1);//robeR Right
      drawShape('tri',x,y,z, 7.14,5.6,  7.5, 7.25,    7.44,   5,    8,   9,'rgba(0,0,0,.35)',1);//robeR Right

      drawShape('qua',x+sx,y+sy,z*scalz2*sz,5.75+scalx2,3.2+scaly2, 6.25+scalx2,    9+scaly2,    8+scalx2,    9+scaly2,  6.5+scalx2, 3.5+scaly2,'darkred',1);//robeR LEft
      drawShape('qua',x+sx,y+sy,z*sz, 4.65, 2.4,   4.5, 6.75,    3.5, 6.75,    3.5, 1.6,'darkred',1);//robeL LEft
      drawShape('qua',x,y,z,  4,2,   3.25,2,    3.33,7.2 ,  3.9, 3.9,'rgba(0,0,0,.5)',1);
      sx =-.6391*z;
      sy = -.6*z;
      sz = 1.13;
      drawShape('qua',x+sx,y+sy,z*sz,  3.99,2.3,   3.3,1.6,    3.16,1.9,   3.99, 3.66,'white',1);//left arm
      drawShape('qua',x+sx,y+sy,z*sz,  7.1,5,   7.25,5.3,    7.28,5.7,   6.9, 5.5,'white',1);//right arm
      drawShape('qua',x+sx,y+sy,z*sz, 3.3,1.61, 3,1.1, 2.9,1.2, 3.16,1.9,'rgb(185,122,87)',1);//left forearm
      drawShape('qua',x+sx,y+sy,z*sz, 3,1.15, 2.9,.95, 2.5,.95, 2.6,1.25,'rgb(185,122,87)',1);//left hand
      //wand
      sx = -.08 *z;
      drawShape('qua',x+sx,y,z,2.5,1.05, 2.3,0.25, 2.5,0, 2.7,.25,'rgba(85,43,0,1)',1);//handle
      drawShape('tri',x+sx,y,z,2.3,.25, 2.5,0, 2.7,.25, 0,0,'rgba(255,0,0,.2)',1);//gfl

      sx =-.6391*z;
      sy = -.6*z;
      sz = 1.13;
      drawShape('qua',x+sx,y+sy,z*sz, 2.5,.95, 2.6,1.25, 2.75,1.2, 2.75,1,'rgb(160,100,70)',1);//left fingers
      drawShape('qua',x+sx,y+sy,z*sz, 2.9,.95, 2.5,1, 2.75,1.05, 3,1.15,'rgb(170,110,70)',1);//left thumb
      drawShape('qua',x+sx,y+sy,z*sz, 7.25,5.3, 7.25,5.69, 8,6.22, 7.5,5.6,'rgb(185,122,87)',1);//left forearm
      drawShape('qua',x+sx,y+sy,z*sz, 7.5,5.6, 7.8,5.8, 7.4,6, 7.25,5.5,'rgb(185,122,87)',1);//left forearm
      drawShape('tri',x+sx,y+sy,z*sz, 7.45,5.93, 7.4,5.85, 7.5,5.875, 7.5,5.6,'rgb(165,102,67)',1);//left forearm
      sx =-.6391*z;
      sy = -1.3691*z;
      sz = 1.13;
      drawShape('tri',x+sx,y+sy,z*sz, 5,2.5, 5.15,2.85, 5,2.85, 0,0,'rgba(0,0,0,.25)',1);//nose
      drawShape('tri',x+sx,y+sy,z*sz, 4.8,3, 5.2,3, 5,3.05, 0,0,'rgba(255,0,0,.25)',1);//mouth
      drawShape('tri',x+sx,y+sy,z*sz, 4.6,2.55, 4.9,2.55, 4.75,2.58, 0,0,'rgba(0,0,0,.25)',1);//left eye
      drawShape('tri',x+sx,y+sy,z*sz, 5.4,2.55, 5.1,2.55, 5.25,2.58, 0,0,'rgba(0,0,0,.25)',1);//left eye
      sx =-.6391*z;
      sy = -1.2*z;
      sz = 1.13;
      drawShape('ell',x+sx,y+sy,z*sz,4.61,1.5, .4,.25,1,0,6,0,'white',1);//infinity symbol 
      drawShape('ell',x+sx,y+sy,z*sz,5.39,1.5, .4,.25,1,0,6,0,'white',1);
      drawShape('ell',x+sx,y+sy,z*sz,4.61,1.5, .38,.23,1,0,6,0,'rgba(0,6,13)',1);
      drawShape('ell',x+sx,y+sy,z*sz,5.39,1.5, .38,.23,1,0,6,0,'(rgba(0,6,13)',1);
      sx =8.5*z;
      sy = 6.5*z;
      sz = .13;
      //Stat symbols
      //sword
      drawShape('qua',x+sx,y+sy,z*sz,0,1, 2,3, 3,2, 1,0,'rgb(252,165,3)',1);//handle
      drawShape('qua',x+sx,y+sy,z*sz,0,1, 2,3, 3,2, 1,0,'rgb(252,165,3)',0);//handle
      drawShape('tri',x+sx,y+sy,z*sz,0,0, 1.4,0, 0,1.4 ,0,0,'darkgray',1);//pommel
      drawShape('tri',x+sx,y+sy,z*sz,0,0, 1.4,0, 0,1.4 ,0,0,'rgb(252,165,3)',0);//pommel
      drawShape('qua',x+sx,y+sy,z*sz,0,5, 1,5 ,5,1 ,5,0,'rgb(252,165,3)',1);//hilt guard
      drawShape('qua',x+sx,y+sy,z*sz,2,4, 8,9, 8,8, 4,4,'gray',1);//lhalf blade
      drawShape('qua',x+sx,y+sy,z*sz,4,2, 9,8, 8,8 ,4,4,'gray',1);//rhalf blade
      drawShape('tri',x+sx,y+sy,z*sz,4,4, 4,2, 2,4, 0,0,'gray',1);//near hilt center
      drawShape('qua',x+sx,y+sy,z*sz,9,8, 8,8, 8,9, 10,10,'gray',1);//sword tip
      drawShape('qua',x+sx,y+sy,z*sz,0,5, 1,5, 5,1 ,5,0,'rgb(252,165,3)',0);//hilt guard outline
      drawShape('arc',x+sx,y+sy,z*sz,3,3, .5,0, 6,0 ,0,0,'white',1);//hilt gem
      drawShape('arc',x+sx,y+sy,z*sz,3,3 ,.51,0, 6,0, 0,0,'white',0);
     //shield
      sx =4.7*z;
      sy = 3*z;
      sz = .06;
      drawShape('lin',x,y,z,5,3.1, 4.6,2.4, 0,0, 0,0,'gray',0);//string
      drawShape('lin',x,y,z,5,3.1, 5.41,2.4, 0,0, 0,0,'gray',0);//string
      drawShape('arc',x+sx,y+sy,z*sz,4.8,5,4.5,0,6,0,0,0,'rgba(40,20,0,1)',1);
      drawShape('arc',x+sx,y+sy,z*sz,5,5,4.5,0,6,0,0,0,'rgba(85,43,0,1)',1);
      drawShape('rec',x+sx,y+sy,z*sz,0.5,5,9,.11,0,0,0,0,'rgba(0,0,0,.35)',1)
      drawShape('rec',x+sx,y+sy,z*sz,.95,3,8.1,.11,0,0,0,0,'rgba(0,0,0,.35)',1)
      drawShape('rec',x+sx,y+sy,z*sz,1,7,8,.11,0,0,0,0,'rgba(0,0,0,.35)',1)
      drawShape('qua',x+sx,y+sy,z*sz,5,4,6,5,5,6,4,5,'green',1);
      drawShape('qua',x+sx,y+sy,z*sz,3,1, 7,1.1, 2.8,1.2, 8,2,'rgba(0,0,0,.35)',1);
      drawShape('qua',x+sx,y+sy,z*sz,3-1,1+1, 7-1,1.1+1, 2.8-1,1.2+1, 8-1,2+1,'rgba(0,0,0,.35)',1);
      drawShape('qua',x+sx,y+sy,z*sz,1+3,1+2, 1+7,1.1+2, 1+2.8,1.2+2, 1+8,2+2,'rgba(0,0,0,.35)',1);
      drawShape('qua',x+sx,y+sy,z*sz,1+3,1+5, 1+7,1.1+5, 1+2.8,1.2+5, 1+8,2+5,'rgba(0,0,0,.35)',1);
      drawShape('qua',x+sx,y+sy,z*sz,3,1+6, 7,1.1+6, 2.8,1.2+6, 8,2+6,'rgba(0,0,0,.35)',1);
      drawShape('qua',x+sx,y+sy,z*sz,3-1,1+7, 7-1,1.1+7, 2.8-1,1.2+7, 8-1,2+7,'rgba(0,0,0,.35)',1);
      //hourglass
      sx =4.875*z;
      sy = .75*z;
      sz = .025;
      drawShape('qua',x+sx,y+sy,z*sz,1,9,9,9,1,1,9,1,'white',1);//body
      drawShape('qua',x+sx,y+sy,z*sz,1,9,9,9,1,1,9,1,'black',0);//body
      drawShape('rec',x+sx,y+sy,z*sz,1,.75,8,.25,0,0,0,0,'rgb(128,64,0)',1);
      drawShape('rec',x+sx,y+sy,z*sz,1,9,8,.25,0,0,0,0,'rgb(128,64,0)',1);
      drawShape('tri',x+sx,y+sy,z*sz,2.5,9,7.5,9,5,8.5,0,0,'blue',1);//bottom sand
      drawShape('tri',x+sx,y+sy,z*sz,5,5,2.5,2.5,7.5,2.5,0,0,'blue',1);//top sand
      drawShape('qua',x+sx,y+sy,z*sz,5,5, 4.9,6, 5.1,7, 4.9,8.5,'blue',1);//drip sand
      break;
    case 2: //High Priestess monster
      drawShape('arc',x,y,z*.5,5,    .85, .8,0,6,0,0,0,'silver',1);//bag
      drawShape('arc',x,y,z*.5,4.95,.80,.75,0,6,0,0,0,'rgba(0,0,0,.25)',1);//bag
      drawShape('arc',x,y,z*.5,4.9,  .85, .7,0,6,0,0,0,'rgba(0,0,0,.25)',1);//bag
      drawShape('arc',x,y,z*.5,4.85, .85, .65,0,6,0,0,0,'rgba(0,0,0,.25)',1);//bag
      drawShape('arc',x,y,z*.5,4.8,  .85, .6,0,6,0,0,0,'rgba(0,0,0,.25)',1);//bag

      drawShape('ell',x,y,z,5,4.5, 2.45,4.5,1,0,6,0,'gray',1);//chair back
      drawShape('rec',x,y,z, 3,5.5, 4,3, 0,0,0,0,'rgba(0,0,0,.35)',1);//seat
      drawShape('rec',x,y,z, 3,9, 4,1, 0,0,0,0,'gray',1);//bottom of chair
      drawShape('rec',x,y,z, 2,2, 1,8, 0,0,0,0,'black',1);//black column
      drawShape('rec',x,y,z, 2,2, 1,8, 0,0,0,0,'gray',0);//black column
      drawShape('rec',x,y,z, 1.99,1.99, 1.02,8.01, 0,0,0,0,'white',0);
      drawShape('tri',x,y,z, 8,1, 8,2, 7,2, 0,0,'black',1);//column top left
      drawShape('tri',x,y,z, 8,1, 8,2, 7,2, 0,0,'gray',0);//column top left
      drawShape('tri',x,y,z, 2,1, 2,2, 3,2, 0,0,'white',1);//column top left
      drawShape('rec',x,y,z, 7,2, 1,8, 0,0,0,0,'white',1);//column white

      drawShape('tri',x,y,z, 3,0, 4,1, 5,1, 0,0,'lightblue',1);//veil top

      drawShape('tri',x,y,z, 7,0, 6,1, 5,1, 0,0,'lightblue',1);//veil top


      drawShape('rec',x,y,z, 4.2,1, 1.6,2.1, 0,0,0,0,'black',1);//face
      drawShape('qua',x,y,z, 4.5,3, 5,2.5, 5.5,3, 5,3.5,'rgb(174,111,77)',1);//neck
      drawShape('rec',x,y,z, 4.2,1, 1.6,1, 0,0,0,0,'rgb(185,122,87)',1);//face
      drawShape('tri',x,y,z, 4.23,1.9, 5.78,1.9, 5,3, 0,0,'rgb(185,122,87)',1);//face bottom
      drawShape('rec',x,y,z, 4,1, .2,2.2, 0,0,0,0,'lightblue',1);//veil l
      drawShape('rec',x,y,z, 4,1, .2,2.2, 0,0,0,0,'rgba(0,0,0,.1)',1);//veil l
      drawShape('rec',x,y,z, 5.8,1, .2,2.2, 0,0,0,0,'lightblue',1);//veil r
      drawShape('rec',x,y,z, 5.8,1, .2,2.2, 0,0,0,0,'rgba(0,0,0,.1)',1);//veil r

      drawShape('rec',x,y,z, 4,1, 2,.75, 0,0,0,0,'lightblue',1);//veil m
      drawShape('rec',x,y,z, 4,1, 2,.75, 0,0,0,0,'rgba(0,0,0,.1)',1);//veil m
      drawShape('qua',x,y,z, 3.8,3.3, 6.2,3.3, 5.8,5.55, 4.2,5.55,'cyan',1);//body
      drawShape('qua',x,y,z, 3.8,3.3, 6.2,3.3, 5.8,5.55, 4.2,5.55,'rgba(255,255,255,.85)',1);//body
      drawShape('qua',x,y,z, 4.2,5.55, 3,7, 3,9.8, 5.8,5.55,'lightblue',1);//skirt left
      drawShape('qua',x,y,z, 5.8,5.55, 7,7, 7,9.8, 3,9.8,'lightblue',1);//skirt right
      drawShape('qua',x,y,z, 4.2,5.55, 3,7, 3,9.8, 5.8,5.55,'rgba(0,0,0,.15)',1);//skirt left
      drawShape('qua',x,y,z, 5.8,5.55, 7,7, 7,9.8, 3,9.8,'rgba(0,0,0,.15)',1);//skirt right
      //drawShape('qua',x,y,z, 3.8,3.3, 3.95,4, 2.9,5.5, 2.5,5.5,'cyan',1);//left arm
      //drawShape('qua',x,y,z, 2.5,5.5, 5,6, 5,5.9, 2.8,5.2,'rgb(185,122,87)',1);//left forearm
      drawShape('qua',x,y,z, 6.2,3.3, 6.05,4, 7.1,5.5, 7.5,5.5,'cyan',1);//right arm

      drawShape('arc',x,y,z,5,    .85, .8,0,6,0,0,0,'lightblue',1);//bag
      drawShape('arc',x,y,z,4.95,.80,.75,0,6,0,0,0,'rgba(255,255,255,.25)',1);//bag
      drawShape('arc',x,y,z,4.9,  .85, .7,0,6,0,0,0,'rgba(255,255,255,.25)',1);//bag
      drawShape('arc',x,y,z,4.85, .85, .65,0,6,0,0,0,'rgba(255,255,255,.25)',1);//bag
      drawShape('arc',x,y,z,4.8,  .85, .6,0,6,0,0,0,'rgba(255,255,255,.25)',1);//bag

      //drawShape('qua',x,y,z,  6.2-.5,9.4,   6.1-.5,9.8,    6.5-.5,10,   6.75-.5, 9.75,'lightblue',1);//right foot
      //drawShape('qua',x,y,z,  4.2,9.4,   4.9-.5,9.8,    4.75-.5,10,   4.25-.5, 9.75,'lightblue',1);//left foot
      drawShape('qua',x,y,z, 4.5,3, 3.75,3.3, 3,7, 6,9.9,'lightblue',1);//robe left
      drawShape('qua',x,y,z, 4.5,3, 3.75,3.3, 3,7, 6,9.9,'rgba(0,0,0,.1)',1);//robe left
      drawShape('qua',x,y,z, 5.5,3, 6.25,3.3, 7,7, 4,9.3,'lightblue',1);//robe left
      drawShape('qua',x,y,z, 5.5,3, 6.25,3.3, 7,7, 4,9.3,'rgba(0,0,0,.15)',1);//robe left
      drawShape('ell',x,y,z,5,4.5, 1.05,1.5,1,0,6,0,'cyan',1);//chair back
      drawShape('ell',x,y,z,5,4.5, 1.05,1.5,1,0,6,0,'rgba(255,255,255,.85)',1);//chair back
      drawShape('ell',x,y,z,5,3.1, .55,.2,1,0,6,0,'rgb(175,112,77)',1);//clavicle
      drawShape('qua',x,y,z, 6.2,3.3, 6.05,4, 7.1,5.5, 7.5,5.5,'rgba(255,255,255,.85)',1);//right arm
      sx = 3.78*z;
      sy = 5*z;
      sz = .2;
			drawShape('qua',x+sx,y+sy,z*sz,0,7.5,10,7.5,7.5,2.5,2.5,2.5,'rgba(128,64,0,.85)',1);
			drawShape('qua',x+sx,y+sy,z*sz,.2,7.1,9.8,7.1,7.5,2.5,2.5,2.5,'rgba(255,255,128,1)',1);
			drawShape('lin',x+sx,y+sy,z*sz,5,7.5,5,2.5,0,0,0,0,'rgba(128,64,0,.85)',1);
			drawShape('arc',x+sx,y+sy,z*sz,3.75,3.8,1.75,1.25,1.75,0,0,0,'rgba(255,255,128,1)',1);
			drawShape('arc',x+sx,y+sy,z*sz,6.25,3.8,1.75,1.25,1.75,0,0,0,'rgba(255,255,128,1)',1);
			drawShape('arc',x+sx,y+sy,z*sz,2.5,7.9,2.4,1.1,1.9,0,0,0,'rgba(248,179,16,.85)',1);
			drawShape('arc',x+sx,y+sy,z*sz,7.5,7.9,2.4,1.1,1.9,0,0,0,'rgba(248,179,16,.85)',1);

      drawShape('qua',x,y,z, 5.5,8, 6.5,7.3, 6.5,6, 4.5,7.5,'rgba(0,0,0,.09)',1);//right forearm
      drawShape('qua',x,y,z, 5,6, 5.5,5.5, 6.1,5.4, 6.13,5.6,'rgb(185,122,87)',1);//right forearm

      drawShape('qua',x,y,z, 4,4, 4.5,6, 5.6,8, 3,9.9,'lightblue',1);//robe left
      drawShape('qua',x,y,z, 5.5,5.5, 5.25,5.75, 5.5,6, 5.7,5.9,'rgb(185,122,87)',1);//right forearm
      drawShape('arc',x,y,z,5,6,1,0,6,0,0,0,'rgba(255,255,255,.25)',1);//book glow
      drawShape('qua',x,y,z, 4,4, 4.5,6, 5.6,8, 3,9.9,'lightblue',1);//robe left
      drawShape('qua',x,y,z, 6.21,3.28, 5.9,4, 6.5,8.5, 7.5,5.5,'lightblue',1);//robe left

      drawShape('tri',x,y,z, 5,1.75, 5.15,2.25, 5,2.25, 0,0,'rgba(0,0,0,.25)',1);//nose
      drawShape('tri',x,y,z, 4.7,2.5, 5.3,2.5, 5,2.59, 0,0,'rgba(255,0,0,.525)',1);//mouth
      drawShape('tri',x,y,z, 4.5,1.8, 4.9,1.8, 4.75,1.83, 0,0,'rgba(0,0,0,.25)',1);//left eye
      drawShape('tri',x,y,z, 5.5,1.8, 5.1,1.8, 5.25,1.83, 0,0,'rgba(0,0,0,.25)',1);//r eye
      drawShape('qua',x,y,z,  4.2,8.8,   4.4,9.1,    4.3,9.4,   3.4, 10,'lightblue',1);//left foot
            drawShape('qua',x,y,z,  6.2-.5,9.4,   6.1-.5,9.8,    6.5-.5,10,   6.75-.5, 9.75,'lightblue',1);//right foot

      break;
    case 3: //Empress monster
      //legs red boots
      sx = -.5*z; 
      sy = -.1*z;
      sz = 1.1;
      drawShape('qua',x+sx,y+sy,z*sz, 5.5,7, 5.8,8.5, 6,8, 6,6.5,'rgba(255,0,0,.65)',1);
      drawShape('qua',x+sx,y+sy,z*sz, 4,7, 4,8.5, 4.25,8.3, 4.5,7,'rgba(255,0,0,.65)',1);
      drawShape('qua',x+sx,y+sy,z*sz, 4,8.25, 3.6,9, 4,8.8, 4.35,8.23,'rgba(230,0,0,.65)',1);
      drawShape('qua',x+sx,y+sy,z*sz, 6,8, 6.3,9, 6,9, 5.7,8.5,'rgba(230,0,0,.65)',1);
      //Empress upper
      sz = .8;
      sx = 1*z;
      sy = .0*z;
      drawShape('qua',x+sx,y+sy,z*sz, 5.25,3, 5.5,3.5, 5,4, 4.5,2.5,'rgb(135,82,47)',1);//neck
      drawShape('qua',x+sx,y+sy,z*sz, 4.5,2.5, 5.5,3.5, 5,4, 4.5,2.5,'rgb(165,102,67)',1);//neckL

      drawShape('qua',x+sx,y+sy,z*sz,4,1.8, 3.9,3, 4.25,3.25, 4.25,1.75,'gold',1);//bangs left
      drawShape('qua',x+sx,y+sy,z*sz, 5.25,3.5, 4.15,2.25, 5,1.3, 6,2.5,'rgb(185,122,87)',1);//face
      
      drawShape('tri',x+sx,y+sy,z*sz, 5.45,2.2, 5.4,2.8, 5.6,2.9, 0,0,'rgba(0,0,0,.2)',1);//nose
      drawShape('tri',x+sx,y+sy,z*sz, 5,2.2, 5.4,2.15, 5.2,2.3, 0,0,'rgba(0,0,0,.25)',1);//eye
      drawShape('tri',x+sx,y+sy,z*sz, 5.5,2.15, 5.9,2, 5.7,2.3, 0,0,'rgba(0,0,0,.25)',1);//eye
     
      drawShape('tri',x+sx,y+sy,z*sz, 5.25,3, 5.6,2.95, 5.4,3.075, 0,0,'rgba(255,0,0,.25)',1);//mouth
      drawShape('qua',x+sx,y+sy,z*sz,5,1.3, 4.2,1.75, 4,2.2, 5,1.85,'gold',1);//hair
      drawShape('qua',x+sx,y+sy,z*sz,5,1.3, 5.8,1.75, 6,2, 5,1.85,'gold',1);
       
      drawShape('qua',x+sx,y+sy,z*sz,5.55,1.9, 6,2.5, 5.8,3.4, 6,3.5,'gold',1);
      drawShape('qua',x+sx,y+sy,z*sz,5.55,1.9, 6,2.5, 5.8,3.4, 6,2,'gold',1);
      //drawShape('qua',x,y,z,4.25,1.9, 3.8,2.5, 4,3.4, 3.8,3.5,'gold',1);
      drawShape('qua',x+sx,y+sy,z*sz,5,1.8, 4.28,2.07, 4.8,3.4, 4.5,3.5,'gold',1);
      drawShape('qua',x+sx,y+sy,z*sz,4.28,2.07, 3.85,2.5, 4.05,3.4, 3.85,3.5,'rgba(0,0,0,.25)',1);
   
      drawShape('qua',x+sx,y+sy,z*sz, 3.9,6, 3,4, 3.5,4, 4,5,'rgba(255,255,255,.65)',1);//dress left forearm
        
      drawShape('qua',x+sx,y+sy,z*sz, 3,4, 3.5,4, 3.4,3.7, 3,3.5,'rgb(185,122,87)',1);//left hand
      drawShape('qua',x+sx,y+sy,z*sz, 3.4,4, 2.7,2, 2.4,2, 3.2,4.1,'yellow',1);//scepter
      drawShape('qua',x+sx,y+sy,z*sz, 3,4, 2.6,3.4, 3,3.5, 3.5,3.4,'rgb(165,102,67)',1);//left hand
        
      drawShape('tri',x+sx,y+sy,z*sz, 2.6,3.4, 3.5,3.4, 3,3.5, 2.75,1,'rgb(160,100,70)',1);//left fingers
      drawShape('qua',x+sx,y+sy,z*sz, 3.4,3.45, 3.25,3.5, 3.25,3.55, 3.4,3.7,'rgb(170,110,70)',1);//left thumb

      drawShape('qua',x+sx,y+sy,z*sz, 4.5,4, 4.5,5.5, 3.9,6, 4,4,'rgba(255,255,255,.65)',1);//dress left arm
      drawShape('qua',x+sx,y+sy,z*sz, 5,4, 5.5,7, 4.5,5.5, 4.5,4,'rgba(255,255,255,.65)',1);//dress left mid
      drawShape('qua',x+sx,y+sy,z*sz, 5.5,3.5, 6,3.5, 6.5,3.75, 7.5,5,'rgba(255,255,255,.75)',1);//dress right shoulder n tricep
      drawShape('qua',x+sx,y+sy,z*sz, 6.5,5, 6,6, 7,9.5, 3,9.5,'rgba(255,255,255,1)',1);//dress bottom right n forearm
      drawShape('qua',x+sx,y+sy,z*sz, 7.5,5, 6,6, 7,9.5, 3,9.5,'rgba(0,0,0,.25)',1);//dress bottom right n forearm
      drawShape('qua',x+sx,y+sy,z*sz, 5.5,3.5, 5,4, 5,7.5, 7.5,5,'rgba(255,255,255,.75)',1);//dress collarR
      drawShape('qua',x+sx,y+sy,z*sz, 5,4, 4.8,3.4, 4.5,3.5, 4,4,'rgba(255,255,255,.75)',1);//dress collarL
      drawShape('qua',x+sx,y+sy,z*sz, 4.5,4, 4.25,4.5, 4.25,5, 5,5.75,'rgba(255,255,255,.65)',1);//bl
      drawShape('qua',x+sx,y+sy,z*sz, 5.5,4, 5.75,4.5, 5.75,5, 5,5.75,'rgba(255,255,255,.65)',1);//br
      drawShape('qua',x+sx,y+sy,z*sz, 5.5,4, 5.05,4.5, 5.05,5, 5.8,5.75,'rgba(255,255,255,.65)',1);//brmain
      sx = -1.5*z;
      sy = 1*z;
      sz = .5;
      //sphere
      drawShape('arc',x+sx,y+sy,z*sz,9,1,.8,0,6,0,0,0,'gold',1);//bag
      drawShape('arc',x+sx,y+sy,z*sz,8.95,.95,.75,0,6,0,0,0,'rgba(255,255,255,.15)',1);//bag
      drawShape('arc',x+sx,y+sy,z*sz,8.9,1,.7,0,6,0,0,0,'rgba(255,255,255,.15)',1);//bag
      drawShape('arc',x+sx,y+sy,z*sz,8.85,1,.65,0,6,0,0,0,'rgba(255,255,255,.15)',1);//bag
      drawShape('arc',x+sx,y+sy,z*sz,8.8,1,.6,0,6,0,0,0,'rgba(255,255,255,.15)',1);//bag
      //heartshield
      sx = 3.7*z;
      sy = 3.8*z;
      sz = .25;
      drawShape('tri',x+sx,y+sy,z*sz,0,6.5, 12.6,12.6, 11.25,0, 0,0,'gray',1);
			drawShape('arc',x+sx,y+sy,z*sz,2.25,3.7,3.63,0,6,0,0,0,'gray',1);
			drawShape('arc',x+sx,y+sy,z*sz,7.75,1,3.63,0,6,0,0,0,'gray',1);
			drawShape('arc',x+sx,y+sy,z*sz,5,7,3,3,0,0,0,0,'gray',1);

      drawShape('arc',x,y,z,5,4.4,.4,0,6,0,0,0,'black',1);//circle in shield
      drawShape('arc',x,y,z,5,4.4,.36,0,6,0,0,0,'green',1);//circle in shield
      sx = 0;
      sy = 0;
      drawShape('qua',x+sx,y+sy,z,5.2,4.7, 5.28,4.69, 5.9,5.5, 5.8,5.5,'black',1);//////////cross
      drawShape('qua',x+sx,y+sy,z,5.23,5.5, 5.25,5.5, 6,5, 5.9,5,'black',1);//////////cross
            
      //star crown
      sz = .03;
      sx = 4.85*z;
      sy = 0.09*z;
      drawShape('tri',x+sx,y+sy,z*sz,5,0,.5,7.5,9.5,7.5,0,0,'white',1);//topmid
      drawShape('tri',x+sx,y+sy,z*sz,5,10,.5,2.5,9.5,2.5,0,0,'white',1);

      sx = 5.1*z;
      sy = 0.3*z;
      drawShape('tri',x+sx,y+sy,z*sz,5,0,.5,7.5,9.5,7.5,0,0,'white',1);//topr1
      drawShape('tri',x+sx,y+sy,z*sz,5,10,.5,2.5,9.5,2.5,0,0,'white',1);
        
      sx = 5.4*z;
      sy = 0.5*z;
      drawShape('tri',x+sx,y+sy,z*sz,5,0,.5,7.5,9.5,7.5,0,0,'white',1);//topr2
      drawShape('tri',x+sx,y+sy,z*sz,5,10,.5,2.5,9.5,2.5,0,0,'white',1);

      sx = 5.13*z;
      sy = 0.6*z;
      drawShape('tri',x+sx,y+sy,z*sz,5,0,.5,7.5,9.5,7.5,0,0,'white',1);//botr1
      drawShape('tri',x+sx,y+sy,z*sz,5,10,.5,2.5,9.5,2.5,0,0,'white',1);

      sx = 5.65*z;
      sy = 0.7*z;
      drawShape('tri',x+sx,y+sy,z*sz,5,0,.5,7.5,9.5,7.5,0,0,'white',1);//topr3
      drawShape('tri',x+sx,y+sy,z*sz,5,10,.5,2.5,9.5,2.5,0,0,'white',1);

      sx = 4.58*z;
      sy = 0.6*z;
      drawShape('tri',x+sx,y+sy,z*sz,5,0,.5,7.5,9.5,7.5,0,0,'white',1);//botl1
      drawShape('tri',x+sx,y+sy,z*sz,5,10,.5,2.5,9.5,2.5,0,0,'white',1);

      sx = 5.8*z;
      sy = 1*z;
      drawShape('tri',x+sx,y+sy,z*sz,5,0,.5,7.5,9.5,7.5,0,0,'white',1);//topr4
      drawShape('tri',x+sx,y+sy,z*sz,5,10,.5,2.5,9.5,2.5,0,0,'white',1);

      sx = 4*z;
      sy = 0.7*z;
      drawShape('tri',x+sx,y+sy,z*sz,5,0,.5,7.5,9.5,7.5,0,0,'white',1);//topl3
      drawShape('tri',x+sx,y+sy,z*sz,5,10,.5,2.5,9.5,2.5,0,0,'white',1);

      sx = 4.6*z;
      sy = 0.3*z;
      drawShape('tri',x+sx,y+sy,z*sz,5,0,.5,7.5,9.5,7.5,0,0,'white',1);//topl1
      drawShape('tri',x+sx,y+sy,z*sz,5,10,.5,2.5,9.5,2.5,0,0,'white',1);

      sx = 4.3*z;
      sy = 0.5*z;
      drawShape('tri',x+sx,y+sy,z*sz,5,0,.5,7.5,9.5,7.5,0,0,'white',1);//topl2
      drawShape('tri',x+sx,y+sy,z*sz,5,10,.5,2.5,9.5,2.5,0,0,'white',1);

      sx = 3.9*z;
      sy = 1*z;
      drawShape('tri',x+sx,y+sy,z*sz,5,0,.5,7.5,9.5,7.5,0,0,'white',1);//topl4
      drawShape('tri',x+sx,y+sy,z*sz,5,10,.5,2.5,9.5,2.5,0,0,'white',1);

      sx = 4.85*z;
      sy = 0.4*z;
      drawShape('tri',x+sx,y+sy,z*sz,5,0,.5,7.5,9.5,7.5,0,0,'white',1);//starmid
      drawShape('tri',x+sx,y+sy,z*sz,5,10,.5,2.5,9.5,2.5,0,0,'white',1);
          

      //leaf crown
      sz = 0.03;
      sx = 4.9*z;
      sy = .9*z;
      drawShape('qua',x+sx,y+sy,z*sz,0,10, 1,4, 3.5,1.5, 10,0,'green',1);
      drawShape('qua',x+sx,y+sy,z*sz,10,0, 9,6, 6.5,8.5, 0,10,'green',1);
      drawShape('qua',x+sx,y+sy,z*sz,0,10, 1,4, 3.5,1.5, 10,0,'rgba(0,0,0,.45)',0);
      drawShape('qua',x+sx,y+sy,z*sz,0,10, 4,4, 5,3, 10,0,'rgba(0,0,0,.15)',1);
      sx = 5.2*z;
      sy = 1*z;
      drawShape('qua',x+sx,y+sy,z*sz,0,10, 1,4, 3.5,1.5, 10,0,'green',1);
      drawShape('qua',x+sx,y+sy,z*sz,10,0, 9,6, 6.5,8.5, 0,10,'green',1);
      drawShape('qua',x+sx,y+sy,z*sz,0,10, 1,4, 3.5,1.5, 10,0,'rgba(0,0,0,.45)',0);
      drawShape('qua',x+sx,y+sy,z*sz,0,10, 4,4, 5,3, 10,0,'rgba(0,0,0,.15)',1);
      sx = 5.5*z;
      sy = 1.1*z;
      drawShape('qua',x+sx,y+sy,z*sz,0,10, 1,4, 3.5,1.5, 10,0,'green',1);
      drawShape('qua',x+sx,y+sy,z*sz,10,0, 9,6, 6.5,8.5, 0,10,'green',1);
      drawShape('qua',x+sx,y+sy,z*sz,0,10, 1,4, 3.5,1.5, 10,0,'rgba(0,0,0,.45)',0);
      drawShape('qua',x+sx,y+sy,z*sz,0,10, 4,4, 5,3, 10,0,'rgba(0,0,0,.15)',1);
      sx = 5.7*z;
      sy = 1.3*z;
      drawShape('qua',x+sx,y+sy,z*sz,0,10, 1,4, 3.5,1.5, 10,0,'green',1);
      drawShape('qua',x+sx,y+sy,z*sz,10,0, 9,6, 6.5,8.5, 0,10,'green',1);
      drawShape('qua',x+sx,y+sy,z*sz,0,10, 1,4, 3.5,1.5, 10,0,'rgba(0,0,0,.45)',0);
      drawShape('qua',x+sx,y+sy,z*sz,0,10, 4,4, 5,3, 10,0,'rgba(0,0,0,.15)',1);
      sx = 4.5*z;
      sy = 1*z;
      drawShape('qua',x+sx,y+sy,z*sz,0,10, 1,4, 3.5,1.5, 10,0,'green',1);
      drawShape('qua',x+sx,y+sy,z*sz,10,0, 9,6, 6.5,8.5, 0,10,'green',1);
      drawShape('qua',x+sx,y+sy,z*sz,0,10, 1,4, 3.5,1.5, 10,0,'rgba(0,0,0,.45)',0);
      drawShape('qua',x+sx,y+sy,z*sz,0,10, 4,4, 5,3, 10,0,'rgba(0,0,0,.15)',1);
      sx = 4.2*z;
      sy = 1.2*z;
      drawShape('qua',x+sx,y+sy,z*sz,0,10, 1,4, 3.5,1.5, 10,0,'green',1);
      drawShape('qua',x+sx,y+sy,z*sz,10,0, 9,6, 6.5,8.5, 0,10,'green',1);
      drawShape('qua',x+sx,y+sy,z*sz,0,10, 1,4, 3.5,1.5, 10,0,'rgba(0,0,0,.45)',0);
      drawShape('qua',x+sx,y+sy,z*sz,0,10, 4,4, 5,3, 10,0,'rgba(0,0,0,.15)',1);
      sx = 43.91*z;
      sy = 1.3*z;
      drawShape('qua',x+sx,y+sy,z*sz,0,10, 1,4, 3.5,1.5, 10,0,'green',1);
      drawShape('qua',x+sx,y+sy,z*sz,10,0, 9,6, 6.5,8.5, 0,10,'green',1);
      drawShape('qua',x+sx,y+sy,z*sz,0,10, 1,4, 3.5,1.5, 10,0,'rgba(0,0,0,.45)',0);
      drawShape('qua',x+sx,y+sy,z*sz,0,10, 4,4, 5,3, 10,0,'rgba(0,0,0,.15)',1);
      //leaf crown bot
      sz = 0.03;
      sx = 4.8*z;
      sy = 1.1*z;
      drawShape('qua',x+sx,y+sy,z*sz,0,10, 1,4, 3.5,1.5, 10,0,'green',1);
      drawShape('qua',x+sx,y+sy,z*sz,10,0, 9,6, 6.5,8.5, 0,10,'green',1);
      drawShape('qua',x+sx,y+sy,z*sz,0,10, 1,4, 3.5,1.5, 10,0,'rgba(0,0,0,.45)',0);
      drawShape('qua',x+sx,y+sy,z*sz,0,10, 4,4, 5,3, 10,0,'rgba(0,0,0,.15)',1);
      sx = 5*z;
      sy = 1.1*z;
      drawShape('qua',x+sx,y+sy,z*sz,0,10, 1,4, 3.5,1.5, 10,0,'green',1);
      drawShape('qua',x+sx,y+sy,z*sz,10,0, 9,6, 6.5,8.5, 0,10,'green',1);
      drawShape('qua',x+sx,y+sy,z*sz,0,10, 1,4, 3.5,1.5, 10,0,'rgba(0,0,0,.45)',0);
      drawShape('qua',x+sx,y+sy,z*sz,0,10, 4,4, 5,3, 10,0,'rgba(0,0,0,.15)',1);

      sx = 5.3*z;
      sy = 1.1*z;
      drawShape('qua',x+sx,y+sy,z*sz,0,10, 1,4, 3.5,1.5, 10,0,'green',1);
      drawShape('qua',x+sx,y+sy,z*sz,10,0, 9,6, 6.5,8.5, 0,10,'green',1);
      drawShape('qua',x+sx,y+sy,z*sz,0,10, 1,4, 3.5,1.5, 10,0,'rgba(0,0,0,.45)',0);
      drawShape('qua',x+sx,y+sy,z*sz,0,10, 4,4, 5,3, 10,0,'rgba(0,0,0,.15)',1);

      sx = 5.5*z;
      sy = 1.2*z;
      drawShape('qua',x+sx,y+sy,z*sz,0,10, 1,4, 3.5,1.5, 10,0,'green',1);
      drawShape('qua',x+sx,y+sy,z*sz,10,0, 9,6, 6.5,8.5, 0,10,'green',1);
      drawShape('qua',x+sx,y+sy,z*sz,0,10, 1,4, 3.5,1.5, 10,0,'rgba(0,0,0,.45)',0);
      drawShape('qua',x+sx,y+sy,z*sz,0,10, 4,4, 5,3, 10,0,'rgba(0,0,0,.15)',1);

      sx = 4.7*z;
      sy = 1*z;
      drawShape('qua',x+sx,y+sy,z*sz,0,10, 1,4, 3.5,1.5, 10,0,'green',1);
      drawShape('qua',x+sx,y+sy,z*sz,10,0, 9,6, 6.5,8.5, 0,10,'green',1);
      drawShape('qua',x+sx,y+sy,z*sz,0,10, 1,4, 3.5,1.5, 10,0,'rgba(0,0,0,.45)',0);
      drawShape('qua',x+sx,y+sy,z*sz,0,10, 4,4, 5,3, 10,0,'rgba(0,0,0,.15)',1);

      sx = 4.4*z;
      sy = 1.2*z;
      drawShape('qua',x+sx,y+sy,z*sz,0,10, 1,4, 3.5,1.5, 10,0,'green',1);
      drawShape('qua',x+sx,y+sy,z*sz,10,0, 9,6, 6.5,8.5, 0,10,'green',1);
      drawShape('qua',x+sx,y+sy,z*sz,0,10, 1,4, 3.5,1.5, 10,0,'rgba(0,0,0,.45)',0);
      drawShape('qua',x+sx,y+sy,z*sz,0,10, 4,4, 5,3, 10,0,'rgba(0,0,0,.15)',1);

      sx = 4*z;
      sy = 1.3*z;
      drawShape('qua',x+sx,y+sy,z*sz,0,10, 1,4, 3.5,1.5, 10,0,'green',1);
      drawShape('qua',x+sx,y+sy,z*sz,10,0, 9,6, 6.5,8.5, 0,10,'green',1);
      drawShape('qua',x+sx,y+sy,z*sz,0,10, 1,4, 3.5,1.5, 10,0,'rgba(0,0,0,.45)',0);
      drawShape('qua',x+sx,y+sy,z*sz,0,10, 4,4, 5,3, 10,0,'rgba(0,0,0,.15)',1);
      break;
    case 4: //Emperor monster
    drawShape('ell',x,y,z,4.59,.8,.65,.5,1,0,6,0,'yellow',1);
    drawShape('arc',x,y,z,4,1,.1,0,6,0,0,0,'red',1);
    drawShape('arc',x,y,z,5.25,.85,.1,0,6,0,0,0,'red',1);
    drawShape('qua',x,y,z,5.3,1, 6,2.5, 5.5,2.5, 5,1,'rgba(255,255,255,.9)',1);//hair back
 
    sx = .15*z;
    sy = .49*z;
    sz=.95;
    drawShape('qua',x+sx,y+sy,z*sz,4.7,5.5,/*tr*/ 3.5,7.5,/*br*/ 4.4,7.7,/*bl*/ 5,6.5,'lightgray',1);//l-thigh
			drawShape('qua',x+sx,y+sy,z*sz,4.5,9.1,/*tr*/4.5,9.6,/*br*/ 2,9.6,/*l*/4.5,8.6,/*tl*/'darkgray',1);//l-foot
			drawShape('qua',x+sx,y+sy,z*sz,4.5,9.5,/*br*/ 4.5,7.7,/*tr*/ 3.3,7.3,/*tl*/ 3.9,9,/*bl*/'darkgray',1);//l-calf
			drawShape('qua',x+sx,y+sy,z*sz,4.5,9.5,/*br*/ 4.5,7.7,/*tr*/ 3.3,7.3,/*tl*/ 3.9,9,/*b*/'gray',0);//l-calf
			drawShape('arc',x+sx,y+sy,z*sz,4.25,2.65, .63,0, 3,0, 0,0,'darkgray',1);//l-shoulder
			drawShape('arc',x+sx,y+sy,z*sz,4.25,2.65, .63,0, 3,0, 0,0,'gray',0);//l-shoulder-shadow
			drawShape('ell',x+sx,y+sy,z*sz,5.15,3.6,1.15,1.75,0,0,6,0,'lightgray',1);//torso
			drawShape('qua',x+sx,y+sy,z*sz,4.7,2,5.5,1.5,6,2.5,4.25,2.5,'darkgray',1);//neck
			//drawShape('arc',x+sx,y+sy,z*sz,5,1,1,0,6,0,0,0,'lightgray',1);//head
			//drawShape('tri',x+sx,y+sy,z*sz,3.5,1.5,4.3,.25,4.9,2,0,0,'lightgray',1);//helm nose
			drawShape('qua',x+sx,y+sy,z*sz,4.5,5.5,/*tl*/6,4.5,/*tr*/ 6.5,7.7,/*br*/ 5.8,8,/*bl*/ 'lightgray',1);//r-thigh
			drawShape('qua',x+sx,y+sy,z*sz,5.5,8,/*tl*/6.25,7.25,/*tm*/6.75,8,/*tr*/ 6.25,9.5,/*b*/'darkgray',1);//r-calf
			drawShape('qua',x+sx,y+sy,z*sz,5.5,8,/*tl*/6.25,7.25,/*tm*/6.75,8,/*tr*/ 6.25,9.5,/**/'gray',0);//r-calf
			drawShape('qua',x+sx,y+sy,z*sz,6.25,9,/*t*/5.6,9.6,/*bl*/6.25,10,/*bm*/ 6.9,9.6,/*br*/'darkgray',1);//r-foot
			//drawShape('tri',x+sx,y+sy,z*sz,6.25,9.5,/*t*/5.75,10,/*bl*/6.75,10,/*br*/ 0,0,'gray',1);//r-toe
			drawShape('qua',x+sx,y+sy,z*sz,6.2,4.3,7.25,7.25,5.1,6.3,4.75,5.25,'darkgray',1);//hip armor
			drawShape('qua',x+sx,y+sy,z*sz,6.2,4.3,7.25,7.25,5.1,6.3,4.75,5.25,'gray',0);//hip armor
			drawShape('qua',x+sx,y+sy,z*sz,4.5,7, 5.2,5, 4.5,5.2, 4.2,5,'darkgray',1);//groin armor
			drawShape('qua',x+sx,y+sy,z*sz,4.5,7, 5.2,5, 4.5,5.2, 4.2,5,'gray',0);//groin armor
			//drawShape('qua',x+sx,y+sy,z*sz,2.75,1.75, 4.5,2.75, 4.5,5.8, 2.75,4.8,'gray',1);//shield top
			//drawShape('tri',x+sx,y+sy,z*sz,2.75,4.8,4.5,5.8,3.5,7.5,0,0,'gray',1);//shield bot
			//drawShape('lin',x+sx,y+sy,z*sz,3.5,7.6,3.45,2.1,0,0,0,0,'blue',0);//shield cross |
			//drawShape('lin',x+sx,y+sy,z*sz,2.75,4,4.5,5,0,0,0,0,'blue',0);//shield cross--
			drawShape('tri',x+sx,y+sy,z*sz,/*tl*/ 4.45,3.55, /*tr*/3.7,2.5, /*br*/2.3,4, 0,0,'lightgray',1);//l-arm
		  

			drawShape('tri',x+sx,y+sy,z*sz,/*tl*/ 5.55,3.55, /*tr*/6.3,2.5, /*br*/7.7,4, 0,0,'lightgray',1);//r-arm
			drawShape('tri',x+sx,y+sy,z*sz,/*tl*/ 5.6,3.5, /*tr*/6.3,2.5, /*br*/7.7,4, 0,0,'gray',0);//r-arm

			drawShape('qua',x+sx,y+sy,z*sz,5.9,5.5, 5.9,5.7, 7.2,6.1, 7.2,5.7,'gold',1);//sword-hilt
			drawShape('arc',x+sx,y+sy,z*sz,6.2,5.75,.4,0,3,0,0,0,'darkgray',1);//r-hand
			//drawShape('tri',x+sx,y+sy,z*sz,1,4.6, 5.9,5.35, 6.1,6.15,0,0,'white',1);//sword-blade
			//drawShape('qua',x+sx,y+sy,z*sz,5.8,4.5,5.9,5.7,6.3,6.8,6.4,6,'gold',1);//sword-crossguard
			drawShape('arc',x+sx,y+sy,z*sz,6,3, .63,0, 3,0, 0,0,'darkgray',1);//r-shoulder
			drawShape('arc',x+sx,y+sy,z*sz,6,3, .63,0, 3,0, 0,0,'gray',0);//r-shoulder
			//drawShape('qua',x+sx,y+sy,z*sz,5.8,.7, 3.5,.8, 3.7,.5, 3.85,.6,'black',1);//helmet visor
            drawShape('qua',x+sx,y+sy,z*sz,4,2, 3.5,2.5, 6.5,7.2, 4.2,5,'rgba(255,0,0,.4)',1);//robeLShoulder
        drawShape('qua',x+sx,y+sy,z*sz,4,2, 6.5,2.5, 3.5,7.2, 6.5,5,'rgba(255,0,0,.4)',1);//robeLShoulder
              drawShape('qua',x+sx,y+sy,z*sz,4,2, 3.5,2.5, 6.5,7.2, 4.2,5,'rgba(255,0,0,.4)',1);//robeLShoulder
        drawShape('qua',x+sx,y+sy,z*sz,4,2, 4,4, 3,8, 7.25,7.25,'rgba(255,0,0,.8)',1);//robeLShoulder
              drawShape('qua',x+sx,y+sy,z*sz,4,2, 3.5,2.5, 6.5,7.2, 4.2,5,'rgba(255,0,0,.4)',1);//robeLShoulder
        drawShape('qua',x+sx,y+sy,z*sz,6,2.1, 7.5,3.5, 7.25,7.25, 4,2,'rgba(255,0,0,.7)',1);//robeLShoulder
      drawShape('qua',x+sx,y+sy,z*sz,6,2.1, 7.5,3.5, 7.25,7.25, 4,2,'rgba(255,0,0,.7)',1);//robeLShoulder
      			drawShape('tri',x+sx,y+sy,z*sz,/*br*/ 7.9,3.9, /*tr*/7.3,3.3, /*l*/6.5,5.5, 0,0,'lightgray',1);//r-forearm
			drawShape('tri',x+sx,y+sy,z*sz,/*br*/ 7.9,3.9, /*tr*/7.3,3.3, /*l*/6.5,5.5, 0,0,'gray',0);//r-forearm
      drawShape('tri',x+sx,y+sy,z*sz,/*br*/ 2.3,4, /*tr*/2.7,3.55, /*l*/4.5,4, 0,0,'gray',1);//l-forearm
      drawShape('qua',x+sx,y+sy,z*sz,4,4, 5,3.75, 4.7,4.4, 4.5,4.4,'rgb(185,122,87)',1);//hand left
      drawShape('arc',x+sx,y+sy,z*sz,4.5,4, .39,0, 3,0, 0,0,'gold',1);////gold orb
      drawShape('arc',x+sx,y+sy,z*sz,4.5,4, .5,0, 3,0, 0,0,'rgba(255,255,0,.25)',1);////gold orb

      drawShape('qua',x+sx,y+sy,z*sz,4,4, 5,4, 4.7,4.4, 4.3,4.4,'rgb(185,122,87)',1);//hand left
      drawShape('arc',x+sx,y+sy,z*sz,6.4,2.65, .25,0, 3,0, 0,0,'gold',1);//ankh circle outer
     
            drawShape('arc',x+sx,y+sy,z*sz,6.4,2.65, .13,0, 3,0, 0,0,'red',1);//ankh circle inner
            drawShape('arc',x+sx,y+sy,z*sz,6.4,2.65, .131,0, 3,0, 0,0,'rgba(0,6,13,1)',0);//ankh circle inner
      drawShape('qua',x+sx,y+sy,z*sz,7,5, 6,4.75, 6.3,5.5, 6.5,5.5,'rgb(185,122,87)',1);//hand right
      drawShape('rec',x+sx,y+sy,z*sz,6.3,3, .19,2.5, 6.3,3, 0,0,'gold',1);//ankh
      drawShape('rec',x+sx,y+sy,z*sz,6.3,3, .19,2.5, 6.3,3, 0,0,'rgb(0,6,13)',0);//ankh
      drawShape('rec',x+sx,y+sy,z*sz,5.9,2.89, 1,.15, 6.3,3, 0,0,'gold',1);//ankh cross
      drawShape('rec',x+sx,y+sy,z*sz,5.9,2.89, 1,.15, 6.3,3, 0,0,'rgb(0,6,13)',0);//ankh cross
       drawShape('arc',x+sx,y+sy,z*sz,6.4,2.65, .25,0, 3,0, 0,0,'rgb(0,6,13)',0);//ankh circle outer
             drawShape('qua',x+sx,y+sy,z*sz,7,5, 6,5, 6.3,5.5, 6.5,5.5,'rgb(185,122,87)',1);//hand right
     
    drawShape('qua',x,y,z,5,1, 4.5,2, 4.75,2.5, 4.5,3,'rgba(255,255,255,.9)',1);//beard l
    drawShape('qua',x,y,z,4.75,2.5, 5.5,2, 5.25,.75, 4,1,'rgb(185,122,87)',1);//head
    drawShape('qua',x,y,z,4.75,2.5, 4.5,2, 4.5,3, 4.5,3,'rgba(255,255,255,.9)',1);//beard l
    drawShape('qua',x,y,z,4.5,2, 5,1.8, 5,1.9, 4.5,2.11,'rgba(255,255,255,.9)',1);//beard l
    drawShape('qua',x,y,z,5.3,1, 5.5,2, 5,3, 4.5,3,'rgba(255,255,255,.9)',1);//beard
        drawShape('tri',x,y,z,5,1.8, 4.5,2, 4.75,2.5, 4.75,2.5,'rgba(255,255,255,.9)',1);//beard
            drawShape('tri',x,y,z,4.5,1, 5.8,2.5, 5.3,1, 4.5,3,'rgba(255,255,255,.9)',1);//beard


    
    drawShape('qua',x,y,z,4.1,1.3, 5.3,1, 5.25,.75, 3.9,.75,'gold',1);//crown
    drawShape('qua',x,y,z,4.5,1.5, 4.5,2, 4.7,2, 4.5,1.5,'rgba(0,0,0,.25)',1);//nose
          drawShape('qua',x,y,z,4.5,1.5, 4.9,1.45, 4.75,1.4, 4.7,1.4,'rgba(0,0,0,.25)',1);//eyesr
          drawShape('qua',x,y,z,4.5,1.5, 4.25,1.4, 4.3,1.5, 4.5,1.5,'rgba(0,0,0,.25)',1);//eyesl
          drawShape('qua',x,y,z,4.5,2, 4.7,2.2, 4.8,2, 4.6,2.1,'rgba(255,0,0,.25)',1);//mouth'
    drawShape('arc',x,y,z,4.25,1,.1,0,6,0,0,0,'white',1);
        drawShape('arc',x,y,z,4.75,.9,.1,0,6,0,0,0,'red',1);
                drawShape('arc',x,y,z,5.1,.87,.1,0,6,0,0,0,'white',1);







    break;
    case 5: //Heirophant monster
      sx =-.6391*z;
      sy = -.30691*z;
      sz = 1.13;

      drawShape('qua',x+sx,y+sy,z*sz,  5.2,8.4,   5.1,8.8,    6.25,9,   5.75, 8.75,'blue',1);//right foot
      drawShape('qua',x+sx,y+sy,z*sz,  4.8,8.4,   4.9,8.8,    3.75,9,   4.25, 8.75,'blue',1);//left foot
      drawShape('qua',x+sx,y+sy,z*sz,  5.2,8.4,   5.1,8.8,    6.25,9,   5.75, 8.75,'rgba(255,255,255,.4)',1);//right foot
      drawShape('qua',x+sx,y+sy,z*sz,  4.8,8.4,   4.9,8.8,    3.75,9,   4.25, 8.75,'rgba(255,255,255,.4)',1);//left foot
      drawShape('qua',x+sx,y+sy,z*sz,  6,5.51,   6.1,8.5,    3.9,8.5,   4, 5.51,'lightblue',1);//robe bottom
  
    

      
      sx =1.25*z;
      sy = -.5*z;
      sz = .75;
        drawShape('qua',x,y,z, 4.4,1.9, 4.4,2.5, 5,2.9, 5,2,'lightblue',1);//neck left
        drawShape('qua',x,y,z, 5.6,1.9, 5.6,2.5, 5,2.9, 5,2,'lightblue',1);//neck left
        drawShape('qua',x+sx,y+sy,z*sz, 5.5,3.5, 5.5,4, 5.75,4,5,4.5,'lightblue',1);//neck right
        drawShape('qua',x+sx,y+sy,z*sz, 4.35,3.2, 5,3.9, 5.65,3.2, 5,4.52,'lightblue',1);//neck middle
        drawShape('qua',x+sx,y+sy,z*sz, 4.35,3.2, 5,3.9, 5.65,3.2, 5.02,4.52,'lightblue',1);//neck middle
        drawShape('qua',x+sx,y+sy,z*sz, 5.02,2, 4.1,2.5, 4.25,3.25,5.02,3.9,'rgb(185,122,87)',1);//face left
        drawShape('qua',x+sx,y+sy,z*sz, 5.02,2, 5.9,2.5, 5.75,3.25,5,3.9,'rgb(185,122,87)',1);//face right

        drawShape('rec',x+sx,y+sy,z*sz, 4,2,2,.28,0,0,0,0,'gold',1);//headband
        drawShape('qua',x+sx,y+sy,z*sz, 5,1.63, 4.3,1.75, 4,2, 5,2,'gold',1);//top head
        drawShape('qua',x+sx,y+sy,z*sz, 5,1.63, 5.7,1.75, 6,2, 5,2,'gold',1);//top head
        sy = -.75*z;
        drawShape('qua',x+sx,y+sy,z*sz, 5,1.63, 4.3,1.75, 4,2.3, 5,2,'gold',1);//top head
        drawShape('qua',x+sx,y+sy,z*sz, 5,1.63, 5.7,1.75, 6,2.3, 5,2,'gold',1);//top head
                sy = -1*z;
        drawShape('qua',x+sx,y+sy,z*sz, 5,1.63, 4.3,1.75, 4,2.6, 5,2,'gold',1);//top head
        drawShape('qua',x+sx,y+sy,z*sz, 5,1.63, 5.7,1.75, 6,2.6, 5,2,'gold',1);//top head
        //DONOTDELETEdrawShape('qua',x,y,z,4,2.25, 3.9,3.5, 4.25,3,4.25,4.25,'rgb(119,43,79)',1);//lightning bolt

      sx =0*z;
      sy = -.75*z;
      sz = 1;
      drawShape('qua',x+sx,y+sy,z*sz, 5.4,3.35,    5,3.6,    6,6,   5.4, 3.35,'white',1);//shirt right
      drawShape('qua',x+sx,y+sy,z*sz,   5, 3.6,  4.5,  3.25, 4.25,    6,    6,   6,'white',1);//shirt left
      drawShape('qua',x,y,z, 5.4,2.5, 5.55, 2.5,    6.1,  3,  6.5, 3.5,'darkred',1);//right shoulder
      drawShape('rec',x+sx,y+sy,z*sz,4,4.65,2,.3,0,0,0,0,'rgba(0,0,0,.75)',0);
 
      drawShape('rec',x,y,z,4.5,3, 1,6,0,0,0,0,'white',1);
      //drawShape('tri',x,y,z, 7.14,5.6,  7.5, 7.25,    7.44,   5,    8,   9,'rgba(0,0,0,.35)',1);//robeR Rightshadow
      sx =0*z;
      sy = 0*z;
      sz = 1;
      drawShape('qua',x+sx,y+sy,z*sz,  5.4,2.45,   5.25,9,    8,9,  6.5,3.5,'darkred',1);//robeR 
      drawShape('qua',x+sx,y+sy,z*sz,  4.6,2.5,   4.75,9,    2,9,  3.85,2,'darkred',1);//robeL
      sx =0*z;
      sy = 0*z;
      sz = 1;
      //drawShape('qua',x+sx,y+sy,z*sz, 4.65, 2.4,   4.5, 6.75,    3.5, 6.75,    3.5, 1.6,'darkred',1);//robeL LEft
      //drawShape('qua',x,y,z,  4,2,   3.25,2,    3.33,7.2 ,  3.9, 3.9,'rgba(0,0,0,.5)',1);
       sx =-.75*z;
      sy = -.8*z;
      sz = 1;
      drawShape('qua',x+sx,y+sy,z*sz, 6.5,3.5,  6.9, 4,    8,   5.5,    8, 9,'rgba(0,0,0,.2)',1);//robeR Right
      sx =.75*z;
      sy = -.8*z;
      sz = 1;
      drawShape('qua',x+sx,y+sy,z*sz, 3.5,3.5,  3.1, 4,    2,   5.5,    2, 9,'rgba(0,0,0,.2)',1);//robeR Right
      sx =1.25*z;
      sy = -.5*z;
      sz = .75;
      drawShape('qua',x+sx,y+sy,z*sz, 4,2.25, 5,2.25, 4.5,2.5, 4.25,6,'gold',1);//bangs left
      drawShape('qua',x+sx,y+sy,z*sz, 6,2.25, 5,2.25, 5.5,2.5, 5.75,6,'gold',1);//bangs left
      sx =-1*z;
      sy = -4*z;
      sz = 1.13;
      
      drawShape('qua',x+sx,y+sy,z*sz, 7.5,9.05, 7.4,8.75, 7.25,8.8, 7.25,9,'rgb(160,100,70)',1);//rightfingers

      drawShape('qua',x+sx,y+sy,z*sz, 6.7,8.39, 7,8.9, 7.1,8.8, 6.84,8.1,'rgb(185,122,87)',1);//right forearm
      drawShape('qua',x+sx,y+sy,z*sz, 7,8.85, 7.1,9.05, 7.5,9.05, 7.4,8.75,'rgb(185,122,87)',1);//right hand
      drawShape('rec',x,y,z,7.25,2, .1,6,0,0,0,0,'gold',1);
      drawShape('qua',x+sx,y+sy,z*sz, 7.1,9.05, 7.5,9, 7.25,8.95, 7,8.85,'rgb(170,110,70)',1);//rightthumb
      sx =-.6391*z;
      sy = -.6*z;
      sz = 1.13;
      drawShape('qua',x+sx,y+sy,z*sz,  3.99,2.3,   3.3,1.6,    3.16,1.9,   3.99, 3.66,'white',1);//left arm
      sx =-.16*z;
      sy = -3.87*z;
      drawShape('qua',x+sx,y+sy,z*sz,  2.9,5,   2.75,4.9,    2.72,4.3,   3.1, 4.8,'white',1);//left forearm white
      
      drawShape('qua',x+sx,y+sy,z*sz, 2.75,4.7, 2.75,4.31, 2,3.78, 2.5,4.4,'rgb(185,122,87)',1);//left finger/wrist
      drawShape('qua',x+sx,y+sy,z*sz, 2.75,4.7, 2.75,4.31, 2.2,3.6, 2.5,4.4,'rgb(185,122,87)',1);//left finger/wrist
      drawShape('qua',x+sx,y+sy,z*sz, 2.5,4.4, 2.2,4.2, 2.6,4, 2.75,4.5,'rgb(185,122,87)',1);//left hand
      drawShape('tri',x+sx,y+sy,z*sz, 2.55,4.07, 2.6,4.15, 2.3,4.2, 2.5,4.4,'rgb(165,102,67)',1);//left finger shadow
      
      sx =0*z;
      sy = -1*z;
      sz = 1;
      drawShape('tri',x+sx,y+sy,z*sz, 5,2.5, 5.15,2.85, 5,2.85, 0,0,'rgba(0,0,0,.25)',1);//nose
      drawShape('tri',x+sx,y+sy,z*sz, 4.8,3, 5.2,3, 5,3.05, 0,0,'rgba(255,0,0,.25)',1);//mouth
      drawShape('tri',x+sx,y+sy,z*sz, 4.6,2.55, 4.9,2.55, 4.75,2.58, 0,0,'rgba(0,0,0,.25)',1);//left eye
      drawShape('tri',x+sx,y+sy,z*sz, 5.4,2.55, 5.1,2.55, 5.25,2.58, 0,0,'rgba(0,0,0,.25)',1);//left eye

      drawShape('rec',x,y,z,4.97,3, .06,.6,0,0,0,0,'rgb(0,0,0)',1);
      drawShape('rec',x,y,z,4.85,3.2, .3,.06,0,0,0,0,'rgb(0,0,0)',1);

      drawShape('rec',x,y,z,4.97,4.5, .06,.6,0,0,0,0,'rgb(0,0,0)',1);
      drawShape('rec',x,y,z,4.85,4.7, .3,.06,0,0,0,0,'rgb(0,0,0)',1);

      drawShape('rec',x,y,z,4.97,6, .06,.6,0,0,0,0,'rgb(0,0,0)',1);
      drawShape('rec',x,y,z,4.85,6.2, .3,.06,0,0,0,0,'rgb(0,0,0)',1);
      drawShape('rec',x,y,z,6.75,2.5, 1.2,.1,0,0,0,0,'gold',1);
      drawShape('rec',x,y,z,6.5,2.75, 1.70,.1,0,0,0,0,'gold',1);           
      drawShape('rec',x,y,z,6.75,3, 1.2,.1,0,0,0,0,'gold',1);
    break;
    case 6://The Lovers spell
       //sx = 1.275*z;
       //sy = 1.275*z;
       //sz = .75;
			//drawShape('tri',x+sx,y+sy,z*sz,0,6.59,5,10,10,6.6,0,0,'rgb(255,72,72)',1);
			//drawShape('arc',x+sx,y+sy,z*sz,2.25,3.7,3.63,0,6,0,0,0,'rgb(255,72,72)',1);
			//drawShape('arc',x+sx,y+sy,z*sz,7.75,3.7,3.63,0,6,0,0,0,'rgb(255,72,72)',1);
			//drawShape('arc',x+sx,y+sy,z*sz,5,7,3,3,0,0,0,0,'rgb(255,72,72)',1);
      
      //wandfor (let i = 0; i < 20; i++){drawShape('ell',x,y,z, 4+i*.001, 5+i*.001, 6-i*.01, 0+i*.01, 4, 0, 2, 0, `rgba(${255},${195+i},${255},1)`,0)}
  drawShape('arc',x,y,z,5,5,5,0,2,0,0,0,'rgba(255,255,0,.25)',1);

  for (let i = 0; i < 25; i++){
      drawShape('ell',x,y,z, 5+i*.001, 5.5+i*.001, 4-i*.01, 0+i*.01, -4, 0, 2, 0, `rgba(${255},${235+i},${255},1)`,0)
  }
  for (let i = 0; i < 30; i++){
    //                                                                  CHANGE THIS 0 TO 4
    drawShape('ell',x,y,z, 5+i*.001, 5.5+i*.001, 6-i*.01, 0+i*.01, 4, 0, 2, 0, `rgba(${255},${225+i},${255},1)`,0)
        if (i == 30){drawShape('ell',x,y,z, 5+31*.001, 5.5+31*.001, 6-31*.01, 0+31*.01, 4, 0, 2, 0, `rgba(${0},${0},${0},1)`,1)
}
  }
      drawShape('pol',x,y,z,0.2,1, .25,.5, 1.9,2, 2.5,3,'rgb(252,165,3)',1,1.6,2.5);//handle
      drawShape('tri',x,y,z,0,.5, .7,.5, 0,1.2 ,0,0,'rgb(252,165,3)',1);//pommel
      drawShape('pol',x,y,z,2.5,1.5, 1,3 ,1,3.5 ,2,2.5,'rgb(252,165,3)',1,3,1.5);//hilt guard
      
      sx = 0.5*z;
       sy = 2*z;
       sz = .75;
      drawShape('pol',x+sx,y+sy,z*sz,10.8,0, 10.75,-.5, 8.1,2, 7.5,3,'rgb(252,165,3)',1,8.4,2.55);//handle
       sx = 1.25*z;
       sy = 1.25*z;
       sz = .75;     
      drawShape('tri',x+sx,y+sy,z*sz,10,.5, 9.3,.5, 10,1.2 ,0,0,'rgb(252,165,3)',1);//pommel
        sx = 1.4*z;
       sy = 1.6*z;
       sz = .75;    
      drawShape('pol',x+sx,y+sy,z*sz,7.5,1.5, 9,2 ,9,2.5 ,8,2.5,'rgb(252,165,3)',1,7,1.75);//hilt guard
      drawShape('pol',x+sx,y+sy,z*sz,8.5,2, 9,2 ,9,2.5 ,8,2.5,'rgba(0,0,0,.2)',1,8,2);//hilt guard

      break;
    case 7://The Chariot item (winged boot)
    			drawShape('qua',x,y,z,4.9,1, 5.1,.7, 5.22,.9, 3.4,6.4,'gray',1);
			drawShape('qua',x,y,z,4.75,2, 4.75,2, 5.5,4.2, 3.3,6.4,'rgba(128,64,0,1)',1);
			drawShape('qua',x,y,z,3.5,1, 5,9.45, 8.3,7.4, 8.5,1,'rgba(128,64,0,1)',1)
			drawShape('qua',x,y,z,3.75,1, 6,9.45, 4.5,7.4, 8,1,'rgba(0,0,0,.06)',1)
			drawShape('qua',x,y,z*1.1,7.8,1, 8,.7, 8.3,4.2, 6.3,6.4,'lightgray',1);
			drawShape('qua',x,y,z*1.1,7.8,1, 8,.7, 8.02,.9, 6.3,6.4,'gray',1);
			drawShape('ell',x,y,z,4,7.2, 2.9,2.4,1,0,6,0,'rgba(128,64,0,1)',1);
			drawShape('ell',x,y,z,4,7.2, 2.9,2.4,1,0,6,0,'rgba(0,0,0,.06)',1);
      break;
    case 8://Strength spell
        drawShape('arc',x,y,z,5,5,5,0,2,0,0,0,'rgba(255,255,0,.25)',1);


        drawShape('qua',x,y,z,10,3, 5,6, 3,10, 10,7,'rgb(255,187,119)',1);
                drawShape('qua',x,y,z,5,7, 2.5,2.5, 1,2, 3,10,'gray',1);
                drawShape('qua',x,y,z,1,2, 3,.5, 4,2, 2.5,2.5,'rgb(255,187,119)',1);
                drawShape('qua',x,y,z,3,.5, 4,2, 2,2, 2.25,1.25,'rgba(0,0,0,.25)',1);
        drawShape('ell',x,y,z,7.65,5.5, 2.8,2, 0,.65,-.19,.5,'rgb(255,187,119)',1);
        drawShape('ell',x,y,z,6.7,4.5, 2.8,2, 0,-.05,.5,.5,'rgba(0,0,0,.25)',1);
			


        break;
    case 9: //Hermit monster
      drawShape('ell',x,y,z,4.59,.8,.65,.5,1,0,6,0,'gray',1);
      drawShape('qua',x,y,z,5.3,1, 6,2.5, 5.5,2.5, 5,1,'gray',1);//hair back
			drawShape('qua',x,y,z,2.5,10,   3,9.5,    5,9,   6.5,9.5,    'brown',1);//mountain
      drawShape('qua',x,y,z,2.5,10,   7,10,    6.5,9.5,   2.5,10,    'brown',1);//mountain
      sx = .15*z;
      sy = .49*z;
      sz=.95;
			drawShape('qua',x,y,z,4.4,8.5,/*tr*/4.75,9.5,/*br*/ 3,9.5,/*l*/4,9,/*tl*/'darkgray',1);//l-foot
			drawShape('qua',x+sx,y+sy,z*sz,4.5,9.5,/*br*/ 4.5,7.7,/*tr*/ 3.3,7.3,/*tl*/ 4.3,9,/*bl*/'darkgray',1);//l-calf
			//drawShape('qua',x+sx,y+sy,z*sz,4.5,9.5,/*br*/ 4.5,7.7,/*tr*/ 3.3,7.3,/*tl*/ 3.9,9,/*b*/'gray',0);//l-calf
			drawShape('qua',x+sx,y+sy,z*sz,4.7,2,5.5,1.5,6,2.5,4.25,2.5,'gray',1);//neck
			drawShape('qua',x+sx,y+sy,z*sz,5.5,7,/*tl*/6.25,7.25,/*tm*/6.75,7.2,/*tr*/ 6.25,9.5,/*b*/'darkgray',1);//r-calf
			//drawShape('qua',x,y,z,6.25,9,/*tl*/6.55,9.5,/*bl*/4.5,9.75,/*bm*/ 6,9,/*br*/'darkgray',1);//r-foot
			drawShape('qua',x,y,z,5.9,8.5,/*tr*/6.25,9.5,/*br*/ 4.8,9.6,/*l*/6,9,/*tl*/'darkgray',1);//l-foot
			drawShape('qua',x,y,z,/*tr*/ 4,2.5, /*tl*/3,1.5, /*bl*/2.5,5, 4,8,'gray',1);//l-arm
		  drawShape('qua',x,y,z,/*tr*/ 4,2.5, /*tl*/3,1.5, /*bl*/2.5,5, 4,8,'rgba(0,0,0,0.15)',1);//l-arm
			drawShape('tri',x+sx,y+sy,z*sz,/*tl*/ 5.55,3.55, /*tr*/6.3,2.5, /*br*/7.7,4, 0,0,'lightgray',1);//r-arm
			drawShape('tri',x+sx,y+sy,z*sz,/*tl*/ 5.6,3.5, /*tr*/6.3,2.5, /*br*/7.7,4, 0,0,'gray',0);//r-arm
			drawShape('arc',x+sx,y+sy,z*sz,6.2,5.75,.4,0,3,0,0,0,'darkgray',1);//r-hand
      drawShape('qua',x+sx,y+sy,z*sz,4,2, 4,4, 3,8, 7.25,7.25,'gray',1);//robeLShoulder
      drawShape('qua',x+sx,y+sy,z*sz,6,2.1, 7.5,3.5, 7.25,7.25, 4,2,'gray',1);//robeLShoulder
      drawShape('qua',x,y,z,7,9, 3,8.5, 3,8.1, 6,7.5,'gray',1);//robeLShoulder
      drawShape('tri',x+sx,y+sy,z*sz,/*br*/ 7.9,3.9, /*tr*/7.3,3.3, /*l*/6.5,5.5, 0,0,'lightgray',1);//r-forearm
			drawShape('tri',x+sx,y+sy,z*sz,/*br*/ 7.9,3.9, /*tr*/7.3,3.3, /*l*/6.5,5.5, 0,0,'gray',0);//r-forearm
      drawShape('qua',x,y,z,/*bl*/ 3,2.5, /*tl*/2.25,1.5, /*tr*/2.5,1, /*br*/ 3.5,2,'lightgray',1);//l-forearm
      drawShape('qua',x,y,z,2.5,1, 1.5,1, 2,1.5, 2.5,1.4,'rgb(185,122,87)',1);//hand left
      //drawShape('arc',x,y,z,2,2.75, .39,0, 3,0, 0,0,'gold',1);////gold orb
      drawShape('arc',x,y,z,2,2.75, .5,0, 3,0, 0,0,'rgba(255,255,0,.05)',1);////gold orb
      sx = 1.62*z;
      sy = 2.35*z;
      sz=.075;
      drawShape('tri',x+sx,y+sy,z*sz,5,0,.5,7.5,9.5,7.5,0,0,'black',0);
      drawShape('tri',x+sx,y+sy,z*sz,5,10,.5,2.5,9.5,2.5,0,0,'black',0);
      drawShape('tri',x+sx,y+sy,z*sz,5,0,.5,7.5,9.5,7.5,0,0,'gold',1);
      drawShape('tri',x+sx,y+sy,z*sz,5,10,.5,2.5,9.5,2.5,0,0,'gold',1);
      sx = 1.25*z;
      sy = 2*z;
      sz=.15;
      drawShape('tri',x+sx,y+sy,z*sz,5,0,.5,7.5,9.5,7.5,0,0,'rgba(255,255,0,.25)',1);
      drawShape('tri',x+sx,y+sy,z*sz,5,10,.5,2.5,9.5,2.5,0,0,'rgba(255,255,0,.25)',1);
      sx = 1.5*z;
      sy = 2.25*z;
      sz=.1;
      drawShape('tri',x+sx,y+sy,z*sz,5,0,.5,7.5,9.5,7.5,0,0,'rgba(255,255,0,.25)',1);
      drawShape('tri',x+sx,y+sy,z*sz,5,10,.5,2.5,9.5,2.5,0,0,'rgba(255,255,0,.25)',1);
      sx = .15*z;
      sy = .49*z;
      sz=.95;
      drawShape('arc',x,y,z,2,2.2, .6,1, 0,1, 1,0,'brown',1);//lantern top
      drawShape('rec',x,y,z,1.5,3.25, 1,.1, 0,1, 1,0,'brown',1);////lantern bottom
      drawShape('rec',x,y,z,1.5,1.99, .1,1.27, 0,1, 1,0,'brown',1);////lantern bottom
      drawShape('rec',x,y,z,1.95,1.99, .1,1.27, 0,1, 1,0,'brown',1);////lantern bottom
      drawShape('rec',x,y,z,2.4,1.99, .1,1.27, 0,1, 1,0,'brown',1);////lantern bottom
      drawShape('ell',x,y,z,2,2.17, .6,.1, 1,1, 0,6,'brown',0);//lantern top
      drawShape('ell',x,y,z,2,2.17, .6,.1, 1,1, 0,6,'rgba(255,255,0,.25)',1);//lantern top
      drawShape('ell',x,y,z,2,3.3, .5,.1, 1,1, 0,6,'brown',1);//lantern top
      drawShape('rec',x,y,z,1.975,1, .05,.6, 0,1, 1,0,'gray',1);////lantern bottom
      drawShape('arc',x,y,z,2,1.55, .1,0, 3,0, 0,0,'brown',1);////gold orb
      drawShape('qua',x,y,z,2.5,1, 1.7,1.1, 2,1.15, 2.5,1.4,'rgb(185,122,87)',1);//hand left
     	drawShape('arc',x+sx,y+sy,z*sz,6,3, .63,0, 3,0, 0,0,'rgba(0,0,0,0.025)',1);//r-shoulder
      drawShape('qua',x+sx,y+sy,z*sz,6,2.1, 7.5,3.5, 7.25,7.25, 4,2,'rgba(0,0,0,0.1)',1);//robeLShoulder
      drawShape('qua',x,y,z,2.5,1, 3,3.5, 7,9, 7,5.5,'gray',1);//crown
      drawShape('qua',x+sx,y+sy,z*sz,7,5, 6,4.75, 6.3,5.5, 6.5,5.5,'rgb(185,122,87)',1);//hand right
      drawShape('rec',x+sx,y+sy,z*sz,6.3,1, .19,8.9, 6.3,3, 0,0,'brown',1);//ankh
      drawShape('rec',x+sx,y+sy,z*sz,6.3,1, .19,8.9, 6.3,3, 0,0,'rgb(0,6,13)',0);//ankh
      drawShape('arc',x+sx,y+sy,z*sz,6.4,1, .25,0, 3,0, 0,0,'brown',1);//ankh circle outer
      drawShape('arc',x+sx,y+sy,z*sz,6.4,1, .25,0, 3,0, 0,0,'rgb(0,6,13)',0);//ankh circle outer
      drawShape('qua',x+sx,y+sy,z*sz,7,5, 6,5, 6.3,5.5, 6.5,5.5,'rgb(185,122,87)',1);//hand right
      drawShape('qua',x+sx,y+sy,z*sz,4.7,5.5,/*tr*/ 3.5,7.5,/*br*/ 4.4,7.7,/*bl*/ 5,6.5,'rgba(0,0,0,.05)',1);//l-thigh shadow
      drawShape('arc',x+sx,y+sy,z*sz,4.25,2.65, .63,0, 3,0, 0,0,'rgba(0,0,0,.025)',1);//l-shoulder
			drawShape('ell',x+sx,y+sy,z*sz,5.15,3.6,1.15,1.75,0,0,6,0,'rgba(0,0,0,.025)',1);//torso
			drawShape('qua',x+sx,y+sy,z*sz,4.5,5.5,/*tl*/6,4.5,/*tr*/ 6.5,7.7,/*br*/ 5.8,8,/*bl*/ 'rgba(0,0,0,.04)',1);//r-thigh
			drawShape('qua',x+sx,y+sy,z*sz,6.2,4.3,7.25,7.25,5.1,6.3,4.75,5.25,'rgba(0,0,0,.05)',1);//hip armor
		  drawShape('qua',x+sx,y+sy,z*sz,3,8, 3,2, 5.5,5.5, 7,7.3,'rgba(0,0,0,.05)',1);//groin armor
      drawShape('qua',x+sx,y+sy,z*sz,4,2, 3.5,2.5, 6.5,7.2, 4.2,5,'rbga(0,0,0,.05)',1);//robeLShoulder
      drawShape('qua',x+sx,y+sy,z*sz,4,2, 6.5,2.5, 3.5,7.2, 6.5,5,'rgba(0,0,0,.05)',1);//robeLShoulder
      drawShape('qua',x,y,z,5,1, 4.5,2, 4.75,2.5, 4.5,3,'rgba(255,255,255,.9)',1);//beard l
      drawShape('qua',x,y,z,4.75,2.5, 5.5,2, 5.25,.75, 4,1,'rgb(185,122,87)',1);//head
      drawShape('qua',x,y,z,4.75,2.5, 4.5,2, 4.5,3, 4.5,3,'rgba(255,255,255,.9)',1);//beard l
      drawShape('qua',x,y,z,4.5,2, 5,1.8, 5,1.9, 4.5,2.11,'rgba(255,255,255,.9)',1);//beard l
      drawShape('qua',x,y,z,5.3,1, 5.5,2, 5,3, 4.5,3,'rgba(255,255,255,.9)',1);//beard
      drawShape('tri',x,y,z,5,1.8, 4.5,2, 4.75,2.5, 4.75,2.5,'rgba(255,255,255,.9)',1);//beard
      drawShape('tri',x,y,z,4.5,1, 5.8,2.5, 5.3,1, 4.5,3,'gray',1);//beard
      drawShape('qua',x,y,z,4.1,1.3, 5.3,1, 5.25,.75, 3.9,.75,'gray',1);//crown
      drawShape('qua',x,y,z,4.5,1.5, 4.5,2, 4.7,2, 4.5,1.5,'rgba(0,0,0,.25)',1);//nose
      drawShape('qua',x,y,z,4.5,1.5, 4.9,1.45, 4.75,1.45, 4.7,1.45,'rgba(0,0,0,.25)',1);//eyesr
      drawShape('qua',x,y,z,4.5,1.5, 4.25,1.44, 4.3,1.5, 4.5,1.5,'rgba(0,0,0,.25)',1);//eyesl
      drawShape('qua',x,y,z,4.5,2, 4.7,2.2, 4.8,2, 4.6,2.1,'rgba(255,255,255,.25)',1);//mouth'
      drawShape('arc',x,y,z,4.25,1,.1,0,6,0,0,0,'gray',1);
      drawShape('arc',x,y,z,4.75,.9,.1,0,6,0,0,0,'gray',1);
      drawShape('arc',x,y,z,5.1,.87,.1,0,6,0,0,0,'gray',1);
      drawShape('qua',x,y,z,4.1,1.275, 4.75,1.1, 5.5,2.2, 4.6,1.25,'white',1);//hair back
      break;
    case 10: //Wheel of Fortune item (CHEST)
    sx = .6*z;
    sy = .4*z;
    sz = .9;
			drawShape('rec',x+sx,y+sy,z*sz,7.93,1,1.85,9,0,0,0,0,'rgb(185,122,87)',1);
			drawShape('rec',x+sx,y+sy,z*sz,2,.3,6.613,9.7,0,0,0,0,'rgb(185,122,87)',1);
			drawShape('rec',x+sx,y+sy,z*sz,1,.3,1,1,0,0,0,0,'rgb(185,122,87)',1);
			drawShape('arc',x+sx,y+sy,z*sz,1,1.3,1,0,6,0,0,0,'rgb(119,43,79)',1);
			drawShape('arc',x+sx,y+sy,z*sz,8.8,1.3,1,0,6,0,0,0,'rgb(185,122,87)',1);
			drawShape('rec',x+sx,y+sy,z*sz,0,1,2,8,0,0,0,0,'rgb(119,43,79)',1);
			drawShape('tri',x+sx,y+sy,z*sz,0,9,2,10,2,9,0,0,'rgb(119,43,79)',1);
			drawShape('lin',x+sx,y+sy,z*sz,0,4,2,5,0,0,0,0,'black',0);
			drawShape('lin',x+sx,y+sy,z*sz,2,5,10,5,0,0,0,0,'black',0);
			drawShape('rec',x+sx,y+sy,z*sz,5,4,2,2,0,0,0,0,'gold',1);
			drawShape('rec',x+sx,y+sy,z*sz,5.8,4.7,.5,1,0,0,0,0,'black',1);
			break;
    case 11://Justice item
      drawShape('tri',x,y,z,4.5,9.5,5.5,9.5,5,0.5,0,0,'gray',1);
      drawShape('tri',x,y,z,5,9, 3,9.9, 7,9.9,0,0,'gray',1);
       drawShape('qua',x,y,z,8.5,.5, 1.5,1, 1.5,1.1,8.5,.6,'gray',1);
       drawShape('rec',x,y,z,2,1, .02,5, 0,0,0,0,'gray',1);
       drawShape('rec',x,y,z,8,.6, .02,5, 0,0,0,0,'gray',1);
       drawShape('ell',x,y,z,2,6, 1,.3, .5,0, 1,1,'gray',1);
        drawShape('ell',x,y,z,8,5.6, 1,.3, .5,0, 1,1,'gray',1);

    break;
    case 12://Bind spell (hanged man)
       sx = 0*z;
      sy = 0*z;
      drawShape('rec',x+sx,y+sy,z,4.5,1, 1,9, 0,0,0,0,'rgb(128,64,0)',1);
      drawShape('rec',x+sx,y+sy,z,0,.51, 10,.5, 0,0,0,0,'rgb(128,64,0)',1);
      drawShape('qua',x+sx,y+sy,z,0,.6, .5,.4, 1,1.5,0,3,'green',1);
      drawShape('qua',x+sx,y+sy,z,10,.6, 9.5,.4, 9,1.5,10,3,'green',1);
      drawShape('qua',x+sx,y+sy,z,7,.51, 6.75,.75, 7,1.5,7.5,.75,'green',1);
      drawShape('qua',x+sx,y+sy,z,3,.51, 3.25,.75, 3,1.5,2.5,.75,'green',1);
             sx = 0*z;
      sy = -.5*z;
      drawShape('qua',x+sx,y+sy,z,5.5,1, 5,2, 4.9,1.9, 5.1,1.25,'gold',1);//rfoottop
      drawShape('tri',x+sx,y+sy,z,5.5,1, 5.5,1.5, 5,2, 5.1,1.25,'gold',1);//rfootbot
      sx = 1*z;
      sy = 1.5*z;
         drawShape('qua',x+sx,y+sy,z,5.5,1, 5,2, 4.9,1.9, 5.2,1.25,'gold',1);
      drawShape('tri',x+sx,y+sy,z,5.5,1, 5.5,1.5, 5,2, 5.1,1.25,'gold',1);
       sx = 0*z;
      sy = -.5*z
      drawShape('pol',x,y+sy,z,6.25,3.5, 6,3.6, 3.5,3.5, 4.5,4,'brown',1, 6.01,3.9);//llegcalf
      drawShape('pol',x,y+sy,z,3.5,3.5, 3.4,3.75, 3.75,5, 4.25,4.5,'brown',1,4,4);//llegthigh
        drawShape('ell',x,y+sy,z,4.1,3.66, .6,.39, .48,0, 1,1,'brown',1);

      drawShape('qua',x+sx,y+sy,z,5.2,1.6, 5.2,2, 4.9,3, 4.95,1.9,'brown',1);//rlegleft
      drawShape('pol',x+sx,y+sy,z,5.2,2, 4.9,3, 4.75,4.2, 5.5,4.75,'brown',1, 5.3,3);//rlegright
      drawShape('pol',x+sx,y+sy,z,4.25,4.5, 3.75,5, 3.7,4.8, 3.5,5.2,'cyan',1, 4.3,6);//hipclothesleft
      drawShape('pol',x+sx,y+sy,z,4.25,4.5, 4.5,4.75, 4.75,4.2, 5.5,4.75,'cyan',1, 5.8,5.5);//hipclothesright
      drawShape('pol',x+sx,y+sy,z,4.25,4.5, 5.8,5.5, 5.5,6, 4.75,5.8,'cyan',1, 4.3,6);//hipclothesmid
      drawShape('qua',x+sx,y+sy,z,4.8,6.8, 2.6,7.5, 5,9.1, 7.4,7.5,'cyan',1);//arms
      drawShape('qua',x+sx,y+sy,z,4.8,6.8, 2.6,7.5, 5,9.1, 7.4,7.5,'rgba(0,0,0,.05)',1);//arms
      drawShape('qua',x+sx,y+sy,z,4.8,7, 3.5,7.5, 4.8,8, 6.5,7.5,'rgba(0,0,0,.45)',1);//arms
      drawShape('arc',x,y,z,5,8.75,1,0,3,0,0,0,'rgba(255,255,255,1)',1);//r-hand
      drawShape('arc',x,y,z,5,8.75,1.1,0,3,0,0,0,'rgba(255,255,0,.25)',1);//r-hand
      drawShape('arc',x,y,z,5,8.75,1.15,0,3,0,0,0,'rgba(255,255,0,.25)',1);//r-hand
      drawShape('arc',x,y,z,5,8.75,1.2,0,3,0,0,0,'rgba(255,255,0,.25)',1);//r-hand
      drawShape('arc',x,y,z,5,8.75,1.25,0,3,0,0,0,'rgba(255,255,0,.25)',1);//r-hand
      drawShape('arc',x,y,z,5,8.75,1.3,0,3,0,0,0,'rgba(255,255,0,.25)',1);//r-hand


      

      drawShape('pol',x+sx,y+sy,z,4.3,6, 4,7.5, 4.1,8.5, 5.85,8.5,'cyan',1, 5.8,8);//tunicl
      drawShape('qua',x+sx,y+sy,z,5.8,8, 5.5,6, 4.75,5.75, 4.3,6,'cyan',1);//tunicr

      drawShape('pol',x+sx,y+sy,z,4.5,8.5, 4.5,8.4, 5,8.25, 5.5,8.4,'rgb(255,179,102)',1, 5.5,8.5);//collar

      drawShape('pol',x,y,z,4.55,8.5, 4.35,9.3, 5,10, 5.6,9.3,'gold',1, 5.4,8.4);//hair

      drawShape('pol',x+sx,y+sy,z,4.55,8.5, 4.8,8.9, 5.25,8.75, 5.3,8.6,'rgb(255,179,102)',1, 5.5,8.5);//neck
      drawShape('pol',x+sx,y+sy,z,4.6,8.75, 4.5,9.75, 5,9.75, 5.5,9.7,'rgb(245,169,92)',1, 5.3,8.5);//neck
      drawShape('pol',x+sx,y+sy,z,4.6,8.75, 4.5,9.75, 5,9.75, 5.5,9.7,'rgb(245,169,92)',1, 5.3,8.5);//head
       sx = 0*z;
      sy = 0*z
            drawShape('tri',x,y,z,4.55,9, 4.8,9.05, 4.95,9, 0,0,'rgba(0,0,0,.7)',1, 5.4,8.4);//hair
            drawShape('tri',x,y,z,5.45,9, 5.2,9.05, 5.05,9, 0,0,'rgba(0,0,0,.7)',1, 5.4,8.4);//hair
            drawShape('pol',x,y,z,5,8.6, 4.9,8.65, 5,8.8, 5,8.65,'rgba(0,0,0,.7)',1, 5.1,8.65);//hair
            drawShape('tri',x,y,z,4.75,8.5, 5,8.45, 5.25,8.5, 0,0,'rgba(255,0,0,.55)',1, 5.4,8.4);//hair
      break;
    case 13://Death monster
      sz = .9;
      sx = .5*z;
      sy=.9*z;
			//arms
			drawShape('arc',x+sx,y+sy,z*sz,3.5,3.5,.5,0,6,0,0,0,'lightgray',1);//l-shoulder
			drawShape('arc',x+sx,y+sy,z*sz,6.5,3.5, .5,0, 6,0,0,0,'lightgray',1);//r-shoulder
			drawShape('arc',x+sx,y+sy,z*sz,3.5,3.5,.5,0,6,0,0,0,'black',0);//l-shoulder-shadow
			drawShape('arc',x+sx,y+sy,z*sz,6.5,3.5,.5,0,6,0,0,0,'black',0);//r-shoulder-shadow
			drawShape('tri',x+sx,y+sy,z*sz,3,3.5,3.5,4,2,5,0,0,'lightgray',1);//l-arm
			drawShape('tri',x+sx,y+sy,z*sz,7,3.5,6.5,4,8,5,0,0,'lightgray',1);//r-arm
			drawShape('tri',x,y,z,2.75,5.1, 2.3,5.4, 2,6.5,0,0,'lightgray',1);//l-forearm
      
      drawShape('tri',x,y,z,7.25,5.1, 7.7,5.4, 8,6.5,0,0,'lightgray',1);//l-forearm
      drawShape('pol',x,y,z,7.9,6.25, 7.88,6.3, 8.1,7, 8,6.5,'lightgray',1,8,6.75);//r-hand
			drawShape('pol',x,y,z,8,6.25, 7.8,6.3, 7.6,7, 8,6.5,'lightgray',1,8.25,6.75);//r-hand
			//lower body
			
      drawShape('pol',x,y,z,2,6, 1.9,6.8, 2.25,6.5, 2.2,6,'lightgray',1,2,6.75);//l-hand
			//drawShape('pol',x,y,z,2,6.25, 2.2,6.3, 2.4,7, 2,6.5,'lightgray',1,1.75,6.75);//l-hand
			//lower body
			drawShape('tri',x+sx,y+sy,z*sz,4,10,1.75,10,3.5,9.3, 0,0,'lightgray',1);//l-foot
			drawShape('tri',x+sx,y+sy,z*sz,6,10,8.25,10,6.5,9.3, 0,0,'lightgray',1);//l-foot
      sx =0*z;
      sy = -.25*z;
      sz = 1;
      drawShape('qua',x+sx,y+sy,z*sz, 5.4,3.35,    5,3.6,    6,6,   5.4, 3.35,'lightgray',1);//shirt right
      drawShape('qua',x+sx,y+sy,z*sz,   5, 3.6,  4.5,  3.25, 4.25,    6,    6,   6,'lightgray',1);//shirt left
      drawShape('rec',x+sx,y+sy,z*sz,4,4.65,2,.3,0,0,0,0,'rgba(0,0,0,.75)',0);
      drawShape('rec',x,y,z,4.5,3, 1,6,0,0,0,0,'lightgray',1);
      //drawShape('tri',x,y,z, 7.14,5.6,  7.5, 7.25,    7.44,   5,    8,   9,'rgba(0,0,0,.35)',1);//robeR Rightshadow
      sx =0*z;
      sy = .5*z;
      sz = 1;
      drawShape('qua',x+sx,y+sy,z*sz,  5,2.45,   5.2,9,    8,9,  6.5,3,'gray',1);//robeR 
      drawShape('qua',x+sx,y+sy,z*sz,  5,2.5,   4.75,9,    2,9,  3.5,3,'gray',1);//robeL
      sx =-.75*z;
      sy = -.3*z;
      sz = 1;
      drawShape('qua',x+sx,y+sy,z*sz, 6.5,3.5,  6.9, 4,    8,   5.5,    8, 9,'rgba(0,0,0,.2)',1);//robeR Right
      sx =.75*z;
      sy = -.3*z;
      sz = 1;
      drawShape('qua',x+sx,y+sy,z*sz, 3.5,3.5,  3.1, 4,    2,   5.5,    2, 9,'rgba(0,0,0,.2)',1);//robeR Right
      sy = .5*z;
      drawShape('qua',x,y+sy,z, 5.4,2.5, 5.55, 2.5,    6.1,  3,  6.5, 3.5,'gray',1);//right shoulder
      sz = 1.2;
      sx = -1*z;
      sy=0*z;
      drawShape('pol',x+sx,y+sy,z*sz,5,.5, 4,1, 3.5,2.5, 4,3.5,'gray',1,5,4);//hood
			drawShape('pol',x+sx,y+sy,z*sz,5,.5, 6,1, 6.5,2.5, 6,3.5,'gray',1,5,4);//hood
			drawShape('pol',x+sx,y+sy,z*sz,5,1.39, 5.9,1.2, 6.3,2.5, 5.8,3.3,'rgba(0,0,0,.45)',1,5,3.8);//hoodinner
			drawShape('pol',x+sx,y+sy,z*sz,5,1.39, 4.1,1.2, 3.7,2.5, 4.2,3.3,'rgba(0,0,0,.45)',1,5,3.8);//hoodinner
      sz = 1;
      sx = 0*z;
      sy=.4*z;
      drawShape('lin',x+sx,y+sy,z*sz,4.5,3.5, 5,4.5, 0,0, 0,0,'rgb(255,126,60)',0);//string
      drawShape('lin',x+sx,y+sy,z*sz,5.5,3.5, 5,4.5, 0,0, 0,0,'rgb(255,126,60)',0);//string
      drawShape('arc',x+sx,y+sy,z*sz,5,4.6,.13,0,6,0,0,0,'darkred',1);//amulet
      drawShape('arc',x+sx,y+sy,z*sz,5,4.6,.1,0,6,0,0,0,'red',1);//amulet
      sz = .9;
      sx = .5*z;
      sy=.9*z;
      //head
			drawShape('arc',x+sx,y+sy,z*sz,5,1.5,1.5,0,6,0,0,0,'lightgray',1);//head
      drawShape('pol',x,y,z,5,.6, 3.8,1.3, 4.5,1.6, 5,1.75,'gray',1,6.2,1.3);//hood

			drawShape('arc',x+sx,y+sy,z*sz,5.55,1.5,.5, -.2,1,0,0,0,'black',1);//r-eye
			drawShape('arc',x+sx,y+sy,z*sz,4.45,1.5,.5,0,1.2,0,0,0,'black',1);//l-eye
      drawShape('ell',x+sx,y+sy,z*sz, 5,   3,  .75,.5,0,0,6,0,'lightgray',1);//jaw
			drawShape('ell',x+sx,y+sy,z*sz,4.88,2.25,.1,.15,0,0,6,0,'black',1);//nose
			drawShape('ell',x+sx,y+sy,z*sz,5.1,2.25,.1,.15,0,0,6,0,'black',1);//nose
			drawShape('lin',x,y,z,4.5,3.7,5.5,3.7,0,0,0,0,'black',0);//mouth

      drawShape('rec',x,y,z,2,.5,.2,9.5,0,0,0,0,'rgb(200,80,40)',1);//scythehandle

			drawShape('tri',x,y,z,2.2,6.5, 2.2,6.3, 2,6.7, 2,6.5,'lightgray',1,1.75,6.75);//l-hand
			drawShape('tri',x,y,z,2,6.5, 2.2,6.7, 2,6.6, 2,6.5,'lightgray',1,1.75,6.75);//l-hand
			drawShape('tri',x,y,z,2,6.7, 2.2,6.9, 2,6.8, 2,6.5,'lightgray',1,1.75,6.75);//l-hand
			drawShape('tri',x,y,z,2,6.6, 2.2,6.8, 2,6.7, 2,6.5,'lightgray',1,1.75,6.75);//l-hand
      drawShape('pol',x,y,z,2,1, 2,.25, 5,.25, 6.7,.6,'lightgray',1,6,.5);//l-hand
			drawShape('ell',x,y,z,4.5,.75, 2.5,.5, .1,1.2,0,0,'lightgray',1);//nose		
      break;
    case 14://Temperance spell? item? (taiji)
    drawShape('arc',x,y,z,5,5,5,0.5,1.5,0,0,0,'white',1);//l-shoulder
    drawShape('arc',x,y,z,5,5,5,1.5,.5,0,0,0,'rgb(39,39,39)',1);//l-shoulder
    drawShape('arc',x,y,z,5,2.5,2.5,2,0,0,0,0,'rgb(39,39,39)',1);//l-shoulder
    drawShape('arc',x,y,z,5,7.5,2.5,2,0,0,0,0,'white',1);//l-shoulder
    drawShape('arc',x,y,z,5,2.5,1,2,0,0,0,0,'white',1);//l-shoulder
    drawShape('arc',x,y,z,5,7.5,1,2,0,0,0,0,'rgb(39,39,39)',1);//l-shoulder
    break;
    case 15://Goblin monster(...)
      drawShape('qua',x,y,z,5,9,6,9,7,8,6,8,'darkgreen',1);//IL-foot
			drawShape('qua',x,y,z,6,8,7,8,4,6,4,7,'darkgreen',1);//IL-calf+knee
			drawShape('tri',x,y,z,4,6,7,5,5,7,0,0,'darkgreen',1);//IL-thigh
			drawShape('tri',x,y,z,7,5,8,5,8,6,0,0,'green',1);//OL-hip
			drawShape('qua',x,y,z,7,5,5,7,6,7,8,6,'green',1);//OL-thigh
			drawShape('qua',x,y,z,5,7,7,9,8,9,6,7,'green',1);//OL-calf+knee
			drawShape('qua',x,y,z,7,9,8,9,7,10,5.5,9.9,'green',1);//OL-foot
			drawShape('tri',x,y,z,3,3,5,5,4,2,0,0,'darkgreen',1);//Inner arm
			drawShape('tri',x,y,z,2.1,5.5,5,5,4.5,4.25,0,0,'darkgreen',1);//Inner forearm
			drawShape('arc',x,y,z,2.5,5.4,.4,0,6,0,0,0,'darkgreen',1);//Inner hand
			drawShape('arc',x,y,z,4.5,3.5,.75,0,6,0,0,0,'darkgreen',1);//T-Ishoulder
			drawShape('arc',x,y,z,5.8,4.4,2.5,1.4,2.25,0,0,0,'brown',1);//T-hump
			drawShape('qua',x,y,z,6,5.5,8,5,5,2,4,3,'brown',1);//T-torso
			drawShape('tri',x,y,z,4,3,5,2,5,3,0,0,'darkgreen',1);//T-neck
			drawShape('arc',x,y,z,5.5,2.5,.75,0,6,0,0,0,'darkgreen',1);//T-Oshoulder
			drawShape('qua',x,y,z,7,5,7,6,8,7,8,5,'brown',1);//T-hip armor
			drawShape('tri',x,y,z,5,3,7,5,6,2,0,0,'green',1);//Outer arm
			drawShape('qua',x,y,z,1,5,1,5.25,10,5.5,10,5.25,'brown',1);//T-spear
			drawShape('tri',x,y,z,4.1,5.5,7,5,6.5,4.25,0,0,'green',1);//Outer forearm
			drawShape('arc',x,y,z,4.5,5.4,.4,0,6,0,0,0,'green',1);//Inner hand
			drawShape('tri',x,y,z,5,0,3,2,5,2,0,0,'red',1);//H-hat
			drawShape('tri',x,y,z,3,2,3,4,5,2,0,0,'green',1);//H-head
			drawShape('tri',x,y,z,3,2,2.25,3.25,3,3,0,0,'green',1);//H-nose
			drawShape('tri',x,y,z,3,3,3.5,3,3,4,0,0,'black',1);//H-mouth
			//drawShape('tri',x,y,z,3,2.25,3,2.75,3.75,2.75,0,0,'red',1);//H-eye(sad)
			drawShape('tri',x,y,z,3,2.25,3,2.75,3.75,2.1,0,0,'red',1);//H-eye(mad)
			//drawShape('tri',x,y,z,3,2.25,3,2.75,3.75,2.25,0,0,'red',1);//H-eye(neutral)
			drawShape('tri',x,y,z,4,2.25,4,2.75,4.75,1.75,0,0,'darkgreen',1);//H-ear
			drawShape('arc',x,y,z,2.7,3.2,.25,1,1.75,0,0,0,'black',1);//H-nostril
			drawShape('tri',x,y,z,1,4.9,1,5.35,0,5.15,0,0,'lightgray',1);//H-ear
    break;
    case 16://Ruin item? spell? (tower)
      sx = 3.25*z;
      sy = .25*z;
      sz = .2;
      drawShape('arc',x+sx,y+sy,z*sz,5,6.5,3.5,0,2,0,0,0,'rgba(176,9,0,.75)',1);//CRA
			drawShape('tri',x+sx,y+sy,z*sz,1.5,6.5,2,0,8,5,0,0,'rgba(176,9,0,.65)',1);//LRT
			drawShape('tri',x+sx,y+sy,z*sz,10-1.5,6.5,5,0,10-8,5,0,0,'rgba(176,9,0,.65)',1);//CRT
			drawShape('tri',x+sx,y+sy,z*sz,10-1.5,6.5,10-2,0,10-8,5,0,0,'rgba(176,9,0,.65)',1);//RRT
			drawShape('tri',x+sx,y+sy,z*sz,2.5,7.5,2.5,1,7,6,0,0,'rgba(232,220,0,.65)',1);//LYT
			drawShape('tri',x+sx,y+sy,z*sz,10-2.5,7.5,5,1,10-7,6,0,0,'rgba(232,220,0,.65)',1);//CYT
			drawShape('tri',x+sx,y+sy,z*sz,10-2.5,7.5,10-2.5,1,10-7,6,0,0,'rgba(232,220,0,.65)',1);//RYT
			drawShape('arc',x+sx,y+sy,z*sz,5,7.5,2.5,0,2,0,0,0,'rgba(232,220,0,1)',1);//CYA
      
       sx = 6*z;
      sy = .75*z;
      sz = .12;
      drawShape('arc',x+sx,y+sy,z*sz,5,6.5,3.5,0,2,0,0,0,'rgba(176,9,0,.75)',1);//CRA
			drawShape('tri',x+sx,y+sy,z*sz,1.5,6.5,2,0,8,5,0,0,'rgba(176,9,0,.65)',1);//LRT
			drawShape('tri',x+sx,y+sy,z*sz,10-1.5,6.5,5,0,10-8,5,0,0,'rgba(176,9,0,.65)',1);//CRT
			drawShape('tri',x+sx,y+sy,z*sz,10-1.5,6.5,10-2,0,10-8,5,0,0,'rgba(176,9,0,.65)',1);//RRT
			drawShape('tri',x+sx,y+sy,z*sz,2.5,7.5,2.5,1,7,6,0,0,'rgba(232,220,0,.65)',1);//LYT
			drawShape('tri',x+sx,y+sy,z*sz,10-2.5,7.5,5,1,10-7,6,0,0,'rgba(232,220,0,.65)',1);//CYT
			drawShape('tri',x+sx,y+sy,z*sz,10-2.5,7.5,10-2.5,1,10-7,6,0,0,'rgba(232,220,0,.65)',1);//RYT
			drawShape('arc',x+sx,y+sy,z*sz,5,7.5,2.5,0,2,0,0,0,'rgba(232,220,0,1)',1);//CYA
      sx = 2.75*z;
      sy = .25*z;
      sz = .2;
      drawShape('arc',x+sx,y+sy,z*sz,5,6.5,3.5,0,2,0,0,0,'rgba(176,9,0,.75)',1);//CRA
			drawShape('tri',x+sx,y+sy,z*sz,1.5,6.5,2,0,8,5,0,0,'rgba(176,9,0,.65)',1);//LRT
			drawShape('tri',x+sx,y+sy,z*sz,10-1.5,6.5,5,0,10-8,5,0,0,'rgba(176,9,0,.65)',1);//CRT
			drawShape('tri',x+sx,y+sy,z*sz,10-1.5,6.5,10-2,0,10-8,5,0,0,'rgba(176,9,0,.65)',1);//RRT
			drawShape('tri',x+sx,y+sy,z*sz,2.5,7.5,2.5,1,7,6,0,0,'rgba(232,220,0,.65)',1);//LYT
			drawShape('tri',x+sx,y+sy,z*sz,10-2.5,7.5,5,1,10-7,6,0,0,'rgba(232,220,0,.65)',1);//CYT
			drawShape('tri',x+sx,y+sy,z*sz,10-2.5,7.5,10-2.5,1,10-7,6,0,0,'rgba(232,220,0,.65)',1);//RYT
			drawShape('arc',x+sx,y+sy,z*sz,5,7.5,2.5,0,2,0,0,0,'rgba(232,220,0,1)',1);//CYA
      
      
      drawShape('tri',x,y,z,2.5,10,7.5,10,5,8,0,0,'rgb(74,37,0)',1);//mountain
      sx = -1*z;
sy = -5*z;
sz = 3;

for (let i = 28; i > 0; i--) {
    // TOWER LOGIC: 
    // .2 is the width at the very top
    // i * 0.02 adds width for every layer down to the base
    let width = 0.3 + Math.abs(i - 14) * 0.02;

    // Use 'width' variable instead of fixed .5
    drawShape('ell',x+sx,y+sy,z*sz, 2, 2.1+i*.1, width, .15, 0, 2, 0, 0, 'rgba(255,255,255,.4)', 1);
    drawShape('ell',x+sx,y+sy,z*sz, 2, 2.1+i*.1, width, .15, 0, 2, 0, 0, 'rgba(255,255,255,.4)', 0);
    drawShape('ell',x+sx,y+sy,z*sz, 2, 2+i*.1,   width, .15, 0, 2, 0, 0, 'rgba(0,0,0,1)', 1);
}

      drawShape('rec',x,y,z,5.75,2,.5,1,0,0,0,0,'black',1);//door
        drawShape('rec',x,y,z,3.7,2,.5,1,0,0,0,0,'black',1);//door

      drawShape('rec',x,y,z,4.1,4,.5,1,0,0,0,0,'black',1);//window
      drawShape('rec',x,y,z,5,6,.5,1,0,0,0,0,'black',1);//window
      drawShape('rec',x,y,z,4.5,8.9,1,1,0,0,0,0,'black',1);//window

      sx = 5.5*z;
      sy = 7.5*z;
      sz = .2;
      drawShape('arc',x+sx,y+sy,z*sz,5,6.5,3.5,0,2,0,0,0,'rgba(176,9,0,.75)',1);//CRA
			drawShape('tri',x+sx,y+sy,z*sz,1.5,6.5,2,0,8,5,0,0,'rgba(176,9,0,.65)',1);//LRT
			drawShape('tri',x+sx,y+sy,z*sz,10-1.5,6.5,5,0,10-8,5,0,0,'rgba(176,9,0,.65)',1);//CRT
			drawShape('tri',x+sx,y+sy,z*sz,10-1.5,6.5,10-2,0,10-8,5,0,0,'rgba(176,9,0,.65)',1);//RRT
			drawShape('tri',x+sx,y+sy,z*sz,2.5,7.5,2.5,1,7,6,0,0,'rgba(232,220,0,.65)',1);//LYT
			drawShape('tri',x+sx,y+sy,z*sz,10-2.5,7.5,5,1,10-7,6,0,0,'rgba(232,220,0,.65)',1);//CYT
			drawShape('tri',x+sx,y+sy,z*sz,10-2.5,7.5,10-2.5,1,10-7,6,0,0,'rgba(232,220,0,.65)',1);//RYT
			drawShape('arc',x+sx,y+sy,z*sz,5,7.5,2.5,0,2,0,0,0,'rgba(232,220,0,1)',1);//CYA
      
      
    	sx = 3.25*z;
      sy = 5*z;
      sz = .15;
      drawShape('arc',x+sx,y+sy,z*sz,5,6.5,3.5,0,2,0,0,0,'rgba(176,9,0,.75)',1);//CRA
			drawShape('tri',x+sx,y+sy,z*sz,1.5,6.5,2,0,8,5,0,0,'rgba(176,9,0,.65)',1);//LRT
			drawShape('tri',x+sx,y+sy,z*sz,10-1.5,6.5,5,0,10-8,5,0,0,'rgba(176,9,0,.65)',1);//CRT
			drawShape('tri',x+sx,y+sy,z*sz,10-1.5,6.5,10-2,0,10-8,5,0,0,'rgba(176,9,0,.65)',1);//RRT
			drawShape('tri',x+sx,y+sy,z*sz,2.5,7.5,2.5,1,7,6,0,0,'rgba(232,220,0,.65)',1);//LYT
			drawShape('tri',x+sx,y+sy,z*sz,10-2.5,7.5,5,1,10-7,6,0,0,'rgba(232,220,0,.65)',1);//CYT
			drawShape('tri',x+sx,y+sy,z*sz,10-2.5,7.5,10-2.5,1,10-7,6,0,0,'rgba(232,220,0,.65)',1);//RYT
			drawShape('arc',x+sx,y+sy,z*sz,5,7.5,2.5,0,2,0,0,0,'rgba(232,220,0,1)',1);//CYA
      sx = 5*z;
      sy = 3.5*z;
      sz = .15;
      drawShape('arc',x+sx,y+sy,z*sz,5,6.5,3.5,0,2,0,0,0,'rgba(176,9,0,.75)',1);//CRA
			drawShape('tri',x+sx,y+sy,z*sz,1.5,6.5,2,0,8,5,0,0,'rgba(176,9,0,.65)',1);//LRT
			drawShape('tri',x+sx,y+sy,z*sz,10-1.5,6.5,5,0,10-8,5,0,0,'rgba(176,9,0,.65)',1);//CRT
			drawShape('tri',x+sx,y+sy,z*sz,10-1.5,6.5,10-2,0,10-8,5,0,0,'rgba(176,9,0,.65)',1);//RRT
			drawShape('tri',x+sx,y+sy,z*sz,2.5,7.5,2.5,1,7,6,0,0,'rgba(232,220,0,.65)',1);//LYT
			drawShape('tri',x+sx,y+sy,z*sz,10-2.5,7.5,5,1,10-7,6,0,0,'rgba(232,220,0,.65)',1);//CYT
			drawShape('tri',x+sx,y+sy,z*sz,10-2.5,7.5,10-2.5,1,10-7,6,0,0,'rgba(232,220,0,.65)',1);//RYT
			drawShape('arc',x+sx,y+sy,z*sz,5,7.5,2.5,0,2,0,0,0,'rgba(232,220,0,1)',1);//CYA
      
      sx = -6*z;
      sy = -4.5*z;
      sz = 2.1;
     //lightning bolt
      drawShape('qua',x+sx,y+sy,z*sz,4,2.25, 3.9,3.5, 4.25,3,4.25,4.25,'gold',1);//lightning bolt
      sx = -4*z;
      drawShape('qua',x+sx,y+sy,z*sz,6,2.25, 6.1,3.5, 5.75,3,5.75,4.25,'gold',1);//lightning bolt

     sx = -5*z;
      sy = .1*z;
      sz = 2;
     		drawShape('arc',x+sx,y+sy,z*sz,3.25,.5,.5,0,2,0,0,0,'rgba(255,255,255,.125)',1);//CYA
        drawShape('arc',x+sx,y+sy,z*sz,3.2,.6,.5,0,2,0,0,0,'rgba(255,255,255,.125)',1);//CYA
        drawShape('arc',x+sx,y+sy,z*sz,3.75,.5,.5,0,2,0,0,0,'rgba(255,255,255,.025)',1);//CYA
        
        drawShape('arc',x+sx,y+sy,z*sz,3.85,.55,.5,0,2,0,0,0,'rgba(255,255,255,.125)',1);//CYA
        drawShape('arc',x+sx,y+sy,z*sz,3,.5,.5,0,2,0,0,0,'rgba(255,255,255,.125)',1);//CYA
        
        drawShape('arc',x+sx,y+sy,z*sz,3.6,.63,.5,0,2,0,0,0,'rgba(255,255,255,.125)',1);//CYA
        drawShape('arc',x+sx,y+sy,z*sz,3.9,.53,.5,0,2,0,0,0,'rgba(255,255,255,.125)',1);//CYA
       sy = .75*z;
        drawShape('arc',x+sx,y+sy,z*sz,4.1,.55,.5,0,2,0,0,0,'rgba(255,255,255,.125)',1);//CYA
        drawShape('arc',x+sx,y+sy,z*sz,4.4,.59,.5,0,2,0,0,0,'rgba(255,255,255,.125)',1);//CYA
        drawShape('arc',x+sx,y+sy,z*sz,4.7,.67,.5,0,2,0,0,0,'rgba(255,255,255,.125)',1);//CYA
        drawShape('arc',x+sx,y+sy,z*sz,5.1,.75,.5,0,2,0,0,0,'rgba(255,255,255,.125)',1);//CYA
        
        drawShape('arc',x+sx,y+sy,z*sz,5.2,.65,.5,0,2,0,0,0,'rgba(255,255,255,.125)',1);//CYA
        drawShape('arc',x+sx,y+sy,z*sz,5.6,.53,.5,0,2,0,0,0,'rgba(255,255,255,.125)',1);//CYA
        
        drawShape('arc',x+sx,y+sy,z*sz,6.1,.52,.5,0,2,0,0,0,'rgba(255,255,255,.125)',1);//CYA
        drawShape('arc',x+sx,y+sy,z*sz,6.3,.55,.5,0,2,0,0,0,'rgba(255,255,255,.125)',1);//CYA
        sy = 0.1*z;
        drawShape('arc',x+sx,y+sy,z*sz,4.4,.51,.5,0,2,0,0,0,'rgba(255,255,255,.125)',1);//CYA
        drawShape('arc',x+sx,y+sy,z*sz,4.7,.63,.5,0,2,0,0,0,'rgba(255,255,255,.125)',1);//CYA
        drawShape('arc',x+sx,y+sy,z*sz,5.1,.65,.5,0,2,0,0,0,'rgba(255,255,255,.125)',1);//CYA
        drawShape('arc',x+sx,y+sy,z*sz,5.2,.55,.5,0,2,0,0,0,'rgba(255,255,255,.125)',1);//CYA
        
        drawShape('arc',x+sx,y+sy,z*sz,5.6,.5,.5,0,2,0,0,0,'rgba(255,255,255,.125)',1);//CYA
        drawShape('arc',x+sx,y+sy,z*sz,5.9,.6,.5,0,2,0,0,0,'rgba(255,255,255,.125)',1);//CYA
        
        drawShape('arc',x+sx,y+sy,z*sz,6.1,.5,.5,0,2,0,0,0,'rgba(255,255,255,.125)',1);//CYA
        drawShape('arc',x+sx,y+sy,z*sz,6.3,.55,.5,0,2,0,0,0,'rgba(255,255,255,.125)',1);//CYA
       
        drawShape('arc',x+sx,y+sy,z*sz,6.5,.55,.5,0,2,0,0,0,'rgba(255,255,255,.125)',1);//CYA
        
        drawShape('arc',x+sx,y+sy,z*sz,6.6,.5,.5,0,2,0,0,0,'rgba(255,255,255,.125)',1);//CYA
        drawShape('arc',x+sx,y+sy,z*sz,6.8,.6,.5,0,2,0,0,0,'rgba(255,255,255,.125)',1);//CYA
        
        drawShape('arc',x+sx,y+sy,z*sz,7,.5,.5,0,2,0,0,0,'rgba(255,255,255,.125)',1);//CYA
        drawShape('arc',x+sx,y+sy,z*sz,6.9,.55,.5,0,2,0,0,0,'rgba(255,255,255,.125)',1);//CYA
        break;
    case 17://star item
      for (let i=0;i<10;i++){
        drawShape('ell',x,y,z,5,2.65,3-i*.01,2.5-i*.01,0,2,0,0,'rgba(160,116,77,1)',0)
      }


      sx = 1.25*z;
      sy = 3.8*z;
      sz = .75;
      const cx = 5, cy = 5;      // center in your 10x10 local grid
      const R  = 3.2;            // outer radius (long points)
      const r  = 1.6;            // inner radius (between points)
      const N  = 8;
      const pts = [];

      // build 16 vertices (outer/inner alternating), start at top
      for (let k = 0; k < 2*N; k++) {
        const ang = -Math.PI/2 + k * (Math.PI / N);   // 22.5 steps
        const rad = (k % 2 === 0) ? R : r;
        pts.push([cx + rad * Math.cos(ang), cy + rad * Math.sin(ang)]);
      }

      // filled star (triangle fan from center)
      for (let k = 0; k < pts.length; k++) {
        const k2 = (k + 1) % pts.length;
        drawShape('tri', x+sx, y+sy, z*sz, cx, cy, pts[k][0], pts[k][1], pts[k2][0], pts[k2][1], 0, 0, 'gold', 1);
      }

      // outline (optional)
      for (let k = 0; k < pts.length; k++) {
        const k2 = (k + 1) % pts.length;
        drawShape('lin', x+sx, y+sy, z*sz, pts[k][0], pts[k][1], pts[k2][0], pts[k2][1], 0, 0, 0, 0, 'black', 0);
      }
      for (let i=0;i<5;i++){
      drawShape('ell',x,y,z,5,5.25,.1-i*.01,.1-i*.01,0,2,0,0,'lightgray',0)

     }
      for (let i=0;i<10;i++){
      drawShape('ell',x,y,z,5,5.1,.1-i*.01,.1-i*.01,0,2,0,0,'rgba(160,116,77,1)',0)

      }
      drawShape('qua',x,y,z,5,5.25, 5,5.5, 5.1,5.5, 5.04,5.25,'gold',1)

      break;
    case 18://Lunacy spell (the moon)
    drawShape('tri',x,y,z, 5,1, 0,10, 10,10,0,0, 'rgba(190,200,255,.15)',1);  

    sx = -15*z;
    sy = 1*z;
    sz = 4;
     // drawShape('arc',x,y,z,5,5,5,0,2,0,0,0,'rgba(255,255,255,.125)',1);
      //drawShape('arc',x,y,z,5,5,4.75,0,2,0,0,0,'rgba(255,255,255,.125)',1);
      //drawShape('arc',x,y,z,5,5,4.5,0,2,0,0,0,'rgba(255,255,255,.125)',1);
      //drawShape('arc',x,y,z,5,5,4.25,0,2,0,0,0,'rgba(255,255,255,.125)',1);

    drawShape('arc',x+sx,y+sy,z*sz,5,1,1,0,2,1,0,0,'gold',1);//moon
      drawShape('arc',x+sx,y+sy,z*sz,5,1,1,0,2,1,0,0,'rgba(0,0,0,.25)',1);//moon
            drawShape('ell',x+sx,y+sy,z*sz,4.5,1,1.25,.75,2,2,0,0,'rgba(0,0,0,.5)',1);//moon

      sx = -16*z;
    sy = 1*z;
    sz = 4;
      drawShape('tri',x+sx,y+sy,z*sz, 5.5,.4, 5,.6, 5.1,.6,0,0, 'rgba(0,0,0,.55)',1);  
      drawShape('tri',x+sx,y+sy,z*sz, 5,.75, 5,1.25, 4.9,1.25,0,0, 'rgba(0,0,0,.55)',1);  
      drawShape('tri',x+sx,y+sy,z*sz, 5,1.5, 5.25,1.45, 5.1,1.5,0,0, 'rgba(0,0,0,.75)',1);  
     // for(let h=0;h<20;h++){ //grid lines
		  //drawShape('lin',x,y,.5*z,h,0,5,5, 0,0,0,0,'green',0);//x line
		 // drawShape('lin',x,y,.5*z,0,h,5,5,0,0,0,0,'green',0);
      
    //  if (h%2 == 0){
     //   drawShape('lin',x,y,.5*z,h,0,5,5,0,0,0,0,'red',0);
     //   drawShape('lin',x,y,.5*z,0,h,5,5,0,0,0,0,'red',0);
     // }
	  //}
      /*drawShape('qua',x,y,z,5.5,.14,4.5,.14,2.5,10,7.5,10,'rgba(255,255,0,.05)',1);
      drawShape('qua',x,y,z,5.5,.14,4.5,.14,2,10,8,10,'rgba(255,255,0,.05)',1);
      drawShape('qua',x,y,z,5.5,.14,4.5,.14,1.5,10,8.5,10,'rgba(255,255,0,.05)',1);

      drawShape('ell',x,y,z,2,1.1, 2,.9, 0,2,0,0,'rgba(255,255,255,.15)',1);//cloud
      drawShape('ell',x,y,z,2.9,.9, 2,.9, 0,2,0,0,'rgba(255,255,255,.15)',1);//cloud
      drawShape('ell',x,y,z,2.3,1, 2,.9, 0,2,0,0,'rgba(255,255,255,.15)',1);//cloud
      drawShape('ell',x,y,z,8,1.1, 2,.9, 0,2,0,0,'rgba(255,255,255,.15)',1);//cloud

      drawShape('ell',x,y,z,3.1,1.1, 2,.9, 0,2,0,0,'rgba(255,255,255,.15)',1);//cloud
      drawShape('ell',x,y,z,3.5,.9, 2,.9, 0,2,0,0,'rgba(255,255,255,.15)',1);//cloud
      drawShape('ell',x,y,z,3.7,1.2, 2,.9, 0,2,0,0,'rgba(255,255,255,.15)',1);//cloud
      drawShape('ell',x,y,z,3.9,1, 2,.9, 0,2,0,0,'rgba(255,255,255,.15)',1);//cloud
      
      drawShape('arc',x,y,z,5,1,1,0,2,1,0,0,'gold',1);//moon
      drawShape('arc',x,y,z,5.1,1,1,0,2,1,0,0,'rgba(0,0,0,.25)',1);//moon
      drawShape('tri',x,y,z, 5.5,.4, 5,.6, 5.1,.6,0,0, 'rgba(0,0,0,.55)',1);  
      drawShape('tri',x,y,z, 5,.75, 5,1.25, 4.9,1.25,0,0, 'rgba(0,0,0,.55)',1);  
      drawShape('tri',x,y,z, 5,1.5, 5.25,1.45, 5.1,1.5,0,0, 'rgba(0,0,0,.75)',1);  

      drawShape('ell',x,y,z,4.4,1.1, 2,.9, 0,2,0,0,'rgba(255,255,255,.15)',1);//cloud
      drawShape('ell',x,y,z,4.9,.9, 2,.9, 0,2,0,0,'rgba(255,255,255,.15)',1);//cloud
      drawShape('ell',x,y,z,5.3,1, 2,.9, 0,2,0,0,'rgba(255,255,255,.15)',1);//cloud
      drawShape('ell',x,y,z,5.6,1.1, 2,.9, 0,2,0,0,'rgba(255,255,255,.15)',1);//cloud
      
      drawShape('ell',x,y,z,6.4,1.1, 2,.9, 0,2,0,0,'rgba(255,255,255,.15)',1);//cloud
      drawShape('ell',x,y,z,6.9,.9, 2,.9, 0,2,0,0,'rgba(255,255,255,.15)',1);//cloud
      drawShape('ell',x,y,z,7.3,1, 2,.9, 0,2,0,0,'rgba(255,255,255,.15)',1);//cloud
      drawShape('ell',x,y,z,7.6,1.1, 2,.9, 0,2,0,0,'rgba(255,255,255,.15)',1);//cloud
      sx=3*z;
      sy=5*z; 
      sz=.45;
      drawShape('qua',x+sx,y+sy,z*sz,4.7,5.5,///*tr*/ //3.5,7.5,/*br*/ 4.4,7.7,/*bl*/ 5,6.5,'lightgray',1);//l-thigh
			//drawShape('qua',x+sx,y+sy,z*sz,4.5,9.1,/*tr*/4.5,9.6,/*br*/ 2,9.6,/*l*/4.5,8.6,/*tl*/'darkgray',1);//l-foot
			//drawShape('qua',x+sx,y+sy,z*sz,4.5,9.5,/*br*/ 4.5,7.7,/*tr*/ 3.3,7.3,/*tl*/ 3.9,9,/*bl*/'darkgray',1);//l-calf
			//drawShape('qua',x+sx,y+sy,z*sz,4.5,9.5,/*br*/ 4.5,7.7,/*tr*/ 3.3,7.3,/*tl*/ 3.9,9,/*b*/'gray',0);//l-calf
			//drawShape('arc',x+sx,y+sy,z*sz,4.25,2.65, .63,0, 3,0, 0,0,'darkgray',1);//l-shoulder
			//drawShape('arc',x+sx,y+sy,z*sz,4.25,2.65, .63,0, 3,0, 0,0,'gray',0);//l-shoulder-shadow
			//drawShape('ell',x+sx,y+sy,z*sz,5.15,3.6,1.15,1.75,0,0,6,0,'lightgray',1);//torso
			//drawShape('qua',x+sx,y+sy,z*sz,4.6,1.5, 5.5,1.5 ,6,2.5, 4.1,2.5,'darkgray',1);//neck
			//drawShape('arc',x+sx,y+sy,z*sz,5,1,.9,0,2,0,0,0,'lightgray',1);//head
      
      //drawShape('tri',x+sx,y+sy,z*sz,3.5,1.5, 4.3,.25, 4.9,2,0,0,'lightgray',1);//helm nose

			//drawShape('tri',x+sx,y+sy,z*sz,3.5,1.5,4.8,1.8,4.9,2,0,0,'rgba(0,0,0,.2)',1);//helm nose
      //drawShape('tri',x+sx,y+sy,z*sz,4.1,.9, 5.6,.4, 4,-.3,0,0,'lightgray',1);//helm nose

     // drawShape('arc',x+sx,y+sy,z*sz,4.95,1,1,0,2,0,0,0,'rgba(0,0,0,.05)',1);//head
			//drawShape('arc',x+sx,y+sy,z*sz,5,1,.9,0,.7,0,0,0,'rgba(0,0,0,.1)',1);//head
			//drawShape('arc',x+sx,y+sy,z*sz,4.9,.9,.9,0,.7,0,0,0,'lightgray',1);//head
			//drawShape('arc',x+sx,y+sy,z*sz,5,1,.8,.7,0,0,0,0,'lightgray',1);//head


     // drawShape('qua',x+sx,y+sy,z*sz,4.5,5.5,/*tl*/6,4.5,/*tr*/ 6.5,7.7,/*br*/ 5.8,8,/*bl*/ 'lightgray',1);//r-thigh
			//drawShape('qua',x+sx,y+sy,z*sz,5.5,8,/*tl*/6.25,7.25,/*tm*/6.75,8,/*tr*/ 6.25,9.5,/*b*/'darkgray',1);//r-calf
			//drawShape('qua',x+sx,y+sy,z*sz,5.5,8,/*tl*/6.25,7.25,/*tm*/6.75,8,/*tr*/ 6.25,9.5,/**/'gray',0);//r-calf
			//drawShape('qua',x+sx,y+sy,z*sz,6.25,9,/*t*/5.6,9.6,/*bl*/6.25,10,/*bm*/ 6.9,9.6,/*br*/'darkgray',1);//r-foot
			//drawShape('tri',x+sx,y+sy,z*sz,6.25,9.5,/*t*/5.75,10,/*bl*/6.75,10,/*br*/ 0,0,'gray',1);//r-toe
			//drawShape('qua',x+sx,y+sy,z*sz,6.2,4.3,7.25,7.25,5.1,6.3,4.75,5.25,'darkgray',1);//hip armor
			//drawShape('qua',x+sx,y+sy,z*sz,6.2,4.3,7.25,7.25,5.1,6.3,4.75,5.25,'gray',0);//hip armor
			//drawShape('qua',x+sx,y+sy,z*sz,4.5,7, 5.2,5, 4.5,5.2, 4.2,5,'darkgray',1);//groin armor
			//drawShape('qua',x+sx,y+sy,z*sz,4.5,7, 5.2,5, 4.5,5.2, 4.2,5,'gray',0);//groin armor

		
      //drawShape('qua',x+sx,y+sy,z*sz,4,4, 5,3.75, 4.7,4.4, 4.5,4.4,'rgb(185,122,87)',1);//hand left
     // drawShape('qua',x+sx,y+sy,z*sz,4,4, 5,4, 4.7,4.4, 4.3,4.4,'rgb(185,122,87)',1);//hand left

		  //drawShape('qua',x+sx,y+sy,z*sz,2.75,1.75, 4.5,2.75, 4.5,5.8, 2.75,4.8,'gray',1);//shield top
			//drawShape('tri',x+sx,y+sy,z*sz,2.75,4.8,4.5,5.8,3.5,7.5,0,0,'gray',1);//shield bot
			//drawShape('lin',x+sx,y+sy,z*sz,3.5,7.6,3.45,2.1,0,0,0,0,'blue',0);//shield cross |
			//drawShape('lin',x+sx,y+sy,z*sz,2.75,4,4.5,5,0,0,0,0,'blue',0);//shield cross--

			//drawShape('tri',x+sx,y+sy,z*sz,/*tl*/ 5.55,3.55, /*tr*/6.3,2.5, /*br*/7.7,4, 0,0,'lightgray',1);//r-arm
		//	drawShape('tri',x+sx,y+sy,z*sz,/*tl*/ 5.6,3.5, /*tr*/6.3,2.5, /*br*/7.7,4, 0,0,'gray',0);//r-arm

			//drawShape('qua',x+sx,y+sy,z*sz,5.9,5, 5.9,5.3, 7.2,5.7, 7.2,5.3,'gold',1);//sword-hilt
			//drawShape('arc',x+sx,y+sy,z*sz,6.2,5.75,.4,0,3,0,0,0,'darkgray',1);//r-hand
			//drawShape('tri',x+sx,y+sy,z*sz,1,4.1, 5.9,4.85, 6.1,5.65,0,0,'white',1);//sword-blade
			//drawShape('qua',x+sx,y+sy,z*sz,6,4, 5.6,5.2, 6,6.3, 6.1,5.5,'gold',1);//sword-crossguard
			//drawShape('arc',x+sx,y+sy,z*sz,6,3, .63,0, 3,0, 0,0,'darkgray',1);//r-shoulder
			//drawShape('arc',x+sx,y+sy,z*sz,6,3, .63,0, 3,0, 0,0,'gray',0);//r-shoulder
			//drawShape('tri',x+sx,y+sy,z*sz,5.3,1.3, 4.95,.05, 5.4,.17, 5.4,.3,'black',1);//helmet visor
      //drawShape('qua',x+sx,y+sy,z*sz,5.8,.7, 3.85,.8, 4.05,.5, 4.15,.6,'black',1);//helmet visor

      //drawShape('tri',x+sx,y+sy,z*sz,/*br*/ 7.9,3.9, /*tr*/7.3,3.3, /*l*/6.5,5.5, 0,0,'lightgray',1);//r-forearm
			//drawShape('tri',x+sx,y+sy,z*sz,/*br*/ 7.9,3.9, /*tr*/7.3,3.3, /*l*/6.5,5.5, 0,0,'gray',0);//r-forearm

      //drawShape('qua',x+sx,y+sy,z*sz,6.9,4.9, 6.1,5.1, 6.4,5.5, 6.7,5.6,'rgb(185,122,87)',1);//hand right
      
      //drawShape('pol',x,y,z,0,9.5, 3.9,9.3, 5.75,9.25, 8.5,9.3,'rgb(185,122,87)',1, 10,9.5);//ground
      //drawShape('qua',x+sx,y+sy,z*sz,6.25,9,/*t*/5.6,9.6,/*bl*/6.25,10,/*bm*/ 6.9,9.6,/*br*/'darkgray',1);//r-foot
     // drawShape('rec',x,y,z,0,9.5, 10,.5, 5.75,9.25, 8.5,9.3,'rgb(185,122,87)',1, 10,9.5);//ground
      //drawShape('pol',x,y,z,7,10, 6.3,9.5, 5,9.4, 4,9.5,'rgba(112,146,190,.75)',1, 3,10);//ground
      //*/
      break;
    case 19://the sun Solar Rite / Hymn to the sun? item
      

      drawShape('qua',x,y,z,0,7.5,10,7.5,7.5,2.5,2.5,2.5,'rgba(128,64,0,1)',1);
			drawShape('qua',x,y,z,.2,7.1,9.8,7.1,7.5,2.5,2.5,2.5,'rgba(255,255,128,1)',1);
			drawShape('lin',x,y,z,5,7.5,5,2.5,0,0,0,0,'rgba(128,64,0,.85)',1);
			drawShape('arc',x,y,z,3.75,3.8,1.79,1.25,1.75,0,0,0,'rgba(255,255,128,1)',1);
			drawShape('arc',x,y,z,6.25,3.8,1.79,1.25,1.75,0,0,0,'rgba(255,255,128,1)',1);
      
      drawShape('qua',x,y,z,4.77,7.2, 4.9,2.4, 4,6, 4.488,6.51,'rgba(0,0,0,.1)',1);
      drawShape('qua',x,y,z,5.188,7.2, 5.1,2.4, 6,6, 5.512,6.51,'rgba(0,0,0,.1)',1);



			drawShape('arc',x,y,z,2.5,7.9,2.4,1.1,1.9,0,0,0,'rgba(248,179,16,.85)',1);
			drawShape('arc',x,y,z,7.5,7.9,2.4,1.1,1.9,0,0,0,'rgba(248,179,16,.85)',1);
      
      for (let i = 0;i<40;i++){
        drawShape('arc',x,y,z,2.5,7.89, 2.39-i*.05,1.1,1.9,0,0,0,'rgba(0,0,0,.25)',0);
			  drawShape('arc',x,y,z,7.5,7.89, 2.39-i*.05,1.1,1.9,0,0,0,'rgba(0,0,0,.25)',0);
      }
      drawShape('rec',x,y,z,0.2,7.13,9.6,.35,0,0,0,0,'rgb(128,64,0)',1);

      drawShape('pol',x,y,z,4.75,8, 4.9,2.42, 5.1,2.42, 5.2,8,'rgba(63,72,204,.45)',1, 5,7.8);
      
      //title
      sx = 2.9*z;
      sy = 2.3*z;
      drawText(x+sx,y+sy,2,.3,'  ','red',z)
      
      //left page
      sx = 2.45*z;
      sy = 2.9*z;
      drawText(x+sx,y+sy,2.5,.75,'      ','red',z)

      sx = 2*z;
      sy = 3.75*z;
      drawText(x+sx,y+sy,2.75,.7,'     ','red',z)

       sx = 1.6*z;
      sy = 4.758*z;
      drawText(x+sx,y+sy,2.9,.8,'      ','red',z)

      //right page
       sx = 5.3*z;
      sy = 2.3*z;
       drawText(x+sx,y+sy,2,.75,'       ','red',z)
       sx = 6*z;
      sy = 4.3*z;
       drawText(x+sx,y+sy,2.25,1.25,'        ','red',z)
      drawShape('pol',x,y,z, 6.5,2.9, 6.25,4.25, 7.1,3.1,5.75,4, 'gold',1,7.25,4);
      drawShape('pol',x,y,z, 5.9,3.1, 6.75,4.25, 6.25,3, 6.5,4.25, 'gold',1,6.5,3.5);
      drawShape('ell',x,y,z,6.5,3.65, .6,.6 ,0,2,0,0,'rgba(255,255,0,.55)',1);//sun shadow

      drawShape('ell',x,y,z,6.5,3.65, .5,.5 ,0,2,0,0,'gold',1);//sun
      drawShape('ell',x,y,z,6.5,3.65, .5,.5 ,0,2,0,0,'rgba(0,0,0,.25)',0);//sun shadow

      break;
    case 20://Horn of judgement item

      drawShape('arc', x, y, z, 5, 5, 4, 0, 2, 0, 0, 0, 'rgba(255,255,0,.05)', 1);
      drawShape('arc', x, y, z, 5, 5, 4.5, 0, 2, 0, 0, 0, 'rgba(255,255,0,.05)', 1);
      drawShape('arc', x, y, z, 5, 5, 5, 0, 2, 0, 0, 0, 'rgba(255,255,0,.05)', 1);

      sx = 0*z;
      sy = .5*z;
      sz = .9;
      
      for (let i = 0; i < 50; i++) {
        let t = i / 50;                   // 0  1
        let cx = 7.5 - t * 5;              // moves left
        let cy = 7.75 - Math.pow(t, 2) * 8; // curves upward (parabola)
        let r  = 2 - t * 2;                // shrinks radius gradually
        drawShape('arc', x+sx, y+sy, z*sz, cx, cy, r, 0, 2, 0, 0, 0, 'gold', 1);
      }

      for (let i = 0; i < 50; i++) {
        let t = i / 50;                   // 0  1
        let cx = 7.5 - t * 5;              // moves left
        let cy = 7.75 - Math.pow(t, 2) * 8; // curves upward (parabola)
        let r  = 2 - t * 2;                // shrinks radius gradually
        drawShape('arc', x+sx, y+sy, z*sz, cx, cy, r, .3, .9, 0, 0, 0, 'rgba(0,0,0,.05)', 1);
        drawShape('arc', x+sx, y+(1*z)+sy, z*sz, cx, cy, r, .3, .9, 0, 0, 0, 'rgba(0,0,0,.05)', 1);

      }
      drawShape('arc',x+sx,y+sy,z*sz,7.5,7.75, 2.02,0,2,0,0,0,'rgba(0,0,0,.45)',0);//horn mouth
      drawShape('arc',x+sx,y+sy,z*sz,7.5,7.75, 2,0,2,0,0,0,'rgba(0,0,0,.45)',0);//horn mouth
      drawShape('arc',x+sx,y+sy,z*sz,7.5,7.75, 2.01,0,2,0,0,0,'rgba(0,0,0,.45)',0);//horn mouth

      drawShape('arc',x+sx,y+sy,z*sz,7.5,7.75, 1.8,0,2,0,0,0,'rgba(0,0,0,.45)',1);//horn mouth
      drawShape('pol',x+sx,y+sy,z*sz,2.95,2, 2.6,.5, 2.55,0, 2.6,0,'gold',1 ,3.36,1.5);//horn mouth
      drawShape('arc',x+sx,y+sy,z*sz,7.5,7.75, 1.8,-.1,.9,0,0,0,'rgba(0,0,0,.15)',1);//horn mouth

    break;
    case 21://ouroboros monster
      for (let i = 0; i < 40; i++) {
        drawShape('ell',x,y,z,5,.6+i*.02,      0+i*.07,   0+i*.01,     0,1.25,1.24,0,`rgba(0,128,0,1)`,0)
      }
      for (let i=0;i<40;i++){  
        drawShape('ell',x,y,z,5,1.65+i*.035,3+i*.05,.75+i*.01, 0,2,1,0,`rgba(0,128,0,1)`,0)
      }
      drawShape('pol',x,y,z,4,10, 3.5,8, 5,5, 4.5,9,'rgba(51,26,0,1)',1,4,8);//root
      drawShape('pol',x,y,z,6,10, 6.5,8, 5,5, 5.5,9,'rgba(51,26,0,1)',1,6,8);//root
      drawShape('pol',x,y,z,2.5,10, 3,8, 5,5, 2,9,'rgba(51,26,0,1)',1,3.5,8);//root
      drawShape('pol',x,y,z,2,10, 4.5,8, 5,5, 3.5,9,'rgba(51,26,0,1)',1,4,8);//root
      drawShape('pol',x,y,z,2,9.5, 4.5,8, 5,5, 4.5,9,'rgba(51,26,0,1)',1,4,8);//root
      drawShape('pol',x,y,z,5.5,1.5, 6,5, 5.75,9.75, 3.5,5,'rgba(103,50,0,1)',1,4.5,1.5);//trunk
      drawShape('pol',x,y,z,5,2, 2,1.5, .5,2.5, 2,2.25,'rgba(93,40,0,1)',1,4.1,3);//branch
      drawShape('pol',x,y,z,5,2.5, 2,2, .5,2.5, 2,2.25,'rgba(0,0,0,.4)',1,4.1,3);//branch
      drawShape('pol',x,y,z,5,3, 8,3.25, 9.5,4, 7.5,3.5,'rgba(93,40,0,1)',1,6,4);//branch
      drawShape('pol',x,y,z,5,3.5, 7.5,3.3, 9.5,4, 7.5,3.5,'rgba(0,0,0,.4)',1,6,4);//branch
      /////////////////////////////////////
      for (let i=0;i<60;i++){
        drawShape('ell',x,y,z,5,9,3-i*.01,.75-i*.01, 0,1,2,0,`rgba(${0},${64-i},${0},1)`,0)
        drawShape('ell',x,y,z,5,8,3-i*.01,.75-i*.01, 0,1,2,0,`rgba(${0},${64-i},${0},1)`,0)
        drawShape('ell',x,y,z,5,7.5,3-i*.01,.75-i*.01, 0,1,2,0,`rgba(${0},${64-i},${0},1)`,0)
        drawShape('ell',x,y,z,5,8.5,3.9-i*.01,.75-i*.01, 0,1,2,0,`rgba(${0},${64-i},${0},1)`,0)
        drawShape('ell',x,y,z,5,6.9,2.5-i*.01,.75-i*.01, 0,1,1.7,0,`rgba(${0},${64-i},${0},1)`,0)
      }
      /////////////////////////////////////
      drawShape('pol',x,y,z,4.5,1.5, 8,1.5, 9,3, 7.5,2.5,'rgba(93,40,0,1)',1,5.5,2.5);//branch
      drawShape('pol',x,y,z,4.5,1.5, 8,2.3, 9,3, 7.5,2.5,'rgba(0,0,0,.4)',1,5.5,2.5);//branch
      drawShape('pol',x,y,z,7.5,10, 7,8, 5,5, 8,9,'rgba(51,26,0,1)',1,6.5,8);//root
      drawShape('pol',x,y,z,8,10, 5.5,8, 5,5, 6.5,9,'rgba(51,26,0,1)',1,6,8);//root
      drawShape('pol',x,y,z,8,9.5, 5.5,8, 5,5, 5.5,9,'rgba(51,26,0,1)',1,6,8);//root
      //leftmost roots
      drawShape('pol',x,y,z,5,1, 6,5, 6.25,9.75, 5,5,'rgba(103,50,0,1)',1,2,9.5);//trunk
      drawShape('pol',x,y,z,1,9.5, 2,7.5, 5,7, 3.5,7.5,'rgba(120,70,37,1)',1,2.25,8.25);//root
      drawShape('pol',x,y,z,1.5,10, 2,8, 5,7, 3.5,7.9,'rgba(160,116,77,1)',1,2.25,8.25);//root
      //rightmost roots
      drawShape('pol',x,y,z,9,9.5, 8,7.5, 5,7, 6.5,7.5,'rgba(120,70,37,1)',1,7.75,8.25);//root
      drawShape('pol',x,y,z,8.5,10, 8,8, 5,7, 6.5,7.9,'rgba(160,116,77,1)',1,7.75,8.25);//root   
      //middle roots
      drawShape('pol',x,y,z,3.5,10, 2,8, 5,5, 3.5,7.9,'rgba(140,96,57,1)',1,3.25,8.25);//root
      drawShape('pol',x,y,z,6.5,10, 8,8, 5,5, 6.5,7.9,'rgba(140,96,58,1)',1,6.75,8.25);//root
      drawShape('pol',x,y,z,5,10, 3.5,8, 5,5, 5,7.55,'rgba(120,70,37,1)',1,4.5,8);//root
      drawShape('pol',x,y,z,5,1, 4,5, 3.75,9.75, 5,5,'rgba(113,60,0,1)',1,8,9.5);//trunk
      //////////////////////////////
      for (let i=0;i<60;i++){
        drawShape('ell',x,y,z,5,8.5,3.9-i*.01,.75-i*.01, 0,2,1,0,`rgba(${0},${64+i},${0},1)`,0)
      }
      /////////////////////////////
      drawShape('pol',x,y,z,5,1, 5.3,5, 8,9.5, 5,5,'rgba(0,0,0,.25)',1,5.1,3.5);//trunk
      drawShape('pol',x,y,z,4.9,1, 5,5, 3.75,9.75, 4.55,6,'rgba(0,0,0,.25)',1,4.5,5);//trunk
      ////////////////////////
      for (let i=0;i<60;i++){
        drawShape('ell',x,y,z,5,8,2.7-i*.01,.75-i*.01, 0,1.9,1.1,0,`rgba(${0},${64+i},${0},1)`,0) 
      }
      ///////////////////////////////
      drawShape('pol',x,y,z,5,10, 6.5,8, 5,5, 5,7.55,'rgba(120,70,37,1)',1,5.5,8);//root
      drawShape('pol',x,y,z,5,10, 4.5,8, 5,5, 5.5,9,'rgba(80,30,0,1)',1,5,8);//root  
      //canopy front lower
      for (let i=0;i<40;i++){
        drawShape('ell',x,y,z,5,1.65+i*.035,3+i*.05,.75+i*.01, 0,1,2,0,`rgba(0,128,0,1)`,0)
      }
      /////Halo/Saturn ring style DO NOT DELETE
      /*const n = 60;                    // more = smoother gradient
      for (let i = 0; i < n; i++) {
        const t  = i/(n-1);            // 01
        const rx = 3   - 0.6*t;        // shrink radii slightly each layer
        const ry = 0.5 - 0.12*t;

        // ---- back half (top) darker: angles 0  1
        const aBack = 0.25 + 0.55*t;   // 0.250.8 alpha ramp
        drawShape('ell', x, y, z,
            5, 2.65, rx, ry,
            0, 0, 1,
        `rgba(80,50,30,${aBack})`, 0);
        // ---- front half (bottom) lighter: angles 1  2
        const aFront = 0.35 + 0.45*(1-t); // 0.80.35 fade
        drawShape('ell', x, y, z,
            5, 2.65, rx, ry,
            0, 1, 2,
            `rgba(200,150,100,${aFront})`, 0);
      }*/
   
      for (let i=0;i<60;i++){
        drawShape('ell',x,y,z,5,9,3-i*.01,.75-i*.01, 0,2,1,0,`rgba(${0},${64+i},${0},1)`,0)
        drawShape('ell',x,y,z,5,7.45,3-i*.01,.75-i*.01, 0,2,1,0,`rgba(${0},${64+i},${0},1)`,0)
        drawShape('ell',x,y,z,5,6.9,2.5-i*.01,.75-i*.01, 0,2.7,1,0,`rgba(${0},${64+i},${0},1)`,0)
        // drawShape('ell',x,y,z,1.8,6.95,2.5-i*.01,.75-i*.01, 0,0,.25,0,`rgba(${0},${64+i},${0},1)`,0)
        // drawShape('ell',x,y,z,1.8,6.95,2.5-i*.01,.75-i*.01, 0,0,.23,0,`rgba(${0},${64+i},${0},1)`,0)
        drawShape('ell',x,y,z*.8,5,7.8,2.3-i*.01,1.6-i*.01, 0,1.7,.6,0,`rgba(${0},${64+i},${0},1)`,0)
        //BOAT from above/Leaf? drawShape('ell',x,y,z,    1+i*.001, 6+i*.001,        2-i*.01,   0+i*.01,  0,    0,   2,    0,   `rgba(${0},${64+i},${0},1)`,0)
        drawShape('ell',x,y,z,    4.4+i*.001, 5.69+i*.001,        0+i*.001,   0+i*.002,  0,    .75,   1.5,    0,   `rgba(${255},${255},${255},1)`,0)
        drawShape('ell',x,y,z,    4.67+i*.000005, 5.680+i*.001,        0+i*.001,   0+i*.002,  0,    1.5,   .2,    0,   `rgba(${255},${255},${255},1)`,0)
        //head
        drawShape('ell',x,y,z,    4.5+i*.001, 5.25+i*.001,        0.2+i*.005,   0+i*.005,  0,    0,   2,    0,   `rgba(${0},${64+i},${0},1)`,0)
        //upper jaw
        drawShape('ell',x,y,z,    4.5+i*.001, 5.5+i*.001,        .5-i*.005,   0+i*.005,  0,    1,   2,    0,   `rgba(${0},${128-i},${0},1)`,0)
        //bottom jaw     
        drawShape('ell',x,y,z,    4.51+i*.001, 5.4+i*.001,        .49-i*.005,   0+i*.01,  0,    2,   1,    0,   `rgba(${0},${64+i},${0},1)`,0)
      }
      drawShape('pol',x,y,z,    4.55, 5.6,   4.5, 6.3,   4.4,6.4,   4.55,6.3,   `rgba(${128},${0},${0},1)`,1, 4.6,6.5)
      drawShape('ell',x,y,z,    4.8, 5.25,   .2, .15,   0,   1.6,  .5,   0,   `rgba(${255},${255},${0},1)`,1, 4.6,6.5)
      drawShape('ell',x,y,z,    4.3, 5.25,   .2, .15,   0,   .5,  1.4,   0,   `rgba(${255},${255},${0},1)`,1, 4.6,6.5)
      drawShape('ell',x,y,z,    4.86, 5.26,   .05, .12,   0,   -.45,  .25,   0,   `rgba(${0},${0},${0},1)`,1, 4.6,6.5)
      drawShape('ell',x,y,z,    4.21, 5.26,   .05, .12,   0,   .75,  -.5,   0,   `rgba(${0},${0},${0},1)`,1, 4.6,6.5)
      ///jormungandr head
    
      break;
    case 20: //HEART
			drawShape('tri',x,y,z,0,6.59,5,10,10,6.6,0,0,'rgb(255,72,72)',1);
			drawShape('arc',x,y,z,2.25,3.7,3.63,0,6,0,0,0,'rgb(255,72,72)',1);
			drawShape('arc',x,y,z,7.75,3.7,3.63,0,6,0,0,0,'rgb(255,72,72)',1);
			drawShape('arc',x,y,z,5,7,3,3,0,0,0,0,'rgb(255,72,72)',1);
			break;
  	case 20.1: //HEARTShield
			drawShape('tri',x,y,z,-1.26,4.9, 5,13, 10,6.6, 0,0,'gray',1);
			drawShape('arc',x,y,z,2.25,3.7,3.63,0,6,0,0,0,'gray',1);
			drawShape('arc',x,y,z,7.75,3.7,3.63,0,6,0,0,0,'gray',1);
			drawShape('arc',x,y,z,5,7,3,3,0,0,0,0,'gray',1);

			break;
  	case 13: //WBOOT
			drawShape('qua',x,y,z,4.9,1, 5.1,.7, 5.22,.9, 3.4,6.4,'gray',1);
			drawShape('qua',x,y,z,4.75,2, 4.75,2, 5.5,4.2, 3.3,6.4,'rgba(128,64,0,1)',1);
			drawShape('qua',x,y,z,3.5,1, 5,9.45, 8.3,7.4, 8.5,1,'rgba(128,64,0,1)',1)
			drawShape('qua',x,y,z,3.75,1, 6,9.45, 4.5,7.4, 8,1,'rgba(0,0,0,.06)',1)
			drawShape('qua',x,y,z*1.1,7.8,1, 8,.7, 8.3,4.2, 6.3,6.4,'lightgray',1);
			drawShape('qua',x,y,z*1.1,7.8,1, 8,.7, 8.02,.9, 6.3,6.4,'gray',1);
			drawShape('ell',x,y,z,4,7.2, 2.9,2.4,1,0,6,0,'rgba(128,64,0,1)',1);
			drawShape('ell',x,y,z,4,7.2, 2.9,2.4,1,0,6,0,'rgba(0,0,0,.06)',1);
			break;
    case 22: //FIRE
		  drawShape('arc',x,y,z,5,6.5,3.5,0,2,0,0,0,'rgba(176,9,0,.75)',1);//CRA
			drawShape('tri',x,y,z,1.5,6.5,2,0,8,5,0,0,'rgba(176,9,0,.65)',1);//LRT
			drawShape('tri',x,y,z,10-1.5,6.5,5,0,10-8,5,0,0,'rgba(176,9,0,.65)',1);//CRT
			drawShape('tri',x,y,z,10-1.5,6.5,10-2,0,10-8,5,0,0,'rgba(176,9,0,.65)',1);//RRT
			drawShape('tri',x,y,z,2.5,7.5,2.5,1,7,6,0,0,'rgba(232,220,0,.65)',1);//LYT
			drawShape('tri',x,y,z,10-2.5,7.5,5,1,10-7,6,0,0,'rgba(232,220,0,.65)',1);//CYT
			drawShape('tri',x,y,z,10-2.5,7.5,10-2.5,1,10-7,6,0,0,'rgba(232,220,0,.65)',1);//RYT
			drawShape('arc',x,y,z,5,7.5,2.5,0,2,0,0,0,'rgba(232,220,0,1)',1);//CYA
			break;
		case 0.1: //GOBLIN
			drawShape('qua',x,y,z,5,9,6,9,7,8,6,8,'darkgreen',1);//IL-foot
			drawShape('qua',x,y,z,6,8,7,8,4,6,4,7,'darkgreen',1);//IL-calf+knee
			drawShape('tri',x,y,z,4,6,7,5,5,7,0,0,'darkgreen',1);//IL-thigh
			drawShape('tri',x,y,z,7,5,8,5,8,6,0,0,'green',1);//OL-hip
			drawShape('qua',x,y,z,7,5,5,7,6,7,8,6,'green',1);//OL-thigh
			drawShape('qua',x,y,z,5,7,7,9,8,9,6,7,'green',1);//OL-calf+knee
			drawShape('qua',x,y,z,7,9,8,9,7,10,5.5,9.9,'green',1);//OL-foot
			drawShape('tri',x,y,z,3,3,5,5,4,2,0,0,'darkgreen',1);//Inner arm
			drawShape('tri',x,y,z,2.1,5.5,5,5,4.5,4.25,0,0,'darkgreen',1);//Inner forearm
			drawShape('arc',x,y,z,2.5,5.4,.4,0,6,0,0,0,'darkgreen',1);//Inner hand
			drawShape('arc',x,y,z,4.5,3.5,.75,0,6,0,0,0,'darkgreen',1);//T-Ishoulder
			drawShape('arc',x,y,z,5.8,4.4,2.5,1.4,2.25,0,0,0,'brown',1);//T-hump
			drawShape('qua',x,y,z,6,5.5,8,5,5,2,4,3,'brown',1);//T-torso
			drawShape('tri',x,y,z,4,3,5,2,5,3,0,0,'darkgreen',1);//T-neck
			drawShape('arc',x,y,z,5.5,2.5,.75,0,6,0,0,0,'darkgreen',1);//T-Oshoulder
			drawShape('qua',x,y,z,7,5,7,6,8,7,8,5,'brown',1);//T-hip armor
			drawShape('tri',x,y,z,5,3,7,5,6,2,0,0,'green',1);//Outer arm
			drawShape('qua',x,y,z,1,5,1,5.25,10,5.5,10,5.25,'brown',1);//T-spear
			drawShape('tri',x,y,z,4.1,5.5,7,5,6.5,4.25,0,0,'green',1);//Outer forearm
			drawShape('arc',x,y,z,4.5,5.4,.4,0,6,0,0,0,'green',1);//Inner hand
			drawShape('tri',x,y,z,5,0,3,2,5,2,0,0,'red',1);//H-hat
			drawShape('tri',x,y,z,3,2,3,4,5,2,0,0,'green',1);//H-head
			drawShape('tri',x,y,z,3,2,2.25,3.25,3,3,0,0,'green',1);//H-nose
			drawShape('tri',x,y,z,3,3,3.5,3,3,4,0,0,'black',1);//H-mouth
			//drawShape('tri',x,y,z,3,2.25,3,2.75,3.75,2.75,0,0,'red',1);//H-eye(sad)
			drawShape('tri',x,y,z,3,2.25,3,2.75,3.75,2.1,0,0,'red',1);//H-eye(mad)
			//drawShape('tri',x,y,z,3,2.25,3,2.75,3.75,2.25,0,0,'red',1);//H-eye(neutral)
			drawShape('tri',x,y,z,4,2.25,4,2.75,4.75,1.75,0,0,'darkgreen',1);//H-ear
			drawShape('arc',x,y,z,2.7,3.2,.25,1,1.75,0,0,0,'black',1);//H-nostril
			drawShape('tri',x,y,z,1,4.9,1,5.35,0,5.15,0,0,'lightgray',1);//H-ear
			break;
		case 23://SPIDER
			//back legs
			drawShape('ell',x,y,z,6.5,5,5.5,.6,1.5,0,6,0,'darkgreen',1);//r-leg-rear-base
			drawShape('ell',x,y,z,10.2,2.6,2.4,.3,.73,0,6,0,'darkgreen',1);//r-leg-rear-mid
			drawShape('ell',x,y,z,11.3,4.4,.5,.15,1.5,0,6,0,'darkgreen',1);//r-leg-rear-tip
			drawShape('ell',x,y,z,8,5,5,.5,1.38,0,6,0,'green',1);//r-leg-mrear-base
			drawShape('ell',x,y,z,11,3.1,2,.2,2,0,6,0,'green',1);//r-leg-mrear-mid
			drawShape('ell',x,y,z,11.3,5,.5,.15,0,0,6,0,'green',1);//r-leg-mrear-tip
			drawShape('ell',x,y,z,3.5,5,5.5,.6,-1.5,0,6,0,'darkgreen',1);//l-leg-rear-base
			drawShape('ell',x,y,z,-.2,2.6,2.4,.3,-.73,0,6,0,'darkgreen',1);//l-leg-rear-mid
			drawShape('ell',x,y,z,-1.3,4.4,.5,.15,-1.5,0,6,0,'darkgreen',1);//l-leg-rear-tip
			drawShape('ell',x,y,z,2,5,5,.5,-1.38,0,6,0,'green',1);//l-leg-mrear-base
			drawShape('ell',x,y,z,-1,3.1,2,.2,2,0,6,0,'green',1);//l-leg-mrear-mid
			drawShape('ell',x,y,z,-1.3,5,.5,.15,0,0,6,0,'green',1);//l-leg-mrear-tip
			//body
			drawShape('ell',x,y,z,5,5,5,4,0,0,6,0,'darkgreen',1);//body
			drawShape('ell',x,y,z,5,5,5,4,0,.05,.95,0,'rgba(0,0,0,.45)',1);//body shadow
			drawShape('ell',x,y,z,5,3,6.13,4,0,.2,.8,0,'darkgreen',1);//body shadowcurve
			drawShape('qua',x,y,z,2,1.73,9.5,5.5,0.5,5.5,8,1.73,'red',1);//hourglass
			//front legs
			drawShape('ell',x,y,z,2,7,4,.4,-1.25,0,6,0,'green',1);//l-leg-mfront-base
			drawShape('ell',x,y,z,-.9,6.7,2,.3,2,0,6,0,'green',1);//l-leg-mfront-mid
			drawShape('ell',x,y,z,-1.1,9,.7,.2,1.5,0,6,0,'green',1);//l-leg-mfront-tip
			drawShape('ell',x,y,z,8,7,4,.4,1.25,0,6,0,'green',1);//r-leg-mfront-base
			drawShape('ell',x,y,z,10.9,6.7,2,.3,2,0,6,0,'green',1);//r-leg-mfront-mid
			drawShape('ell',x,y,z,11.1,9,.7,.2,-1.5,0,6,0,'green',1);//r-leg-mfront-tip
			drawShape('ell',x,y,z,7.5,5,5,.5,1.5,0,6,0,'green',1);//r-leg-front-base
			drawShape('ell',x,y,z,10,5,4,.4,2,0,6,0,'green',1);//r-leg-front1-mid
			drawShape('ell',x,y,z,10,5,4,.4,2,0,6,0,'darkgreen',0);//r-leg-front1-mid
			drawShape('ell',x,y,z,9.6,9,1,.3,1.5,0,6,0,'green',1);//r-leg-front-tip
			drawShape('ell',x,y,z,2.5,5,5,.5,-1.5,0,6,0,'green',1);//l-leg-front-base
			drawShape('ell',x,y,z,0,5,4,.4,2,0,6,0,'green',1);//l-leg-front-mid
			drawShape('ell',x,y,z,0,5,4,.4,2,0,6,0,'darkgreen',0);//l-leg-front-mid
			drawShape('ell',x,y,z,.4,9,1,.3,-1.5,0,6,0,'green',1);//l-leg-front-tip
			//head
			drawShape('ell',x,y,z,5,8,2.3,2,0,0,6,0,'green',1);//head
			drawShape('ell',x,y,z,5,8,2.3,2,0,0,6,0,'darkgreen',0);//head
			drawShape('ell',x,y,z,5,8,2.3,2,0,.05,.95,0,'rgba(0,0,0,.45)',1);//head shadow
			drawShape('ell',x,y,z,5,7,2.8,2,0,.2,.8,0,'green',1);//head shadowcurve
			drawShape('arc',x,y,z,4.5,8,.5,0,6,0,0,0,'black',1);//l-eye1
			drawShape('arc',x,y,z,5.5,8,.5,0,6,0,0,0,'black',1);//r-eye1
			drawShape('arc',x,y,z,3.73,7,.2,0,6,0,0,0,'black',1);//l-eyebot
			drawShape('arc',x,y,z,4.23,7.2,.2,0,6,0,0,0,'black',1);//l-eyemid
			drawShape('arc',x,y,z,4.7,7.35,.2,0,6,0,0,0,'black',1);//l-eyetop
			drawShape('arc',x,y,z,6.26,7,.2,0,6,0,0,0,'black',1);//r-eyebot
			drawShape('arc',x,y,z,5.77,7.2,.2,0,6,0,0,0,'black',1);//r-eyemid
			drawShape('arc',x,y,z,5.3,7.35,.2,0,6,0,0,0,'black',1);//r-eyebot
			drawShape('ell',x,y,z,5,9.3,1.5,.5,0,.65,2.35,0,'black',1);//mouth
			drawShape('ell',x,y,z,5.2,9.5,.8,.5,1.9,1.1,1.9,0,'white',1);//r-fang
			drawShape('ell',x,y,z,4.8,9.5,.8,.5,-1.9,1.1,1.9,0,'white',1);//l-fang
			drawShape('ell',x,y,z,6.8,8.4,1,.8,1.1,1.1,1.9,0,'green',1);//r-fang
			drawShape('ell',x,y,z,6.8,8,1,.8,1.1,1.1,1.9,0,'darkgreen',0);//r-fang
			drawShape('ell',x,y,z,3.3,8.4,1,.8,-1.1,1.1,1.9,0,'green',1);//l-fang
			drawShape('ell',x,y,z,3.3,8,1,.8,-1.1,1.1,1.9,0,'darkgreen',0);//l-fang
			break;
		case 2.1://WISP
			drawShape('arc',x,y,z,5,5,5,0,6,0,0,0,'rgba(163,73,164,.25)',1);//glow
			drawShape('arc',x,y,z,5,5,3,0,6,0,0,0,'rgba(163,73,164,.45)',1);//glow
			drawShape('tri',x,y,z,2.3,3.5,1.9,4.5,3,5.3,0,0,'black',1);//glow
			drawShape('tri',x,y,z,3,5.3,5,4.2,5,5.9,0,0,'black',1);//glow
			drawShape('tri',x,y,z,2,5.9,2.9,7,4,6.5,0,0,'black',1);//glow
		break;
		case 3.1://SKELETON
			//ribs+spine
			drawShape('ell',x,y,z,5,5,1,1,0,0.1,.9,0,'lightgray',1);//rib5
			drawShape('ell',x,y,z,5,5,.75,.7,0,0.1,.9,0,'black',1);//rib5-shadow
			drawShape('ell',x,y,z,5,4.5,1.5,1,0,0.1,.9,0,'lightgray',1);//rib4
			drawShape('ell',x,y,z,5,4.5,1,.7,0,0.1,.9,0,'black',1);//rib4-shadow
			drawShape('ell',x,y,z,5,4,1.5,1,0,0.1,.9,0,'lightgray',1);//rib3
			drawShape('ell',x,y,z,5,4,1,.7,0,0.1,.9,0,'black',1);//rib3-shadow
			drawShape('ell',x,y,z,5,3.5,1.5,1,0,0.1,.9,0,'lightgray',1);//rib2
			drawShape('ell',x,y,z,5,3.5,1,.7,0,0.1,.9,0,'black',1);//rib2-shadow
			drawShape('ell',x,y,z,5,3,1.5,1,0,0.1,.9,0,'lightgray',1);//rib1
			drawShape('ell',x,y,z,5,3,1,.7,0,0.1,.9,0,'black',1);//rib1-shadow
			drawShape('lin',x,y,z,5,3.5,5,6,0,0,0,0,'gray',0);//spine
			//head
			drawShape('arc',x,y,z,5,1.5,1.5,0,6,0,0,0,'lightgray',1);//head
			drawShape('arc',x,y,z,5.5,1.5,.5,0,6,0,0,0,'black',1);//r-eye
			drawShape('arc',x,y,z,4.5,1.5,.5,0,6,0,0,0,'black',1);//l-eye
			drawShape('lin',x,y,z,5.1,1.3,3.9,.75,0,0,0,0,'black',0);//l-eyebrow
			drawShape('lin',x,y,z,4.9,1.3,6.1,.75,0,0,0,0,'black',0);//l-eyebrow
			drawShape('tri',x,y,z,5,2,4.5,2.5,5.5,2.5,0,0,'black',1);//nose
			drawShape('lin',x,y,z,5,2,5,2.4,0,0,0,0,'lightgray',0);//nostrils
			drawShape('ell',x,y,z,5,3,1,.5,0,0,6,0,'lightgray',1);//jaw
			drawShape('lin',x,y,z,4,3,6,3,0,0,0,0,'black',0);//mouth
			//arms
			drawShape('arc',x,y,z,3.5,3.5,.5,0,6,0,0,0,'lightgray',1);//l-shoulder
			drawShape('arc',x,y,z,6.5,3.5,.5,0,6,0,0,0,'lightgray',1);//r-shoulder
			drawShape('arc',x,y,z,3.5,3.5,.5,0,6,0,0,0,'black',0);//l-shoulder-shadow
			drawShape('arc',x,y,z,6.5,3.5,.5,0,6,0,0,0,'black',0);//r-shoulder-shadow
			drawShape('tri',x,y,z,3,3.5,3.5,4,2,5,0,0,'lightgray',1);//l-arm
			drawShape('tri',x,y,z,7,3.5,6.5,4,8,5,0,0,'lightgray',1);//r-arm
			drawShape('tri',x,y,z,2,5,1.5,6.5,2.4,4.9,0,0,'lightgray',1);//l-forearm
			drawShape('tri',x,y,z,7.8,4.8,8.5,6.3,7.5,4.8,0,0,'lightgray',1);//r-forearm
			drawShape('arc',x,y,z,1.7,6.3,.35,0,6,0,0,0,'lightgray',1);//l-hand
			drawShape('arc',x,y,z,8.1,6.1,.35,0,6,0,0,0,'lightgray',1);//r-hand
			//lower body
			drawShape('ell',x,y,z,5,6.5,1,.5,0,0,6,0,'lightgray',1);//hip
			drawShape('arc',x,y,z,5.75,6.5,.5,0,6,0,0,0,'gray',1);//hip
			drawShape('arc',x,y,z,4.25,6.5,.5,0,6,0,0,0,'gray',1);//hip
			drawShape('tri',x,y,z,6.15,6.4, 5.4,6.75, 8,8, 0,0,'lightgray',1);//r-leg
			drawShape('tri',x,y,z,3.85,6.4, 4.6,6.75, 2,8, 0,0,'lightgray',1);//l-leg
			drawShape('tri',x,y,z,2,8,2.5,7.5,4,10, 0,0,'lightgray',1);//l-shin
			drawShape('tri',x,y,z,8,8,7.5,7.5,6,9, 0,0,'lightgray',1);//r-shin
			drawShape('tri',x,y,z,4,10,1.75,10,3.5,9.3, 0,0,'lightgray',1);//l-foot
			drawShape('tri',x,y,z,6.8,8.3,8,10,6,9, 0,0,'lightgray',1);//r-foot
			break;
    case 3.2: //skull
    			//head
      drawShape('arc',x,y,z,5,5,5,0,6,0,0,0,'rgba(0,0,0,.4)',1);//head
      drawShape('arc',x,y,z,5,5,4.55,0,6,0,0,0,'rgba(0,0,0,.15)',1);//head
      drawShape('arc',x,y,z,5,5,4.2,0,6,0,0,0,'rgba(0,0,0,.15)',1);//head
          sx = -8.75*z;
          sy = .2 * z;
          sz = 2.75;
			drawShape('arc',x+sx,y+sy,z*sz,5,1.5,1.5,0,6,0,0,0,'lightgray',1);//head
			drawShape('arc',x+sx,y+sy,z*sz,5.5,1.5,.5,0,6,0,0,0,'black',1);//r-eye
			drawShape('arc',x+sx,y+sy,z*sz,4.5,1.5,.5,0,6,0,0,0,'black',1);//l-eye
			drawShape('lin',x+sx,y+sy,z*sz,5.1,1.3,3.9,.75,0,0,0,0,'black',0);//l-eyebrow
			drawShape('lin',x+sx,y+sy,z*sz,4.9,1.3,6.1,.75,0,0,0,0,'black',0);//l-eyebrow
			drawShape('tri',x+sx,y+sy,z*sz,5,2,4.5,2.5,5.5,2.5,0,0,'black',1);//nose
			drawShape('lin',x+sx,y+sy,z*sz,5,2,5,2.4,0,0,0,0,'lightgray',0);//nostrils
			drawShape('ell',x+sx,y+sy,z*sz,5,3,1,.5,0,0,6,0,'lightgray',1);//jaw
			drawShape('lin',x+sx,y+sy,z*sz,4,3,6,3,0,0,0,0,'black',0);//mouth

      break;
		case 4.1://KNIGHT(emperor)
			drawShape('qua',x,y,z,4.7,5.5,/*tr*/ 3.5,7.5,/*br*/ 4.4,7.7,/*bl*/ 5,6.5,'lightgray',1);//l-thigh
			drawShape('qua',x,y,z,4.5,9.1,/*tr*/4.5,9.6,/*br*/ 2,9.6,/*l*/4.5,8.6,/*tl*/'darkgray',1);//l-foot
			drawShape('qua',x,y,z,4.5,9.5,/*br*/ 4.5,7.7,/*tr*/ 3.3,7.3,/*tl*/ 3.9,9,/*bl*/'darkgray',1);//l-calf
			drawShape('qua',x,y,z,4.5,9.5,/*br*/ 4.5,7.7,/*tr*/ 3.3,7.3,/*tl*/ 3.9,9,/*b*/'gray',0);//l-calf
			drawShape('arc',x,y,z,4.25,2.65, .63,0, 3,0, 0,0,'darkgray',1);//l-shoulder
			drawShape('arc',x,y,z,4.25,2.65, .63,0, 3,0, 0,0,'gray',0);//l-shoulder-shadow
			drawShape('ell',x,y,z,5.15,3.6,1.15,1.75,0,0,6,0,'lightgray',1);//torso
			drawShape('qua',x,y,z,4.7,2,5.5,1.5,6,2.5,4.25,2.5,'darkgray',1);//neck
			//drawShape('arc',x,y,z,5,1,1,0,6,0,0,0,'lightgray',1);//head
			//drawShape('tri',x,y,z,3.5,1.5,4.3,.25,4.9,2,0,0,'lightgray',1);//helm nose
			drawShape('qua',x,y,z,4.5,5.5,/*tl*/6,4.5,/*tr*/ 6.5,7.7,/*br*/ 5.8,8,/*bl*/ 'lightgray',1);//r-thigh
			drawShape('qua',x,y,z,5.5,8,/*tl*/6.25,7.25,/*tm*/6.75,8,/*tr*/ 6.25,9.5,/*b*/'darkgray',1);//r-calf
			drawShape('qua',x,y,z,5.5,8,/*tl*/6.25,7.25,/*tm*/6.75,8,/*tr*/ 6.25,9.5,/**/'gray',0);//r-calf
			drawShape('qua',x,y,z,6.25,9,/*t*/5.6,9.6,/*bl*/6.25,10,/*bm*/ 6.9,9.6,/*br*/'darkgray',1);//r-foot
			//drawShape('tri',x,y,z,6.25,9.5,/*t*/5.75,10,/*bl*/6.75,10,/*br*/ 0,0,'gray',1);//r-toe
			drawShape('qua',x,y,z,6.2,4.3,7.25,7.25,5.1,6.3,4.75,5.25,'darkgray',1);//hip armor
			drawShape('qua',x,y,z,6.2,4.3,7.25,7.25,5.1,6.3,4.75,5.25,'gray',0);//hip armor
			drawShape('qua',x,y,z,4.5,7, 5.2,5, 4.5,5.2, 4.2,5,'darkgray',1);//groin armor
			drawShape('qua',x,y,z,4.5,7, 5.2,5, 4.5,5.2, 4.2,5,'gray',0);//groin armor
			//drawShape('qua',x,y,z,2.75,1.75, 4.5,2.75, 4.5,5.8, 2.75,4.8,'gray',1);//shield top
			//drawShape('tri',x,y,z,2.75,4.8,4.5,5.8,3.5,7.5,0,0,'gray',1);//shield bot
			//drawShape('lin',x,y,z,3.5,7.6,3.45,2.1,0,0,0,0,'blue',0);//shield cross |
			//drawShape('lin',x,y,z,2.75,4,4.5,5,0,0,0,0,'blue',0);//shield cross--
			drawShape('tri',x,y,z,/*tl*/ 4.45,3.55, /*tr*/3.7,2.5, /*br*/2.3,4, 0,0,'lightgray',1);//l-arm
		  

			drawShape('tri',x,y,z,/*tl*/ 5.55,3.55, /*tr*/6.3,2.5, /*br*/7.7,4, 0,0,'lightgray',1);//r-arm
			drawShape('tri',x,y,z,/*tl*/ 5.6,3.5, /*tr*/6.3,2.5, /*br*/7.7,4, 0,0,'gray',0);//r-arm

			drawShape('qua',x,y,z,5.9,5.5, 5.9,5.7, 7.2,6.1, 7.2,5.7,'gold',1);//sword-hilt
			drawShape('arc',x,y,z,6.2,5.75,.4,0,3,0,0,0,'darkgray',1);//r-hand
			//drawShape('tri',x,y,z,1,4.6, 5.9,5.35, 6.1,6.15,0,0,'white',1);//sword-blade
			//drawShape('qua',x,y,z,5.8,4.5,5.9,5.7,6.3,6.8,6.4,6,'gold',1);//sword-crossguard
			drawShape('arc',x,y,z,6,3, .63,0, 3,0, 0,0,'darkgray',1);//r-shoulder
			drawShape('arc',x,y,z,6,3, .63,0, 3,0, 0,0,'gray',0);//r-shoulder
			//drawShape('qua',x,y,z,5.8,.7, 3.5,.8, 3.7,.5, 3.85,.6,'black',1);//helmet visor
            drawShape('qua',x,y,z,4,2, 3.5,2.5, 6.5,7.2, 4.2,5,'rgba(255,0,0,.4)',1);//robeLShoulder
        drawShape('qua',x,y,z,4,2, 6.5,2.5, 3.5,7.2, 6.5,5,'rgba(255,0,0,.4)',1);//robeLShoulder
              drawShape('qua',x,y,z,4,2, 3.5,2.5, 6.5,7.2, 4.2,5,'rgba(255,0,0,.4)',1);//robeLShoulder
        drawShape('qua',x,y,z,4,2, 4,4, 3,8, 7.25,7.25,'rgba(255,0,0,.8)',1);//robeLShoulder
              drawShape('qua',x,y,z,4,2, 3.5,2.5, 6.5,7.2, 4.2,5,'rgba(255,0,0,.4)',1);//robeLShoulder
        drawShape('qua',x,y,z,6,2.1, 7.5,3.5, 7.25,7.25, 4,2,'rgba(255,0,0,.7)',1);//robeLShoulder
      drawShape('qua',x,y,z,6,2.1, 7.5,3.5, 7.25,7.25, 4,2,'rgba(255,0,0,.7)',1);//robeLShoulder
      			drawShape('tri',x,y,z,/*br*/ 7.9,3.9, /*tr*/7.3,3.3, /*l*/6.5,5.5, 0,0,'lightgray',1);//r-forearm
			drawShape('tri',x,y,z,/*br*/ 7.9,3.9, /*tr*/7.3,3.3, /*l*/6.5,5.5, 0,0,'gray',0);//r-forearm
      drawShape('tri',x,y,z,/*br*/ 2.3,4, /*tr*/2.7,3.55, /*l*/4.5,4, 0,0,'gray',1);//l-forearm
      drawShape('qua',x,y,z,4,4, 5,3.75, 4.7,4.4, 4.5,4.4,'rgb(185,122,87)',1);//hand left
      drawShape('arc',x,y,z,4.5,4, .39,0, 3,0, 0,0,'gold',1);////gold orb
      drawShape('arc',x,y,z,4.5,4, .5,0, 3,0, 0,0,'rgba(255,255,0,.25)',1);////gold orb

      drawShape('qua',x,y,z,4,4, 5,4, 4.7,4.4, 4.3,4.4,'rgb(185,122,87)',1);//hand left
      drawShape('arc',x,y,z,6.4,2.65, .25,0, 3,0, 0,0,'gold',1);//ankh circle outer
     
            drawShape('arc',x,y,z,6.4,2.65, .13,0, 3,0, 0,0,'red',1);//ankh circle inner
            drawShape('arc',x,y,z,6.4,2.65, .131,0, 3,0, 0,0,'rgba(0,6,13,1)',0);//ankh circle inner
      drawShape('qua',x,y,z,7,5, 6,4.75, 6.3,5.5, 6.5,5.5,'rgb(185,122,87)',1);//hand right
      drawShape('rec',x,y,z,6.3,3, .19,2.5, 6.3,3, 0,0,'gold',1);//ankh
      drawShape('rec',x,y,z,6.3,3, .19,2.5, 6.3,3, 0,0,'rgb(0,6,13)',0);//ankh
      drawShape('rec',x,y,z,5.9,2.89, 1,.15, 6.3,3, 0,0,'gold',1);//ankh cross
      drawShape('rec',x,y,z,5.9,2.89, 1,.15, 6.3,3, 0,0,'rgb(0,6,13)',0);//ankh cross
       drawShape('arc',x,y,z,6.4,2.65, .25,0, 3,0, 0,0,'rgb(0,6,13)',0);//ankh circle outer
             drawShape('qua',x,y,z,7,5, 6,5, 6.3,5.5, 6.5,5.5,'rgb(185,122,87)',1);//hand right
     
      


        break;
  }
}
//MUSIC ENGINE
const MusicEngine = {
  ctx: null,
  masterGain: null,
  currentSong: null,
  async init() {
    const AudioCtx = window.AudioContext || window.webkitAudioContext;
    if (!this.ctx) {
        this.ctx = new AudioCtx();
        this.masterGain = this.ctx.createGain();
        this.masterGain.gain.value = 0.5;
        this.masterGain.connect(this.ctx.destination);
    }
    if (this.ctx.state === 'suspended') {
        await this.ctx.resume();
    }
    const buffer = this.ctx.createBuffer(1, 1, 22050);
    const source = this.ctx.createBufferSource();
    source.buffer = buffer;
    source.connect(this.ctx.destination);
    source.start(0);
    return true;
},
    
  playSFX(type) {
    if (!this.ctx) return;
    if (this.ctx.state === 'suspended') { this.ctx.resume(); }
    const t = this.ctx.currentTime;
    switch (type) {
      case 'click': default:
        this.createTone(t, 1500, 'sine', 1, 0.1, -200);
        break;
      case 'cancel':
        this.createTone(t, 150, 'sawtooth', 0.15, 0.2, -50);
        break;
      case 'chime':
        this.createTone(t, 1200, 'sine', 2, 0.5, 0);
        this.createTone(t, 2400, 'sine', 1, 0.5, 0);
        break;
      case 'fireball':
        this.createNoise(t, 'lowpass', 100, 2, 3, 800); // Filter sweeps up
        this.createTone(t, 100, 'sawtooth', 1.5, 3, -50); // Low rumble
        break;
      case 'warp':
        const oscW = this.ctx.createOscillator();
        const gainW = this.ctx.createGain();
        oscW.type = 'sine';
        oscW.frequency.setValueAtTime(200, t);
        oscW.frequency.exponentialRampToValueAtTime(2000, t + 0.2); // Zip up
        oscW.frequency.exponentialRampToValueAtTime(100, t + 0.4); // Zip down
        gainW.gain.setValueAtTime(0.2, t);
        gainW.gain.linearRampToValueAtTime(0, t + 0.4);
        oscW.connect(gainW); gainW.connect(this.ctx.destination);
        oscW.start(t); oscW.stop(t + 0.4);
        break;
      case 'heal':
        for (let i = 0; i < 5; i++) {
          setTimeout(() => {
            this.createTone(this.ctx.currentTime, 800 + (i * 200), 'sine', 0.1, 0.3, 0);
          }, i * 50);
        }
        break;
      case 'slash':
        this.createNoise(t, 'highpass', 1000, 1, 1, 0);
        break;
      case 'clang':
        const c = this.ctx.createOscillator();
        const cG = this.ctx.createGain();
        c.type = 'square';
        c.frequency.value = 400;
        const m = this.ctx.createOscillator();
        const mG = this.ctx.createGain();
        m.frequency.value = 567; // Non-integer ratio
        mG.gain.value = 2000;
        m.connect(mG); mG.connect(c.frequency);
        c.connect(cG); cG.connect(this.ctx.destination);
        cG.gain.setValueAtTime(1, t);
        cG.gain.exponentialRampToValueAtTime(0.01, t + 1);
        c.start(t); m.start(t);
        c.stop(t + 0.5); m.stop(t + 0.5);
        break;
      case 'death':
        const oscD = this.ctx.createOscillator();
        const gainD = this.ctx.createGain();
        oscD.type = 'sawtooth';
        oscD.frequency.setValueAtTime(150, t);
        oscD.frequency.exponentialRampToValueAtTime(40, t + 1.5);
        const filter = this.ctx.createBiquadFilter();
        filter.type = 'lowpass';
        filter.frequency.value = 300;
        gainD.gain.setValueAtTime(1, t);
        gainD.gain.linearRampToValueAtTime(0, t + 1.5);
        oscD.connect(filter); filter.connect(gainD); gainD.connect(this.ctx.destination);
        oscD.start(t); oscD.stop(t + 1.5);
        break;
    }
  },
  createTone(t, freq, type, vol, dur, slide) {
    const osc = this.ctx.createOscillator();
    const gain = this.ctx.createGain();
    osc.type = type;
    osc.frequency.setValueAtTime(freq, t);
    if (slide !== 0) osc.frequency.linearRampToValueAtTime(freq + slide, t + dur);
    gain.gain.setValueAtTime(vol, t);
    gain.gain.exponentialRampToValueAtTime(0.01, t + dur);

    osc.connect(gain); gain.connect(this.ctx.destination);
    osc.start(t); osc.stop(t + dur);
  },
  createNoise(t, filterType, filterFreq, vol, dur, sweep) {
    const bufSize = this.ctx.sampleRate * dur;
    const buffer = this.ctx.createBuffer(1, bufSize, this.ctx.sampleRate);
    const data = buffer.getChannelData(0);
    for (let i = 0; i < bufSize; i++) data[i] = Math.random() * 2 - 1;

    const noise = this.ctx.createBufferSource();
    noise.buffer = buffer;

    const filter = this.ctx.createBiquadFilter();
    filter.type = filterType;
    filter.frequency.setValueAtTime(filterFreq, t);
    if (sweep !== 0) filter.frequency.linearRampToValueAtTime(filterFreq + sweep, t + dur);

    const gain = this.ctx.createGain();
    gain.gain.setValueAtTime(vol, t);
    gain.gain.exponentialRampToValueAtTime(0.01, t + dur);

    noise.connect(filter); filter.connect(gain); gain.connect(this.ctx.destination);
    noise.start(t);
  },
  play(style) {
    if (!this.ctx) { console.warn("Call MusicEngine.init() first!"); return; }
    if (this.ctx.state === 'suspended') this.ctx.resume();

    this.stop();

    switch (style) {
      case 0: case 'scary2':
        this.currentSong = new ScaryM(this.ctx, this.masterGain);
        break;
      case 1: case 'scary':
        this.currentSong = new ScaryModule(this.ctx, this.masterGain);
        break;
      case 2: case 'dungeon':
        this.currentSong = new DungeonModule(this.ctx, this.masterGain);
        break;
      case 3: case 'lyre':
        this.currentSong = new LyreModule(this.ctx, this.masterGain);
        break;
      case 4: case 'dungeonm':
        this.currentSong = new DungeonM(this.ctx, this.masterGain);
        break;
      case 5: case 'boss':
        this.currentSong = new BossBattleModule(this.ctx, this.masterGain);
        break;
      case 6: case 'raid':
        this.currentSong = new RaidBossModule(this.ctx, this.masterGain);
        break;
      case 7: case 'tactics':
        this.currentSong = new TacticalModule(this.ctx, this.masterGain);
        break;
      case 8: case 'promenade':
        this.currentSong = new PromenadeModule(this.ctx, this.masterGain);
        break;
      case 9: case 'battle':
        this.currentSong = new BattleModule(this.ctx, this.masterGain);
        break;
      case 10: case 'love':
        this.currentSong = new RomanceModule(this.ctx, this.masterGain);
        break;
      case 11: case 'bach':
        this.currentSong = new BachModule(this.ctx, this.masterGain);
        break;
      case 12: case 'bach2':
        this.currentSong = new Bach2Module(this.ctx, this.masterGain);
        break;
      case 13: case 'bach3':
        this.currentSong = new Bach3Module(this.ctx, this.masterGain);
        break;
      case 14: case 'bach4':
        this.currentSong = new Bach4Module(this.ctx, this.masterGain);
        break;
      case 15: case 'bach5':
        this.currentSong = new Bach5Module(this.ctx, this.masterGain);
        break;
      case 16: case 'infinitebattle':
        this.currentSong = new InfiniteBattleModule(this.ctx, this.masterGain);
        break;
      case 17: case 'finalboss':
        this.currentSong = new FinalBossModule(this.ctx, this.masterGain);
        break;
      case 18: case 'finalform':
        this.currentSong = new FinalFormModule(this.ctx, this.masterGain);
        break;
      case 19: case 'singularity':
        this.currentSong = new SingularityModule(this.ctx, this.masterGain);
        break;
      case 20: case 'lament':
        this.currentSong = new LamentModule(this.ctx, this.masterGain);
        break;
        case 21: case 'Elegia':
        this.currentSong = new ElegiaModule(this.ctx, this.masterGain);
        break;
      default:
        console.error("Unknown style:", style);
        return;
    }

    if (this.currentSong) {
      console.log(`Starting: ${style}`);
      this.currentSong.start();
    }
  },

  stop() {
    // 1. Cut the Master Volume immediately to kill lingering reverb tails
    if (this.masterGain) {
        this.masterGain.gain.cancelScheduledValues(this.ctx.currentTime);
        this.masterGain.gain.setValueAtTime(this.masterGain.gain.value, this.ctx.currentTime);
        this.masterGain.gain.linearRampToValueAtTime(0, this.ctx.currentTime + 0.05); // 50ms fade out
    }

    // 2. Stop the specific song logic
    if (this.currentSong) {
      if (this.currentSong.stop) this.currentSong.stop();
      this.currentSong = null;
    }

    // 3. Reset Master Volume for the next track (after a tiny delay)
    setTimeout(() => {
        if(this.masterGain){
            this.masterGain.gain.setValueAtTime(0.5, this.ctx.currentTime); 
        }
    }, 100);
  },
isPlaying() {
    // 1. If context doesn't exist or is suspended, we aren't playing
    if (!this.ctx || this.ctx.state !== 'running') return false;
    
    // 2. If no song object is assigned, we aren't playing
    if (!this.currentSong) return false;
    
    return true;
  },
  setVolume(val) {
    if (this.masterGain) this.masterGain.gain.setTargetAtTime(val, this.ctx.currentTime, 0.1);
  }
};
  //MODULE 0: NIGHTMARE (The Ligeti System)
    class ScaryM {
      constructor(ctx, dest) {
        this.ctx = ctx;
        // Add a Master Compressor so the dissonance doesn't clip speakers
        this.masterGain = ctx.createGain();
        this.masterGain.gain.value = 0.8;

        // Create a Feedback Delay (The "Echo from the Well")
        this.delay = ctx.createDelay();
        this.delay.delayTime.value = 0.4; // 400ms delay
        this.feedback = ctx.createGain();
        this.feedback.gain.value = 0.6; // High feedback

        this.delay.connect(this.feedback);
        this.feedback.connect(this.delay);
        this.delay.connect(this.masterGain);
        this.masterGain.connect(dest);

        this.dest = this.masterGain; // Voices connect here
        this.destWithDelay = this.delay; // Some voices connect to delay

        this.voices = new Map();
        this.timer = null;
        this.conductor = null;
      }

      start() {
        // Lower ranges for a darker tone
        const vids = ['sop', 'alt', 'ten', 'bas'];
        const rngs = { sop: [60, 80], alt: [50, 70], ten: [40, 60], bas: [28, 48] };

        vids.forEach(vid => {
          // Pass the delay line to the voice
          this.voices.set(vid, new ScaryV(vid, rngs[vid], this.ctx, this.dest, this.destWithDelay));
        });

        this.conductor = {
          t: 0,
          tick: () => {
            this.conductor.t += 100;
            this.voices.forEach(vo => {
              if (this.conductor.t >= vo.nextTime) {
                // SCARY INTERVALS:
                // 1 = Minor 2nd (Jaws theme tension)
                // 6 = Tritone (The "Devil's Interval")
                // 11 = Major 7th (Unresolved, piercing)
                const intervals = [1, 6, 11, -1, -6, -13];

                const int = intervals[Math.floor(Math.random() * intervals.length)];

                // 20% chance to jump a huge distance (octave displacement)
                const octaveJump = Math.random() > 0.8 ? 12 : 0;
                const nextPitch = vo.currPitch ? vo.currPitch + int + octaveJump : 50;

                // Slower, agonizing durations (2 to 5 seconds)
                const duration = 2000 + Math.random() * 3000;

                if (nextPitch >= vo.range[0] && nextPitch <= vo.range[1]) {
                  vo.play(nextPitch, duration);
                  vo.currPitch = nextPitch;
                  // Overlap voices creates clusters
                  vo.nextTime = this.conductor.t + (duration * 0.7);
                }
              }
            });
          }
        };

        // Stagger starts
        this.voices.forEach(vo => vo.nextTime = Math.random() * 5000);
        this.timer = setInterval(() => this.conductor.tick(), 100);
      }

      stop() {
        clearInterval(this.timer);
        this.voices.forEach(v => v.silence());
        this.voices.clear();
      }
    }
    class ScaryV {
      constructor(id, range, ctx, dest, delayNode) {
        this.id = id; this.range = range; this.ctx = ctx;
        this.dest = dest; this.delayNode = delayNode;
        this.osc = null; this.gain = null; this.filter = null;
        this.currPitch = null; this.nextTime = 0;
      }

      play(pitch, duration) {
        // Crossfade logic: don't kill the old note instantly, let it bleed
        const oldOsc = this.osc;
        const oldGain = this.gain;
        if (oldGain) {
          oldGain.gain.cancelScheduledValues(this.ctx.currentTime);
          oldGain.gain.linearRampToValueAtTime(0, this.ctx.currentTime + 3); // 3s fade out (Ghostly)
          if (oldOsc) oldOsc.stop(this.ctx.currentTime + 3.1);
        }

        // 1. FREQUENCY CALCULATION (With Detune)
        // Add random "drift" to the pitch so it's never perfectly in tune (Uncanny Valley)
        const detune = (Math.random() * 20) - 10; // +/- 10 cents
        const freq = 440 * Math.pow(2, ((pitch + (detune / 100)) - 69) / 12);

        // 2. OSCILLATOR (Sawtooth is too clean, let's filter it)
        this.osc = this.ctx.createOscillator();
        this.osc.type = Math.random() > 0.5 ? 'sawtooth' : 'triangle';
        this.osc.frequency.setValueAtTime(freq, this.ctx.currentTime);

        // 3. LOW PASS FILTER (The "Next Room" Effect)
        this.filter = this.ctx.createBiquadFilter();
        this.filter.type = 'lowpass';
        // Randomly open/close the filter for "breathing" texture
        this.filter.frequency.setValueAtTime(200, this.ctx.currentTime);
        this.filter.frequency.linearRampToValueAtTime(800 + Math.random() * 1000, this.ctx.currentTime + (duration / 1000));

        // 4. ENVELOPE (Slow Attack, Long Release)
        this.gain = this.ctx.createGain();
        this.gain.gain.setValueAtTime(0, this.ctx.currentTime);
        // Take 2 seconds to reach full volume (Creeping in)
        this.gain.gain.linearRampToValueAtTime(0.08, this.ctx.currentTime + 2);

        // 5. CONNECTIONS
        this.osc.connect(this.filter);
        this.filter.connect(this.gain);

        // 50% chance to send to Delay (Echo) or Direct
        if (Math.random() > 0.5) {
          this.gain.connect(this.delayNode);
        } else {
          this.gain.connect(this.dest);
        }

        this.osc.start();

        // 6. MICRO-GLISSANDO (Slide slightly to the note)
        // This simulates a violinist searching for the pitch
        this.osc.frequency.setValueAtTime(freq * 0.98, this.ctx.currentTime);
        this.osc.frequency.exponentialRampToValueAtTime(freq, this.ctx.currentTime + 1);
      }

      silence() {
    if (this.gain) {
        this.gain.gain.cancelScheduledValues(this.ctx.currentTime);
        this.gain.gain.linearRampToValueAtTime(0, this.ctx.currentTime + 0.1); // Instant kill
    }
    if (this.osc) {
        this.osc.stop(this.ctx.currentTime + 0.1);
        this.osc = null;
    }
    }
    }
    //MODULE 1: SCARY (The Bach System)
    class ScaryModule {
      constructor(ctx, dest) {
        this.ctx = ctx;
        this.dest = dest;
        this.voices = new Map();
        this.timer = null;
        this.conductor = null;
      }

      start() {
        const vids = ['sop', 'alt', 'ten', 'bas'];
        const rngs = { sop: [60, 79], alt: [55, 74], ten: [48, 67], bas: [36, 55] };

        vids.forEach(vid => {
          this.voices.set(vid, new ScaryVoice(vid, rngs[vid], this.ctx, this.dest));
        });

        this.conductor = {
          t: 0,
          tick: () => {
            this.conductor.t += 100;
            this.voices.forEach(vo => {
              if (this.conductor.t >= vo.nextTime) {
                const intervals = [0, 2, 4, 5, 7, -3, -5];
                const int = intervals[Math.floor(Math.random() * intervals.length)];
                const nextPitch = vo.currPitch ? vo.currPitch + int : 60;
                const duration = 500 + Math.random() * 500;

                if (nextPitch >= vo.range[0] && nextPitch <= vo.range[1]) {
                  vo.play(nextPitch);
                  vo.currPitch = nextPitch;
                  vo.nextTime = this.conductor.t + duration;
                }
              }
            });
          }
        };

        this.voices.forEach(vo => vo.nextTime = Math.random() * 2000);
        this.timer = setInterval(() => this.conductor.tick(), 100);
      }

      stop() {
        clearInterval(this.timer);
        this.voices.forEach(v => v.silence());
        this.voices.clear();
      }
    }
    class ScaryVoice {
      constructor(id, range, ctx, dest) {
        this.id = id; this.range = range; this.ctx = ctx; this.dest = dest;
        this.osc = null; this.gain = null; this.currPitch = null; this.nextTime = 0;
      }
      play(pitch) {
        if (this.osc) this.silence();
        const freq = 440 * Math.pow(2, (pitch - 69) / 12);
        this.osc = this.ctx.createOscillator();
        this.osc.type = 'sawtooth';
        this.osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
        this.gain = this.ctx.createGain();
        this.gain.gain.setValueAtTime(0, this.ctx.currentTime);
        this.gain.gain.linearRampToValueAtTime(0.1, this.ctx.currentTime + 0.1);
        this.osc.connect(this.gain);
        this.gain.connect(this.dest);
        this.osc.start();
        if (this.currPitch) this.osc.frequency.linearRampToValueAtTime(freq, this.ctx.currentTime + 0.05);
      }
      silence() {
        if (this.gain) this.gain.gain.linearRampToValueAtTime(0, this.ctx.currentTime + 0.05);
        if (this.osc) { this.osc.stop(this.ctx.currentTime + 0.1); this.osc = null; }
      }
    }
    //MODULE 2: DUNGEON (Bach Affekt System)
    class DungeonModule {
      constructor(ctx, dest) {
        this.ctx = ctx;
        this.mainOut = dest;
        this.timer = null;
        this.tempo = 100;

        this.fxInput = ctx.createGain();
        this.fxInput.gain.value = 0.5;
        this.comp = ctx.createDynamicsCompressor();
        this.comp.threshold.value = -20;
        this.comp.ratio.value = 4;
        this.eq = ctx.createBiquadFilter();
        this.eq.type = 'highshelf'; this.eq.frequency.value = 2000; this.eq.gain.value = 3;
        this.revNode = ctx.createConvolver();
        this.setupReverb();
        this.revGain = ctx.createGain(); this.revGain.gain.value = 0.35;
        this.dryGain = ctx.createGain(); this.dryGain.gain.value = 0.65;

        this.fxInput.connect(this.comp);
        this.comp.connect(this.eq);
        this.eq.connect(this.dryGain);
        this.eq.connect(this.revNode);
        this.revNode.connect(this.revGain);
        this.dryGain.connect(this.mainOut);
        this.revGain.connect(this.mainOut);

        this.cfg = {
          scales: { ionian: [0, 2, 4, 5, 7, 9, 11], dorian: [0, 2, 3, 5, 7, 9, 10], aeolian: [0, 2, 3, 5, 7, 8, 10], phrygian: [0, 1, 3, 5, 7, 8, 10] },
          voices: {
            soprano: { p: 0.8, type: 'sawtooth', range: [1, 3, 5, 7], role: 'upper' },
            alto: { p: 0.7, type: 'triangle', range: [1, 2, 4, 5], role: 'lower' }
          }
        };

        this.st = { tickCount: 0, activeVoices: [], scaleName: 'dorian', scaleIntervals: [], rootFreqs: {}, rootNoteIndex: 0 };
      }

      setupReverb() {
        const len = this.ctx.sampleRate * 2.0;
        const buf = this.ctx.createBuffer(2, len, this.ctx.sampleRate);
        for (let c = 0; c < 2; c++) {
          const d = buf.getChannelData(c);
          for (let i = 0; i < len; i++) d[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / len, 2.5);
        }
        this.revNode.buffer = buf;
      }

      start() {
        this.st.activeVoices = [];
        this.st.tickCount = 0;
        this.updateKey();
        this.addVoice('soprano');
        const tickRate = (60 / this.tempo) * 250;
        this.timer = setInterval(() => this.tick(), tickRate);
      }

      stop() {
        if (this.timer) clearInterval(this.timer);
        this.fxInput.gain.linearRampToValueAtTime(0, this.ctx.currentTime + 0.3);
        setTimeout(() => { this.fxInput.disconnect(); this.revNode.disconnect(); this.comp.disconnect(); }, 400);
      }

      updateKey() {
        const scaleKeys = Object.keys(this.cfg.scales);
        this.st.scaleName = scaleKeys[Math.floor(Math.random() * scaleKeys.length)];
        this.st.scaleIntervals = this.cfg.scales[this.st.scaleName];
        this.st.rootNoteIndex = Math.floor(Math.random() * 12);
        this.st.rootFreqs = {};
        for (let i = 0; i < 36; i++) {
          const noteNum = 48 + i + this.st.rootNoteIndex;
          const freq = 440 * Math.pow(2, (noteNum - 69) / 12);
          this.st.rootFreqs[i] = freq;
        }
      }

      addVoice(id) {
        const def = this.cfg.voices[id];
        this.st.activeVoices.push({ id: id, ...def, momentum: 5, active: true });
      }

      tick() {
        this.st.tickCount++;
        if (this.st.tickCount === 20) this.addVoice('alto');
        if (this.st.tickCount % 64 === 0) this.updateKey();
        this.st.activeVoices.forEach(v => this.processVoice(v));
      }

      processVoice(v) {
        let chance = v.p + (v.momentum * 0.1);
        if (v.role === 'upper') chance *= 1.1;
        if (Math.random() < chance) {
          this.playNote(v);
          v.momentum = Math.max(-2, v.momentum - (2 + Math.random()));
        } else {
          v.momentum = Math.min(10, v.momentum + 1);
        }
      }

      playNote(v) {
        const scale = this.st.scaleIntervals;
        const scaleDegree = Math.floor(Math.random() * scale.length);
        const pitchClass = scale[scaleDegree];
        let octaveBase = v.role === 'upper' ? 12 : 0;
        const noteIndex = octaveBase + pitchClass;
        const freq = this.st.rootFreqs[noteIndex];
        if (!freq) return;

        const r = Math.random();
        let dur = 0.5;
        if (r < 0.3) dur = 0.25; else if (r > 0.8) dur = 1.0;

        const t = this.ctx.currentTime;
        const osc = this.ctx.createOscillator();
        const gn = this.ctx.createGain();
        osc.type = v.type;
        osc.frequency.setValueAtTime(freq, t);
        const filter = this.ctx.createBiquadFilter();
        filter.type = 'lowpass';
        filter.frequency.setValueAtTime(600 + (Math.random() * 1000), t);

        osc.connect(filter); filter.connect(gn); gn.connect(this.fxInput);
        gn.gain.setValueAtTime(0, t);
        gn.gain.linearRampToValueAtTime(0.2, t + 0.02);
        gn.gain.exponentialRampToValueAtTime(0.01, t + dur);
        gn.gain.linearRampToValueAtTime(0, t + dur + 0.1);
        osc.start(t);
        osc.stop(t + dur + 0.2);
      }
    }
    // MODULE 3: DAWN (Cinematic Ending)
    class LyreModule {
      constructor(ctx, dest) {
        this.ctx = ctx;
        this.dest = dest;
        this.timer = null;

        // --- EMOTIONAL STATS ---
        this.tempo = 60; // Very Slow (Adagio)
        this.keyBase = 155.56; // Eb3 (Eb Major - The key of "Heroic Love")

        // Eb Major Scale: Eb, F, G, Ab, Bb, C, D
        this.scale = [0, 2, 4, 5, 7, 9, 11];

        // --- STATE ---
        this.tickCount = 0;
        this.startTime = 0;

        // Timeline: 'explosion' -> 'silence' -> 'piano_solo' -> 'tutti'
        this.phase = 'explosion';

        // --- GLOBAL FX: THE "CATHEDRAL" REVERB ---
        // We need a ConvolverNode to simulate a massive space
        this.reverb = ctx.createConvolver();
        this.reverb.buffer = this.createImpulseResponse(3.0, 2.0); // 3 seconds reverb

        // Master Gain for Fade Out
        this.masterGain = ctx.createGain();
        this.masterGain.gain.value = 1.0;

        // Chain: Instruments -> Reverb -> Master -> Dest
        this.reverb.connect(this.masterGain);
        this.masterGain.connect(dest);

        // Direct signal mix (Dry/Wet)
        this.dryGain = ctx.createGain();
        this.dryGain.gain.value = 0.6;
        this.dryGain.connect(this.masterGain);

        // This is where instruments connect
        this.input = ctx.createGain();
        this.input.connect(this.reverb); // Wet
        this.input.connect(this.dryGain); // Dry
      }

      createImpulseResponse(duration, decay) {
        const rate = this.ctx.sampleRate;
        const length = rate * duration;
        const impulse = this.ctx.createBuffer(2, length, rate);
        const left = impulse.getChannelData(0);
        const right = impulse.getChannelData(1);

        for (let i = 0; i < length; i++) {
          // Exponential decay noise
          const n = i / length;
          const env = Math.pow(1 - n, decay);
          left[i] = (Math.random() * 2 - 1) * env;
          right[i] = (Math.random() * 2 - 1) * env;
        }
        return impulse;
      }

      start() {
        this.tickCount = 0;
        this.startTime = this.ctx.currentTime;
        this.phase = 'explosion';

        // Trigger the blinding light immediately
        this.playExplosion();

        // Start the loop
        this.loop();
      }

      stop() {
        if (this.timer) clearTimeout(this.timer);
        this.masterGain.gain.cancelScheduledValues(this.ctx.currentTime);
        this.masterGain.gain.linearRampToValueAtTime(0, this.ctx.currentTime + 0.1);
      }

      loop() {
        const secondsPerBeat = 60 / this.tempo;
        const interval = (secondsPerBeat / 4) * 1000; // 16th notes

        this.timer = setTimeout(() => this.loop(), interval);

        const t = this.ctx.currentTime - this.startTime;
        const step = this.tickCount % 32;

        // --- CINEMATIC TIMELINE ---

        // 0s - 4s: The Explosion (Handled in start(), we just wait)
        if (t < 4.0) {
          // Do nothing, let the noise fade
        }
        // 4s - 12s: The "Glimpse" (Lonely Piano)
        else if (t >= 4.0 && t < 16.0) {
          this.phase = 'piano_solo';
          if (step % 4 === 0) this.playPianoMelody(step);
          if (step % 16 === 0) this.playBassPad(0); // Root
        }
        // 16s+: The "Walk Away" (Strings + Sparkles)
        else {
          this.phase = 'tutti';

          // Piano continues
          if (step % 4 === 0) this.playPianoMelody(step);

          // Strings Swell (New chord every 2 bars)
          if (step % 32 === 0) {
            // Progression: I -> IV -> I -> V
            const chord = (this.tickCount % 64 === 0) ? 0 : 5; // I or IV
            this.playStringSection(chord);
          }

          // The "Repair" Sparkles (Magic fixing the world)
          if (step % 2 === 0) this.playSparkle(step);
        }

        this.tickCount++;
      }

      // --- INSTRUMENTS ---

      playExplosion() {
        const t = this.ctx.currentTime;

        // 1. White Noise Burst (The "Flash")
        const buf = this.ctx.createBuffer(1, 44100 * 4, this.ctx.sampleRate);
        const data = buf.getChannelData(0);
        for (let i = 0; i < data.length; i++) data[i] = Math.random() * 2 - 1;
        const src = this.ctx.createBufferSource();
        src.buffer = buf;

        // Lowpass Filter sweep (Opening up the sound)
        const f = this.ctx.createBiquadFilter();
        f.type = 'lowpass';
        f.frequency.setValueAtTime(100, t);
        f.frequency.exponentialRampToValueAtTime(10000, t + 0.5); // Flash

        const g = this.ctx.createGain();
        g.gain.setValueAtTime(0, t);
        g.gain.linearRampToValueAtTime(0.8, t + 0.1);
        g.gain.exponentialRampToValueAtTime(0.001, t + 3.5); // Long fade out

        src.connect(f); f.connect(g); g.connect(this.input);
        src.start(t);

        // 2. Sub Bass Drop (The "Impact")
        const osc = this.ctx.createOscillator();
        osc.frequency.setValueAtTime(100, t);
        osc.frequency.exponentialRampToValueAtTime(20, t + 2.0);

        const g2 = this.ctx.createGain();
        g2.gain.setValueAtTime(0.5, t);
        g2.gain.exponentialRampToValueAtTime(0.001, t + 2.0);

        osc.connect(g2); g2.connect(this.input);
        osc.start(t);
      }

      playPianoMelody(step) {
        // Procedural "Hope" Melody
        // Keeps it simple, mostly stepwise motion
        const t = this.ctx.currentTime;

        // Random note from scale (Pentatonic-ish for safety)
        // 0, 1, 2, 4, 5 (Eb, F, G, Bb, C)
        const safeNotes = [0, 2, 4, 7, 9, 11];
        const noteIndex = safeNotes[Math.floor(Math.random() * safeNotes.length)];

        // Octave: Middle range
        const freq = this.keyBase * Math.pow(2, (this.scale[noteIndex % 7] + 12) / 12);

        // SOUND: Soft Piano (Sine + Triangle)
        const osc = this.ctx.createOscillator();
        osc.type = 'triangle'; // Triangle has a nice hollow wood sound
        osc.frequency.value = freq;

        const g = this.ctx.createGain();
        g.gain.setValueAtTime(0, t);
        g.gain.linearRampToValueAtTime(0.2, t + 0.05); // Soft attack
        g.gain.exponentialRampToValueAtTime(0.001, t + 3.0); // Long ring

        osc.connect(g); g.connect(this.input);
        osc.start(t); osc.stop(t + 3.0);
      }

      playStringSection(rootIndex) {
        // Lush Pad
        const t = this.ctx.currentTime;
        const chordOffsets = [0, 2, 4, 6]; // Major 7th Chord (Lush/Nostalgic)

        chordOffsets.forEach((offset, i) => {
          const idx = (rootIndex + offset) % 7;
          const semitone = this.scale[idx];
          const freq = this.keyBase * Math.pow(2, semitone / 12);

          // Dual Oscillator for width
          this.createPadVoice(t, freq);
          // Add a lower octave for the root
          if (i === 0) this.createPadVoice(t, freq / 2);
        });
      }

      createPadVoice(t, freq) {
        const osc = this.ctx.createOscillator();
        osc.type = 'sawtooth';
        osc.frequency.value = freq;
        osc.detune.value = (Math.random() * 10) - 5; // Detuned

        const f = this.ctx.createBiquadFilter();
        f.type = 'lowpass';
        f.frequency.value = 600; // Very warm, muffled

        const g = this.ctx.createGain();
        g.gain.setValueAtTime(0, t);
        g.gain.linearRampToValueAtTime(0.05, t + 2.0); // Slow swell (2 seconds)
        g.gain.setTargetAtTime(0, t + 6.0, 1.0); // Slow release

        osc.connect(f); f.connect(g); g.connect(this.input);
        osc.start(t); osc.stop(t + 8.0);
      }

      playSparkle(step) {
        // High pitched sine waves panning around
        // Represents "light" or "magic"
        const t = this.ctx.currentTime;

        // Ascending run
        const noteIndex = step % 7;
        const freq = (this.keyBase * 4) * Math.pow(2, this.scale[noteIndex] / 12);

        const osc = this.ctx.createOscillator();
        osc.type = 'sine';
        osc.frequency.value = freq;

        const panner = this.ctx.createStereoPanner();
        panner.pan.value = Math.sin(t * 2); // Pan back and forth

        const g = this.ctx.createGain();
        g.gain.setValueAtTime(0, t);
        g.gain.linearRampToValueAtTime(0.05, t + 0.1);
        g.gain.exponentialRampToValueAtTime(0.001, t + 0.5);

        osc.connect(g); g.connect(panner); panner.connect(this.input);
        osc.start(t); osc.stop(t + 0.5);
      }

      playBassPad(rootIndex) {
        const t = this.ctx.currentTime;
        const freq = (this.keyBase / 2) * Math.pow(2, this.scale[rootIndex] / 12);

        const osc = this.ctx.createOscillator();
        osc.type = 'sine'; // Sub bass
        osc.frequency.value = freq;

        const g = this.ctx.createGain();
        g.gain.setValueAtTime(0, t);
        g.gain.linearRampToValueAtTime(0.3, t + 1.0);
        g.gain.setTargetAtTime(0, t + 3.0, 1.0);

        osc.connect(g); g.connect(this.input);
        osc.start(t); osc.stop(t + 5.0);
      }
    }
    //MODULE 4: THE DEEP DUNGEON (FM Synthesis)
    class DungeonM {
      constructor(ctx, dest) {
        this.ctx = ctx;
        this.mainOut = dest;
        this.timer = null;
        this.tempo = 60; // Slower tempo for heaviness

        // 1. THE FX CHAIN (Compressor -> Dark Reverb)
        this.masterGain = ctx.createGain();
        this.masterGain.gain.value = 0.7;

        this.comp = ctx.createDynamicsCompressor();
        this.comp.threshold.value = -30;
        this.comp.ratio.value = 12; // Heavy compression to sustain the tails

        // "Stone Wall" EQ - Cut the highs, boost the low-mids
        this.eq = ctx.createBiquadFilter();
        this.eq.type = 'lowpass';
        this.eq.frequency.value = 3000;

        // 2. CONVOLUTION REVERB (The "Great Hall")
        this.revNode = ctx.createConvolver();
        this.setupDarkReverb();

        this.revGain = ctx.createGain(); this.revGain.gain.value = 0.6; // Wet
        this.dryGain = ctx.createGain(); this.dryGain.gain.value = 0.4; // Dry

        // Connect Chain
        this.masterGain.connect(this.comp);
        this.comp.connect(this.eq);
        this.eq.connect(this.dryGain);
        this.eq.connect(this.revNode);
        this.revNode.connect(this.revGain);
        this.dryGain.connect(this.mainOut);
        this.revGain.connect(this.mainOut);

        // 3. CONFIGURATION
        this.cfg = {
          // Darker, "Ancient" Scales
          scales: {
            phrygianDom: [0, 1, 4, 5, 7, 8, 10], // "Desert Temple"
            hungarian: [0, 2, 3, 6, 7, 8, 11], // "Vampire Castle"
            locrian: [0, 1, 3, 5, 6, 8, 10]  // "Unsettling/Wrong"
          },
          voices: {
            // FM Bell sound
            chime: { p: 0.6, type: 'sine', range: [12, 14, 24], modIndex: 12, decay: 3.0 },
            // Deep resonant pad
            bass: { p: 0.4, type: 'triangle', range: [-12, -24], modIndex: 2, decay: 2.0 }
          }
        };

        this.st = {
          tickCount: 0,
          scaleIntervals: this.cfg.scales.phrygianDom,
          rootFreq: 55 // Low A (A1) as absolute anchor
        };

        this.droneOsc = null;
        this.droneGain = null;
      }

      setupDarkReverb() {
        // Generate a 4-second reverb tail (Massive space)
        const duration = 4.0;
        const len = this.ctx.sampleRate * duration;
        const buf = this.ctx.createBuffer(2, len, this.ctx.sampleRate);
        for (let c = 0; c < 2; c++) {
          const d = buf.getChannelData(c);
          for (let i = 0; i < len; i++) {
            // Exponential decay for realistic "room" fade
            // Multiplied by random noise
            d[i] = (Math.random() * 2 - 1) * Math.pow(1 - (i / len), 4.0);
          }
        }
        this.revNode.buffer = buf;
      }

      start() {
        this.st.tickCount = 0;
        this.startDrone(); // The constant background hum

        // Randomly tick between 0.5s and 2s
        const tickLoop = () => {
          this.tick();
          // Randomize timing for "Human" feel (not robotic)
          const nextTick = 500 + Math.random() * 1500;
          this.timer = setTimeout(tickLoop, nextTick);
        };
        tickLoop();
      }

      stop() {
        if (this.timer) clearTimeout(this.timer);

        // Fade out everything
        this.masterGain.gain.setTargetAtTime(0, this.ctx.currentTime, 0.5);

        // Kill drone specifically
        if (this.droneGain) {
          this.droneGain.gain.linearRampToValueAtTime(0, this.ctx.currentTime + 1);
          setTimeout(() => {
            if (this.droneOsc) this.droneOsc.stop();
            this.masterGain.disconnect();
          }, 1500);
        }
      }

      startDrone() {
        // A low, detuned saw wave that plays forever (The "Room Tone")
        const t = this.ctx.currentTime;
        this.droneOsc = this.ctx.createOscillator();
        this.droneOsc.type = 'sawtooth';
        this.droneOsc.frequency.value = 55; // Low A

        const filter = this.ctx.createBiquadFilter();
        filter.type = 'lowpass';
        filter.frequency.value = 120; // Muffled

        this.droneGain = this.ctx.createGain();
        this.droneGain.gain.value = 0.05; // Quiet rumble

        this.droneOsc.connect(filter);
        filter.connect(this.droneGain);
        this.droneGain.connect(this.masterGain); // Goes through reverb!
        this.droneOsc.start(t);
      }

      tick() {
        this.st.tickCount++;

        // 10% chance to change scale for a "room change" feel
        if (Math.random() < 0.1) {
          const keys = Object.keys(this.cfg.scales);
          const key = keys[Math.floor(Math.random() * keys.length)];
          this.st.scaleIntervals = this.cfg.scales[key];
        }

        // Try to play Chime
        if (Math.random() > 0.4) this.playFMVoice('chime');

        // Try to play Bass swell
        if (Math.random() > 0.7) this.playFMVoice('bass');
      }

      // FM SYNTHESIS ENGINE
      playFMVoice(type) {
        const v = this.cfg.voices[type];
        const t = this.ctx.currentTime;

        // 1. Pitch Selection
        const scale = this.st.scaleIntervals;
        const degree = scale[Math.floor(Math.random() * scale.length)];
        const octaveOffset = v.range[Math.floor(Math.random() * v.range.length)];
        // Calculate frequency from root (55Hz)
        const noteValue = degree + octaveOffset;
        const freq = this.st.rootFreq * Math.pow(2, noteValue / 12);

        // 2. The Setup (Carrier + Modulator)
        const carrier = this.ctx.createOscillator();
        const modulator = this.ctx.createOscillator();
        const modGain = this.ctx.createGain();
        const masterVol = this.ctx.createGain();

        // 3. FM Configuration
        carrier.type = v.type;
        carrier.frequency.value = freq;

        // "Metallic" Ratio: Non-integer ratios create bell sounds
        const ratio = 2.0 + (Math.random() * 0.5);
        modulator.type = 'sine';
        modulator.frequency.value = freq * ratio;

        // The "Clang" intensity
        modGain.gain.value = freq * v.modIndex;

        // 4. Envelope (ADSR)
        masterVol.gain.setValueAtTime(0, t);
        masterVol.gain.linearRampToValueAtTime(0.2, t + 0.1); // Fast attack
        masterVol.gain.exponentialRampToValueAtTime(0.001, t + v.decay); // Long, ringing tail

        // Modulator Envelope (Brightness fades faster than volume -> "Pluck" sound)
        modGain.gain.setValueAtTime(freq * v.modIndex, t);
        modGain.gain.exponentialRampToValueAtTime(0.01, t + (v.decay * 0.5));

        // 5. Wiring
        modulator.connect(modGain);
        modGain.connect(carrier.frequency); // This is the FM magic
        carrier.connect(masterVol);
        masterVol.connect(this.masterGain);

        // 6. Start/Stop
        carrier.start(t);
        modulator.start(t);
        carrier.stop(t + v.decay + 1);
        modulator.stop(t + v.decay + 1);
      }
    }
    // MODULE 5: BOSS BATTLE
    class BossBattleModule {
      constructor(ctx, dest) {
        this.ctx = ctx;
        this.dest = dest;
        this.timer = null;

        // 1. GLOBAL FX: COMPRESSION & EQ (No Distortion)
        this.master = ctx.createGain();
        this.master.gain.value = 0.5;

        // Compressor: Keeps levels tight without crushing them
        this.limiter = ctx.createDynamicsCompressor();
        this.limiter.threshold.value = -12;
        this.limiter.ratio.value = 12;
        this.limiter.attack.value = 0.005;

        // Master EQ: Gentle High-Shelf cut to remove "Digital Harshness"
        this.eq = ctx.createBiquadFilter();
        this.eq.type = 'highshelf';
        this.eq.frequency.value = 3000; // Frequencies above 3kHz
        this.eq.gain.value = -10;       // Reduce by 10dB (Warmth)

        // Reverb: "Glues" the sounds together
        this.revNode = ctx.createConvolver();
        this.setupReverb();
        this.revGain = ctx.createGain();
        this.revGain.gain.value = 0.35; // Moderate reverb amount

        // Wiring: Source -> Limiter -> EQ -> (Split to Reverb/Dry) -> Master
        this.limiter.connect(this.eq);

        this.eq.connect(this.master); // Dry path
        this.eq.connect(this.revNode); // Wet path start
        this.revNode.connect(this.revGain);
        this.revGain.connect(this.master); // Wet path end

        this.master.connect(this.dest);

        // This is the input point for all instruments
        this.input = this.limiter;

        // 2. BATTLE STATE (Same Logic as before)
        this.tempo = 175;
        this.tickCount = 0;
        this.currentScale = [];
        this.rootFreq = 110; // A2
        this.progression = [0, 5, 3, 4];
        this.currentChordIndex = 0;
        this.momentum = 5;
      }

      setupReverb() {
        // Creates a short, dense "Room" reverb
        const len = this.ctx.sampleRate * 1.5; // 1.5 seconds
        const buf = this.ctx.createBuffer(2, len, this.ctx.sampleRate);
        for (let c = 0; c < 2; c++) {
          const d = buf.getChannelData(c);
          for (let i = 0; i < len; i++) {
            // Decay envelope
            d[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / len, 3);
          }
        }
        this.revNode.buffer = buf;
      }

      start() {
        this.generateScale('harmonicMinor');
        const noteDuration = (60 / this.tempo) / 4;
        this.timer = setInterval(() => this.tick(), noteDuration * 1000);
      }

      stop() {
        clearInterval(this.timer);
        this.master.gain.linearRampToValueAtTime(0, this.ctx.currentTime + 0.2);
      }

      generateScale(type) {
        const intervals = [0, 2, 3, 5, 7, 8, 11];
        this.currentScale = intervals.map(i => this.rootFreq * Math.pow(2, i / 12));
      }

      tick() {
        const t = this.ctx.currentTime;
        const barStep = this.tickCount % 16;

        this.playDrums(t, barStep);

        if (barStep % 2 === 0 || Math.random() > 0.3) {
          this.playBass(t);
        }

        if (barStep === 0 || (barStep === 6 && Math.random() > 0.5)) {
          this.playHit(t);
        }

        if (Math.random() < (this.momentum / 10)) {
          this.playLead(t);
        }

        if (barStep === 15) {
          this.currentChordIndex = (this.currentChordIndex + 1) % this.progression.length;
          this.tickCount = -1;
          this.momentum = Math.floor(Math.random() * 8) + 2;
        }

        this.tickCount++;
      }

      // --- INSTRUMENTS (UPDATED FOR WARMTH) ---

      playDrums(t, step) {
        if (step % 4 === 0) { // Kick
          const osc = this.ctx.createOscillator();
          const g = this.ctx.createGain();
          osc.frequency.setValueAtTime(150, t);
          osc.frequency.exponentialRampToValueAtTime(0.01, t + 0.1);
          g.gain.setValueAtTime(1.0, t);
          g.gain.exponentialRampToValueAtTime(0.01, t + 0.1);
          osc.connect(g); g.connect(this.input);
          osc.start(t); osc.stop(t + 0.1);
        }

        if (step === 4 || step === 12) { // Snare
          const noise = this.ctx.createBufferSource();
          noise.buffer = this.createNoiseBuffer();
          const g = this.ctx.createGain();
          const filter = this.ctx.createBiquadFilter();

          // Lowered Highpass frequency to give snare more "Body", less "Hiss"
          filter.type = 'highpass'; filter.frequency.value = 600;

          g.gain.setValueAtTime(0.5, t); // Lower volume slightly
          g.gain.exponentialRampToValueAtTime(0.01, t + 0.15);

          noise.connect(filter); filter.connect(g); g.connect(this.input);
          noise.start(t); noise.stop(t + 0.15);
        }
      }

      playBass(t) {
        const degree = this.progression[this.currentChordIndex];
        const freq = this.currentScale[degree] / 2;

        const osc = this.ctx.createOscillator();
        const g = this.ctx.createGain();
        const f = this.ctx.createBiquadFilter();

        osc.type = 'sawtooth';
        osc.frequency.setValueAtTime(freq, t);

        // CHANGED: Lowered the cutoff significantly (1500 -> 600)
        // This makes the bass sound "Deep" instead of "Buzzy"
        f.type = 'lowpass';
        f.frequency.setValueAtTime(100, t);
        f.frequency.linearRampToValueAtTime(600, t + 0.01);
        f.frequency.exponentialRampToValueAtTime(100, t + 0.15);

        g.gain.setValueAtTime(0.6, t);
        g.gain.linearRampToValueAtTime(0, t + 0.15);

        osc.connect(f); f.connect(g); g.connect(this.input);
        osc.start(t); osc.stop(t + 0.15);
      }

      playHit(t) {
        const rootIdx = this.progression[this.currentChordIndex];
        const chord = [rootIdx, rootIdx + 2, rootIdx + 4];

        chord.forEach(idx => {
          const noteFreq = this.currentScale[idx % this.currentScale.length] * (idx >= 7 ? 2 : 1);

          const osc = this.ctx.createOscillator();
          const g = this.ctx.createGain();
          const f = this.ctx.createBiquadFilter(); // Added Filter per voice

          osc.type = 'sawtooth'; // Changed Square -> Sawtooth (Richer)
          osc.frequency.value = noteFreq;

          // Filter: "Brass" envelope
          f.type = 'lowpass';
          f.frequency.setValueAtTime(300, t);
          f.frequency.linearRampToValueAtTime(2000, t + 0.05); // "Blare"
          f.frequency.exponentialRampToValueAtTime(500, t + 0.3); // Mellow out

          g.gain.setValueAtTime(0.2, t); // Lower volume per voice
          g.gain.exponentialRampToValueAtTime(0.01, t + 0.3);

          osc.connect(f); f.connect(g); g.connect(this.input);
          osc.start(t); osc.stop(t + 0.3);
        });
      }

      playLead(t) {
        const scaleIdx = Math.floor(Math.random() * this.currentScale.length);
        const octave = Math.random() > 0.5 ? 2 : 4;
        const freq = this.currentScale[scaleIdx] * octave;

        const osc = this.ctx.createOscillator();
        const g = this.ctx.createGain();
        const f = this.ctx.createBiquadFilter(); // Added filter

        osc.type = 'triangle'; // Triangle is naturally soft
        osc.frequency.setValueAtTime(freq, t);

        if (Math.random() > 0.5) {
          osc.frequency.setValueAtTime(freq * 0.9, t);
          osc.frequency.linearRampToValueAtTime(freq, t + 0.05);
        }

        // Slight lowpass to remove digital aliasing on high notes
        f.type = 'lowpass';
        f.frequency.value = 3000;

        g.gain.setValueAtTime(0, t);
        g.gain.linearRampToValueAtTime(0.3, t + 0.02);
        g.gain.linearRampToValueAtTime(0, t + 0.2);

        osc.connect(f); f.connect(g); g.connect(this.input);
        osc.start(t); osc.stop(t + 0.2);
      }

      createNoiseBuffer() {
        const bufferSize = this.ctx.sampleRate * 2;
        const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
        const output = buffer.getChannelData(0);
        for (let i = 0; i < bufferSize; i++) {
          output[i] = Math.random() * 2 - 1;
        }
        return buffer;
      }
    }
    //MODULE OLD: THE FINAL BOSS (High Octane)
    class BossBattleModuleOLD {
      constructor(ctx, dest) {
        this.ctx = ctx;
        this.dest = dest;
        this.timer = null;

        // 1. GLOBAL FX: COMPRESSION & OVERDRIVE
        // Boss music needs to be LOUD and slightly distorted.
        this.master = ctx.createGain();
        this.master.gain.value = 0.6;

        this.limiter = ctx.createDynamicsCompressor();
        this.limiter.threshold.value = -10;
        this.limiter.ratio.value = 20;

        this.drive = ctx.createWaveShaper();
        this.drive.curve = this.makeDistortionCurve(50); // Mild distortion
        this.drive.oversample = '4x';

        this.limiter.connect(this.drive);
        this.drive.connect(this.master);
        this.master.connect(this.dest);

        // 2. BATTLE STATE
        this.tempo = 175; // Fast pacing
        this.tickCount = 0; // 16th note counter
        this.currentScale = []; // Will hold our frequencies
        this.rootFreq = 110; // A2

        // Battle Progression Logic
        this.progression = [0, 5, 3, 4]; // i - VI - iv - V (Classic JRPG Tension)
        this.currentChordIndex = 0;

        // Momentum (Energy levels)
        this.momentum = 5;
      }

      start() {
        this.generateScale('harmonicMinor'); // The "Heroic/Gothic" scale
        const noteDuration = (60 / this.tempo) / 4; // 16th note duration
        this.timer = setInterval(() => this.tick(), noteDuration * 1000);
      }

      stop() {
        clearInterval(this.timer);
        // Quick fade out
        this.master.gain.linearRampToValueAtTime(0, this.ctx.currentTime + 0.2);
      }

      // --- THEORY ENGINE ---
      generateScale(type) {
        // A Harmonic Minor: Classic Boss Battle Scale
        const intervals = [0, 2, 3, 5, 7, 8, 11];
        this.currentScale = intervals.map(i => this.rootFreq * Math.pow(2, i / 12));
      }

      // --- THE LOOP ---
      tick() {
        const t = this.ctx.currentTime;
        const barStep = this.tickCount % 16; // 16 steps in a bar

        // 1. THE DRUMS (The Driving Force)
        this.playDrums(t, barStep);

        // 2. THE BASS (The "Gallop")
        // Plays on almost every 16th note to create urgency
        if (barStep % 2 === 0 || Math.random() > 0.3) {
          this.playBass(t);
        }

        // 3. ORCHESTRA HITS (Harmony)
        // Hit on step 0 (downbeat) and sometimes syncopated on 6 or 12
        if (barStep === 0 || (barStep === 6 && Math.random() > 0.5)) {
          this.playHit(t);
        }

        // 4. HEROIC MELODY (Lead)
        // High momentum = fast runs (arpeggios). Low momentum = sustained notes.
        if (Math.random() < (this.momentum / 10)) {
          this.playLead(t);
        }

        // Progression Logic: Change chord every 16 ticks (1 bar)
        if (barStep === 15) {
          this.currentChordIndex = (this.currentChordIndex + 1) % this.progression.length;
          this.tickCount = -1; // Reset

          // Randomly modulate momentum
          this.momentum = Math.floor(Math.random() * 8) + 2;
        }

        this.tickCount++;
      }

      // --- INSTRUMENTS ---

      playDrums(t, step) {
        // Kick on 0, 4, 8, 12 (Four on the floor driving beat)
        if (step % 4 === 0) {
          const osc = this.ctx.createOscillator();
          const g = this.ctx.createGain();
          osc.frequency.setValueAtTime(150, t);
          osc.frequency.exponentialRampToValueAtTime(0.01, t + 0.1); // Thud
          g.gain.setValueAtTime(1.0, t);
          g.gain.exponentialRampToValueAtTime(0.01, t + 0.1);
          osc.connect(g); g.connect(this.limiter);
          osc.start(t); osc.stop(t + 0.1);
        }

        // Snare/Clap on 4 and 12 (Backbeat)
        if (step === 4 || step === 12) {
          const noise = this.ctx.createBufferSource();
          noise.buffer = this.createNoiseBuffer();
          const g = this.ctx.createGain();
          // High pass filter for "crisp" sound
          const filter = this.ctx.createBiquadFilter();
          filter.type = 'highpass'; filter.frequency.value = 1000;

          g.gain.setValueAtTime(0.7, t);
          g.gain.exponentialRampToValueAtTime(0.01, t + 0.15);

          noise.connect(filter); filter.connect(g); g.connect(this.limiter);
          noise.start(t); noise.stop(t + 0.15);
        }
      }

      playBass(t) {
        // Get the frequency of the current chord root
        const degree = this.progression[this.currentChordIndex];
        const freq = this.currentScale[degree] / 2; // Octave down

        const osc = this.ctx.createOscillator();
        const g = this.ctx.createGain();
        const f = this.ctx.createBiquadFilter();

        // Sawtooth = "Aggressive"
        osc.type = 'sawtooth';
        osc.frequency.setValueAtTime(freq, t);

        // Low Pass Filter Envelope (The "Pluck" sound)
        f.type = 'lowpass';
        f.frequency.setValueAtTime(200, t);
        f.frequency.linearRampToValueAtTime(1500, t + 0.01); // Open fast
        f.frequency.exponentialRampToValueAtTime(200, t + 0.1); // Close fast

        g.gain.setValueAtTime(0.5, t);
        g.gain.linearRampToValueAtTime(0, t + 0.15); // Short notes

        osc.connect(f); f.connect(g); g.connect(this.limiter);
        osc.start(t); osc.stop(t + 0.15);
      }

      playHit(t) {
        // Play a triad (Root, 3rd, 5th) simultaneously
        const rootIdx = this.progression[this.currentChordIndex];
        const chord = [rootIdx, rootIdx + 2, rootIdx + 4]; // 1-3-5 intervals

        chord.forEach(idx => {
          // Handle array wrap-around for scale
          const noteFreq = this.currentScale[idx % this.currentScale.length] * (idx >= 7 ? 2 : 1);

          const osc = this.ctx.createOscillator();
          const g = this.ctx.createGain();

          osc.type = 'square'; // Square wave = Retro/Gamey sound
          osc.frequency.value = noteFreq;

          // Fast decay "Stab"
          g.gain.setValueAtTime(0.3, t);
          g.gain.exponentialRampToValueAtTime(0.01, t + 0.3);

          osc.connect(g); g.connect(this.limiter);
          osc.start(t); osc.stop(t + 0.3);
        });
      }

      playLead(t) {
        // Pick a random note from the scale
        const scaleIdx = Math.floor(Math.random() * this.currentScale.length);
        // 50% chance to be an octave higher
        const octave = Math.random() > 0.5 ? 2 : 4;
        const freq = this.currentScale[scaleIdx] * octave;

        const osc = this.ctx.createOscillator();
        const g = this.ctx.createGain();

        // Triangle is clearer for melody
        osc.type = 'triangle';
        osc.frequency.setValueAtTime(freq, t);

        // Slide! (Portamento) - Essential for "Heroic" feel
        if (Math.random() > 0.5) {
          osc.frequency.setValueAtTime(freq * 0.9, t);
          osc.frequency.linearRampToValueAtTime(freq, t + 0.05);
        }

        g.gain.setValueAtTime(0, t);
        g.gain.linearRampToValueAtTime(0.4, t + 0.02);
        g.gain.linearRampToValueAtTime(0, t + 0.2); // Fast 16th notes

        osc.connect(g); g.connect(this.limiter);
        osc.start(t); osc.stop(t + 0.2);
      }

      // --- UTILS ---
      createNoiseBuffer() {
        const bufferSize = this.ctx.sampleRate * 2; // 2 seconds
        const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
        const output = buffer.getChannelData(0);
        for (let i = 0; i < bufferSize; i++) {
          output[i] = Math.random() * 2 - 1;
        }
        return buffer;
      }

      makeDistortionCurve(amount) {
        const k = typeof amount === 'number' ? amount : 50;
        const n_samples = 44100;
        const curve = new Float32Array(n_samples);
        const deg = Math.PI / 180;
        for (let i = 0; i < n_samples; ++i) {
          const x = i * 2 / n_samples - 1;
          curve[i] = (3 + k) * x * 20 * deg / (Math.PI + k * Math.abs(x));
        }
        return curve;
      }
    }
    //MODULE 6: THE RAID BOSS (Epic/Cinematic)
    class RaidBossModule {
      constructor(ctx, dest) {
        this.ctx = ctx;
        this.dest = dest;
        this.timer = null;

        // 1. THE "GRAND HALL" FX CHAIN
        this.master = ctx.createGain();
        this.master.gain.value = 0.5;

        // A heavy compressor to make the drums "thud" against the choir
        this.comp = ctx.createDynamicsCompressor();
        this.comp.threshold.value = -24;
        this.comp.ratio.value = 12;
        this.comp.attack.value = 0.003;

        // Dark Reverb (The Raid Zone)
        this.revNode = ctx.createConvolver();
        this.setupReverb();
        this.revGain = ctx.createGain(); this.revGain.gain.value = 0.5;

        // Connect
        this.master.connect(this.comp);
        this.comp.connect(this.dest);
        this.comp.connect(this.revNode);
        this.revNode.connect(this.revGain);
        this.revGain.connect(this.dest);

        // 2. MUSICAL STATE
        this.tempo = 75; // Slow, marching tempo
        this.tickCount = 0;

        // C Minor / Eb Major (Epic, Serious)
        this.scale = [
          130.81, // C3
          146.83, // D3
          155.56, // Eb3
          174.61, // F3
          196.00, // G3
          207.65, // Ab3
          233.08  // Bb3
        ];

        // Chord Progressions (The "Loop")
        // i - VI - III - VII (Classic Epic Progression)
        this.chords = [
          [0, 2, 4], // Cm
          [5, 7, 9], // Ab (VI) - Note: indices wrap around
          [2, 4, 6], // Eb (III)
          [6, 8, 10] // Bb (VII)
        ];
        this.currentChord = 0;
      }

      setupReverb() {
        // Generate a 3-second dark impulse
        const len = this.ctx.sampleRate * 3;
        const buf = this.ctx.createBuffer(2, len, this.ctx.sampleRate);
        for (let c = 0; c < 2; c++) {
          const d = buf.getChannelData(c);
          for (let i = 0; i < len; i++) {
            // Low-pass noise for "muddy/stone" sound
            d[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / len, 2);
          }
        }
        this.revNode.buffer = buf;
      }

      start() {
        this.tickCount = 0;
        this.currentChord = 0;

        // Calculate 8th note duration
        const interval = (60 / this.tempo) / 2 * 1000;

        // Start the loop
        this.timer = setInterval(() => this.tick(), interval);
      }

      stop() {
        if (this.timer) clearInterval(this.timer);
        this.master.gain.linearRampToValueAtTime(0, this.ctx.currentTime + 0.5);
      }

      // --- THE CONDUCTOR ---
      tick() {
        const t = this.ctx.currentTime;
        const step = this.tickCount % 16; // 2 bars of 4/4

        // 1. WAR DRUMS (Orchestral Percussion)
        // Pattern: BOOM ... BOOM-boom ... (The March)
        if (step === 0 || step === 8) this.playTimpani(t, 'high'); // Downbeat
        if (step === 10 || step === 14) this.playTimpani(t, 'low'); // Fill

        // 2. SNARE/CLASH (The Accent)
        if (step === 4 || step === 12) this.playSnare(t);

        // 3. THE CHOIR (Pads)
        // Change chord every 16 steps (2 bars)
        if (step === 0) {
          this.playChoir(t);
          // Advance chord progression for next time
          if (this.tickCount > 0 && this.tickCount % 32 === 0) {
            this.currentChord = (this.currentChord + 1) % this.chords.length;
          }
        }

        // 4. THE BRASS LEADS (Melody)
        // Slow, majestic notes. Not fast.
        // Play on beat 0, 3, 6, etc. (Polyrhythmic feel)
        if (step % 4 === 0 || (step === 2 && Math.random() > 0.6)) {
          this.playBrass(t, step === 0); // Accentuate downbeat
        }

        this.tickCount++;
      }

      // --- INSTRUMENTS ---

      playTimpani(t, tone) {
        // Deep, resonant sine wave + noise burst
        const osc = this.ctx.createOscillator();
        const g = this.ctx.createGain();

        osc.frequency.setValueAtTime(tone === 'high' ? 80 : 60, t);
        osc.frequency.exponentialRampToValueAtTime(30, t + 0.3); // Pitch drop

        g.gain.setValueAtTime(0.8, t);
        g.gain.exponentialRampToValueAtTime(0.01, t + 0.5);

        osc.connect(g); g.connect(this.master);
        osc.start(t); osc.stop(t + 0.5);
      }

      playSnare(t) {
        // A wash of noise, low-passed (Orchestral Snare/Cymbal swell)
        const bufSize = this.ctx.sampleRate * 0.5;
        const buf = this.ctx.createBuffer(1, bufSize, this.ctx.sampleRate);
        const data = buf.getChannelData(0);
        for (let i = 0; i < bufSize; i++) data[i] = Math.random() * 2 - 1;

        const noise = this.ctx.createBufferSource();
        noise.buffer = buf;

        const filter = this.ctx.createBiquadFilter();
        filter.type = 'lowpass';
        filter.frequency.value = 1500; // Dark snare

        const g = this.ctx.createGain();
        g.gain.setValueAtTime(0.4, t);
        g.gain.exponentialRampToValueAtTime(0.01, t + 0.3);

        noise.connect(filter); filter.connect(g); g.connect(this.master);
        noise.start(t);
      }

      playChoir(t) {
        // Play the triad of the current chord
        const indices = this.chords[this.currentChord];

        indices.forEach(idx => {
          // Map index to frequency (wrapping scale)
          let freq = this.scale[idx % this.scale.length];
          if (idx >= 7) freq *= 2; // Octave up

          // Create "Choir" voice (2 oscillators slightly detuned)
          const osc1 = this.ctx.createOscillator();
          const osc2 = this.ctx.createOscillator();
          osc1.type = 'triangle';
          osc2.type = 'sine'; // Sine adds "breath"

          osc1.frequency.value = freq;
          osc2.frequency.value = freq + (Math.random() * 2 - 1); // Detune

          const g = this.ctx.createGain();
          // Long Attack (Fade in) -> Long Sustain -> Long Release
          g.gain.setValueAtTime(0, t);
          g.gain.linearRampToValueAtTime(0.15, t + 1.0); // 1s attack
          g.gain.setValueAtTime(0.15, t + 3.0); // Hold
          g.gain.linearRampToValueAtTime(0, t + 4.0); // Release

          osc1.connect(g); osc2.connect(g);
          g.connect(this.master);

          osc1.start(t); osc1.stop(t + 4.5);
          osc2.start(t); osc2.stop(t + 4.5);
        });

        // Add a Bass Root note
        const rootFreq = this.scale[indices[0] % 7] / 2; // Octave down
        const bass = this.ctx.createOscillator();
        bass.type = 'sawtooth';
        bass.frequency.value = rootFreq;
        const bg = this.ctx.createGain();
        const bf = this.ctx.createBiquadFilter();
        bf.type = 'lowpass'; bf.frequency.value = 100; // Sub bass

        bg.gain.setValueAtTime(0, t);
        bg.gain.linearRampToValueAtTime(0.3, t + 1);
        bg.gain.linearRampToValueAtTime(0, t + 4);

        bass.connect(bf); bf.connect(bg); bg.connect(this.master);
        bass.start(t); bass.stop(t + 4.5);
      }

      playBrass(t, isStrong) {
        // Procedural melody logic
        const indices = this.chords[this.currentChord];
        // Pick a note from the chord (Consonant) or scale (Passing note)
        const noteIdx = Math.random() > 0.3 ?
          indices[Math.floor(Math.random() * indices.length)] :
          Math.floor(Math.random() * this.scale.length);

        let freq = this.scale[noteIdx % this.scale.length];
        // Brass plays high
        freq *= 2;

        const osc = this.ctx.createOscillator();
        osc.type = 'sawtooth';
        osc.frequency.value = freq;

        const filter = this.ctx.createBiquadFilter();
        filter.type = 'lowpass';
        filter.Q.value = 2; // Resonance for "brassy" sound

        const g = this.ctx.createGain();

        // Brass Envelope: swell into the note
        const dur = isStrong ? 1.5 : 0.8;

        // Filter Envelope (The "Wah" of the brass)
        filter.frequency.setValueAtTime(200, t);
        filter.frequency.linearRampToValueAtTime(2000, t + 0.1); // Bite
        filter.frequency.exponentialRampToValueAtTime(500, t + dur);

        // Volume Envelope
        g.gain.setValueAtTime(0, t);
        g.gain.linearRampToValueAtTime(0.15, t + 0.1);
        g.gain.linearRampToValueAtTime(0, t + dur);

        osc.connect(filter); filter.connect(g); g.connect(this.master);
        osc.start(t); osc.stop(t + dur + 0.1);
      }
    }
    //MODULE 7: THE STRATEGIST (Tactical March)  
    class TacticalModule {
      constructor(ctx, dest) {
        this.ctx = ctx;
        this.dest = dest;
        this.timer = null;

        // 1. DYNAMIC LAYERING (The Card Game Logic)
        this.intensity = 1; // 1 = Setup, 2 = Mid, 3 = Lethal

        // 2. GLOBAL MIX
        this.master = ctx.createGain();
        this.master.gain.value = 0.5;
        this.master.connect(this.dest);

        // 3. STATE
        this.tempo = 110; // March tempo
        this.tickCount = 0;
        this.keyBase = 146.83; // D3 (D Dorian - classic fantasy strategy key)

        // D Dorian Scale: D, E, F, G, A, B, C
        this.scale = [0, 2, 3, 5, 7, 9, 10];

        // Snare Pattern (1 = Hit, 0 = Rest, 2 = Accent)
        // "Ratta-tat-tat" military cadence
        this.snareGrid = [2, 0, 1, 0, 2, 1, 1, 0, 2, 0, 1, 0, 1, 1, 0, 1];
      }

      start() {
        this.tickCount = 0;
        // 16th note interval
        const interval = (60 / this.tempo) / 4 * 1000;
        this.timer = setInterval(() => this.tick(), interval);
      }

      stop() {
        if (this.timer) clearInterval(this.timer);
        this.master.gain.setTargetAtTime(0, this.ctx.currentTime, 0.1);
      }

      setIntensity(level) {
        // Smooth transition between game phases
        this.intensity = level;
      }

      // --- THE SEQUENCER ---
      tick() {
        const t = this.ctx.currentTime;
        const step = this.tickCount % 16; // 1 bar loop
        const bar = Math.floor(this.tickCount / 16) % 4; // 4 bar phrase

        // LAYER 1: THE FOUNDATION (Always On)
        // Military Snare
        const snareType = this.snareGrid[step];
        if (snareType > 0) this.playSnare(t, snareType === 2);

        // Kick Drum (On beats 1 and 3)
        if (step === 0 || step === 8) this.playKick(t);

        // LAYER 2: THE INTELLECT (Intensity 2+)
        // Staccato Strings (The "Clockwork" of strategy)
        if (this.intensity >= 2) {
          // Play on off-beats to create forward momentum
          if (step % 2 === 0) {
            // Arpeggiate current chord
            this.playStrings(t, step, bar);
          }
        }

        // LAYER 3: THE RESOLVE (Intensity 3 Only)
        // Low Brass / Horns (The "Army" has arrived)
        if (this.intensity >= 3) {
          // Long, swelling notes on the 1st beat of the bar
          if (step === 0) {
            this.playBrass(t, bar);
          }
        }

        this.tickCount++;
      }

      // --- INSTRUMENTS ---

      playSnare(t, accent) {
        // White noise burst
        const bufSize = this.ctx.sampleRate * 0.1; // Short
        const buffer = this.ctx.createBuffer(1, bufSize, this.ctx.sampleRate);
        const data = buffer.getChannelData(0);
        for (let i = 0; i < bufSize; i++) data[i] = Math.random() * 2 - 1;

        const noise = this.ctx.createBufferSource();
        noise.buffer = buffer;

        // Filter: High pass to make it crisp (Military style, not Rock style)
        const filt = this.ctx.createBiquadFilter();
        filt.type = 'highpass';
        filt.frequency.value = 1000;

        const gain = this.ctx.createGain();
        // Envelope: Very sharp snap
        const vol = accent ? 0.4 : 0.15; // Dynamics!
        gain.gain.setValueAtTime(vol, t);
        gain.gain.exponentialRampToValueAtTime(0.01, t + 0.08);

        noise.connect(filt); filt.connect(gain); gain.connect(this.master);
        noise.start(t);
      }

      playKick(t) {
        // Orchestral Bass Drum (Deep and boom-y)
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();

        osc.frequency.setValueAtTime(100, t);
        osc.frequency.exponentialRampToValueAtTime(30, t + 0.3); // Pitch dive

        gain.gain.setValueAtTime(0.5, t);
        gain.gain.exponentialRampToValueAtTime(0.01, t + 0.3);

        osc.connect(gain); gain.connect(this.master);
        osc.start(t); osc.stop(t + 0.3);
      }

      playStrings(t, step, bar) {
        // Logic: Walk up and down the Dorian scale
        // Bar 0: i (Dm), Bar 1: III (F), Bar 2: VII (C), Bar 3: V (Am)
        const chordRoots = [0, 3, 6, 4];
        const root = chordRoots[bar];

        // Arpeggiator pattern: Root -> 3rd -> 5th -> 3rd
        const arp = [0, 2, 4, 2];
        const noteIndex = (root + arp[(step / 2) % 4]) % this.scale.length;

        const freq = this.keyBase * Math.pow(2, this.scale[noteIndex] / 12);

        // Sound: Sawtooth wave with Low Pass (Spiccato Strings)
        const osc = this.ctx.createOscillator();
        osc.type = 'sawtooth';
        osc.frequency.value = freq * 2; // Octave up

        const filter = this.ctx.createBiquadFilter();
        filter.type = 'lowpass';
        filter.frequency.value = 600;

        const gain = this.ctx.createGain();
        gain.gain.setValueAtTime(0, t);
        gain.gain.linearRampToValueAtTime(0.15, t + 0.02);
        gain.gain.linearRampToValueAtTime(0, t + 0.1); // Short "Pluck"

        osc.connect(filter); filter.connect(gain); gain.connect(this.master);
        osc.start(t); osc.stop(t + 0.2);
      }

      playBrass(t, bar) {
        // Logic: Play the Root note of the chord
        const chordRoots = [0, 3, 6, 4];
        const noteIndex = chordRoots[bar];
        const freq = this.keyBase * Math.pow(2, this.scale[noteIndex] / 12);

        // Sound: Detuned Sawtooth (French Horn swell)
        const osc = this.ctx.createOscillator();
        osc.type = 'sawtooth';
        osc.frequency.value = freq / 2; // Octave down (Low mid)

        const filter = this.ctx.createBiquadFilter();
        filter.type = 'lowpass';

        const gain = this.ctx.createGain();

        // The "Swell" Envelope (Brass doesn't hit instantly, it grows)
        gain.gain.setValueAtTime(0, t);
        gain.gain.linearRampToValueAtTime(0.3, t + 1.0); // Slow attack
        gain.gain.linearRampToValueAtTime(0, t + 3.0);   // Slow release

        // The "Brighten" Envelope (As it gets louder, it gets brassier)
        filter.frequency.setValueAtTime(200, t);
        filter.frequency.linearRampToValueAtTime(1500, t + 1.0);

        osc.connect(filter); filter.connect(gain); gain.connect(this.master);
        osc.start(t); osc.stop(t + 3.5);
      }
    }
    //MODULE 8: THE PROMENADE (Noble/Heroic)
    class PromenadeModule {
      constructor(ctx, dest) {
        this.ctx = ctx;
        this.dest = dest;
        this.timer = null;

        // 1. MIXER
        this.master = ctx.createGain();
        this.master.gain.value = 0.5;

        // Large Reverb is essential for that "City Gate" feel
        this.revNode = ctx.createConvolver();
        this.setupReverb();
        this.revGain = ctx.createGain(); this.revGain.gain.value = 0.4;

        this.master.connect(this.dest);
        this.master.connect(this.revNode);
        this.revNode.connect(this.revGain);
        this.revGain.connect(this.dest);

        // 2. MUSICAL STATE
        this.tempo = 95; // A stately, walking tempo
        this.tickCount = 0;

        // C Mixolydian (Major scale w/ Flat 7) - The "Adventure" Scale
        // C, D, E, F, G, A, Bb
        this.scale = [0, 2, 4, 5, 7, 9, 10];
        this.rootFreq = 261.63; // Middle C

        // Melody Logic
        this.currentChordIndex = 0;
        this.chordProgression = [0, 5, 3, 4]; // I - bVII - IV - V
        this.melodyNote = null; // Track current note to slide from
      }

      setupReverb() {
        // 2.5 second tail
        const len = this.ctx.sampleRate * 2.5;
        const buf = this.ctx.createBuffer(2, len, this.ctx.sampleRate);
        for (let c = 0; c < 2; c++) {
          const d = buf.getChannelData(c);
          for (let i = 0; i < len; i++) d[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / len, 2);
        }
        this.revNode.buffer = buf;
      }

      start() {
        this.tickCount = 0;
        // 16th notes
        const interval = (60 / this.tempo) / 4 * 1000;
        this.timer = setInterval(() => this.tick(), interval);
      }

      stop() {
        if (this.timer) clearInterval(this.timer);
        this.master.gain.linearRampToValueAtTime(0, this.ctx.currentTime + 1);
      }

      // --- SEQUENCER ---
      tick() {
        const t = this.ctx.currentTime;
        const step = this.tickCount % 16;
        const bar = Math.floor(this.tickCount / 16) % 4;

        // 1. THE MARCHING SNARE (The backbone)
        // A standard march pattern: ONE-e-and-a TWO...
        const marchPattern = [1, 0.3, 0.5, 0.3, 1, 0, 0.5, 0, 1, 0.3, 0.5, 0.3, 1, 0, 1, 0];
        if (marchPattern[step] > 0) {
          this.playSnare(t, marchPattern[step]);
        }

        // 2. ORCHESTRAL CRASH (Transitions)
        // Hit a crash cymbal at the start of every 4-bar cycle
        if (bar === 0 && step === 0) {
          this.playCymbal(t);
        }

        // 3. THE STRING BED (Pad)
        // Change chords every Bar (16 ticks)
        if (step === 0) {
          this.currentChordIndex = bar; // Sync chord to bar
          this.playStringPad(t, bar);
        }

        // 4. THE HEROIC HORN (Melody)
        // This is the "Baldur's Gate" element.
        // It plays slow, long notes. We check every Quarter Note (step % 4 === 0)
        // But we only play if the 'dice roll' says so, to leave gaps.
        if (step % 4 === 0) {
          // High chance to play on beat 1 (step 0), lower on others
          const chance = step === 0 ? 0.9 : 0.6;

          if (Math.random() < chance) {
            // Determine duration: 1 beat, 2 beats, or 4 beats (Long!)
            const r = Math.random();
            let beats = 1;
            if (r > 0.6) beats = 2;
            if (r > 0.9 && step === 0) beats = 4; // Heroic long note

            this.playFrenchHorn(t, beats);
          }
        }

        this.tickCount++;
      }

      // --- INSTRUMENTS ---

      playSnare(t, velocity) {
        // Filtered noise for a warmer "Marching Snare"
        const bufSize = this.ctx.sampleRate * 0.1;
        const buffer = this.ctx.createBuffer(1, bufSize, this.ctx.sampleRate);
        const data = buffer.getChannelData(0);
        for (let i = 0; i < bufSize; i++) data[i] = Math.random() * 2 - 1;

        const noise = this.ctx.createBufferSource();
        noise.buffer = buffer;

        const filter = this.ctx.createBiquadFilter();
        filter.type = 'lowpass';
        filter.frequency.value = 2000; // Cut the harsh high end

        const gain = this.ctx.createGain();
        gain.gain.setValueAtTime(0.3 * velocity, t);
        gain.gain.exponentialRampToValueAtTime(0.01, t + 0.1);

        noise.connect(filter); filter.connect(gain); gain.connect(this.master);
        noise.start(t);
      }

      playStringPad(t, chordIdx) {
        // Play a triad (Root + 3rd + 5th)
        // C Mixolydian Chords
        const roots = [0, 10, 5, 7]; // I (C), bVII (Bb), IV (F), V (G)
        const rootNote = roots[chordIdx];

        // Build Chord (1, 3, 5)
        const chord = [rootNote, rootNote + 2, rootNote + 4];

        chord.forEach((note, i) => {
          const osc = this.ctx.createOscillator();
          const g = this.ctx.createGain();

          // Sawtooth + Lowpass = Strings
          osc.type = 'sawtooth';
          const freq = this.rootFreq * Math.pow(2, (this.scale[note % 7] + (note >= 7 ? 12 : 0)) / 12);
          osc.frequency.value = freq / 2; // Lower octave for body

          const filter = this.ctx.createBiquadFilter();
          filter.type = 'lowpass';
          filter.frequency.value = 400 + (i * 100); // Spread filters

          // ADSR: Slow Attack (The "Swell")
          g.gain.setValueAtTime(0, t);
          g.gain.linearRampToValueAtTime(0.1, t + 0.5); // 0.5s fade in
          g.gain.setValueAtTime(0.1, t + 2.0); // Sustain
          g.gain.linearRampToValueAtTime(0, t + 2.5); // Fade out

          osc.connect(filter); filter.connect(g); g.connect(this.master);
          osc.start(t); osc.stop(t + 2.6);
        });
      }

      playFrenchHorn(t, durationInBeats) {
        const beatSec = 60 / this.tempo;
        const duration = beatSec * durationInBeats;

        // 1. SELECT NOTE
        // Pick a note from the chord or a passing tone
        const chordRoot = [0, 10, 5, 7][this.currentChordIndex];
        // Prefer chord tones: Root, 3rd, 5th
        const tones = [chordRoot, chordRoot + 2, chordRoot + 4, chordRoot + 7];
        const noteIdx = tones[Math.floor(Math.random() * tones.length)];

        let freq = this.rootFreq * Math.pow(2, (this.scale[noteIdx % 7] + (noteIdx >= 7 ? 12 : 0)) / 12);

        // French Horn plays in the mid-range
        if (Math.random() > 0.5) freq /= 2;

        // 2. SYNTHESIS
        const osc = this.ctx.createOscillator();
        osc.type = 'sawtooth'; // Brass is Sawtooth
        osc.frequency.setValueAtTime(freq, t);

        // Slide from previous note (Legato)
        if (this.melodyNote) {
          osc.frequency.setValueAtTime(this.melodyNote, t);
          osc.frequency.exponentialRampToValueAtTime(freq, t + 0.1);
        }
        this.melodyNote = freq;

        // 3. THE "BRASSY" FILTER
        // Brass gets brighter as it gets louder
        const filter = this.ctx.createBiquadFilter();
        filter.type = 'lowpass';
        filter.Q.value = 2; // Resonance simulates the bell of the horn

        // Filter Envelope
        filter.frequency.setValueAtTime(300, t);
        filter.frequency.linearRampToValueAtTime(1200, t + (duration * 0.3)); // Swell brightness
        filter.frequency.linearRampToValueAtTime(300, t + duration); // Mellow out

        // 4. AMPLITUDE ENVELOPE
        const g = this.ctx.createGain();
        g.gain.setValueAtTime(0, t);
        g.gain.linearRampToValueAtTime(0.25, t + (duration * 0.2)); // Softer attack than trumpet
        g.gain.linearRampToValueAtTime(0.2, t + (duration * 0.8));
        g.gain.linearRampToValueAtTime(0, t + duration);

        osc.connect(filter); filter.connect(g); g.connect(this.master);
        osc.start(t); osc.stop(t + duration + 0.1);
      }

      playCymbal(t) {
        // Metallic noise
        const bufSize = this.ctx.sampleRate * 2;
        const buffer = this.ctx.createBuffer(1, bufSize, this.ctx.sampleRate);
        const data = buffer.getChannelData(0);
        for (let i = 0; i < bufSize; i++) data[i] = Math.random() * 2 - 1;

        const noise = this.ctx.createBufferSource();
        noise.buffer = buffer;

        const filter = this.ctx.createBiquadFilter();
        filter.type = 'highpass';
        filter.frequency.value = 3000;

        const g = this.ctx.createGain();
        g.gain.setValueAtTime(0.3, t);
        g.gain.exponentialRampToValueAtTime(0.001, t + 2);

        noise.connect(filter); filter.connect(g); g.connect(this.master);
        noise.start(t);
      }
    }
    //MODULE 9: 8-Bit Battle
    class BattleModule {
      constructor(ctx, dest) {
        this.ctx = ctx;
        this.dest = dest;
        this.timer = null;

        // 1. MASTER GAIN (Volume Control)
        this.master = ctx.createGain();
        this.master.gain.value = 0.4;
        this.master.connect(this.dest);

        // 2. STATE
        this.tempo = 160; // High speed battle
        this.tickCount = 0;
        this.state = 'INTRO'; // INTRO -> LOOP

        // Scale: G Harmonic Minor (The "Serious Battle" Scale)
        // G, A, Bb, C, D, Eb, F#
        this.baseFreq = 196.00; // G3
        this.scale = [0, 2, 3, 5, 7, 8, 11];

        // Game Boy "Noise" Buffer (Static for drums)
        this.noiseBuffer = this.createNoiseBuffer();
      }

      createNoiseBuffer() {
        const bufSize = this.ctx.sampleRate * 1;
        const buffer = this.ctx.createBuffer(1, bufSize, this.ctx.sampleRate);
        const data = buffer.getChannelData(0);
        for (let i = 0; i < bufSize; i++) {
          // Math.random() is too clean. We need digital static.
          // This threshold creates a "crackle" rather than "hiss"
          data[i] = Math.random() > 0.5 ? 1 : -1;
        }
        return buffer;
      }

      start() {
        this.tickCount = 0;
        this.state = 'INTRO';
        // 16th note interval
        const interval = (60 / this.tempo) / 4 * 1000;
        this.timer = setInterval(() => this.tick(), interval);
      }

      stop() {
        if (this.timer) clearInterval(this.timer);
        this.master.gain.setTargetAtTime(0, this.ctx.currentTime, 0.1);
      }

      // --- THE SEQUENCER ---
      tick() {
        const t = this.ctx.currentTime;

        if (this.state === 'INTRO') {
          this.playIntro(t);
        } else {
          this.playLoop(t);
        }

        this.tickCount++;
      }

      playIntro(t) {
        // The Classic "Encounter" Sound: Rapid ascending chromatic scale
        // Intro lasts 32 ticks (2 bars)
        const step = this.tickCount;

        // 1. The "Screech" (High pitch slide)
        if (step === 0) {
          this.playPulse(t, 880, 0.5, 0.1, 'lead'); // High A
          this.playNoise(t, 'open'); // Crash
        }

        // 2. The "Tension" (Rapid triplets)
        if (step < 28) {
          // Play chromatically rising notes every 2 ticks
          if (step % 2 === 0) {
            const freq = 220 + (step * 20);
            this.playPulse(t, freq, 0.05, 0.05, 'arp');
            this.playNoise(t, 'closed');
          }
        }
        // 3. The Drop (Silence before loop)
        else if (step === 30) {
          // Silence...
        }
        // 4. Switch to Loop
        else if (step === 32) {
          this.state = 'LOOP';
          this.tickCount = 0; // Reset for loop
        }
      }

      playLoop(t) {
        const step = this.tickCount % 16;
        const bar = Math.floor(this.tickCount / 16) % 8; // 8 bar phrases

        // CHANNEL 3: WAVE (Bass)
        // Driving eighth notes (0, 2, 4, 6...)
        if (step % 2 === 0) {
          this.playBass(t, bar);
        }

        // CHANNEL 4: NOISE (Percussion)
        // Basic Rock Beat: Kick (0, 8), Snare (4, 12), HiHat (every 2)
        if (step === 4 || step === 12) this.playNoise(t, 'snare');
        else if (step === 0 || step === 8) this.playNoise(t, 'kick');
        else if (step % 2 === 0) this.playNoise(t, 'closed');

        // CHANNEL 1: PULSE 1 (Lead Melody)
        // Complex logic to simulate "Pokemon" phrasing
        if (step % 2 === 0) { // Play mainly on 8th notes
          this.playMelody(t, step, bar);
        }

        // CHANNEL 2: PULSE 2 (Arpeggios/Support)
        // Fast 16th note runs
        this.playArp(t, step, bar);
      }

      // --- INSTRUMENTS ---

      playBass(t, bar) {
        // Chord Progression: i - VI - V - i (Gm - Eb - D - Gm)
        const progression = [0, 0, 5, 5, 4, 4, 0, 0]; // Root scale degrees
        const degree = progression[bar];
        const freq = this.baseFreq * Math.pow(2, (this.scale[degree] - 12) / 12); // Octave down

        const osc = this.ctx.createOscillator();
        osc.type = 'triangle'; // Game Boy "Wave" channel was often roughly triangular
        osc.frequency.setValueAtTime(freq, t);

        const g = this.ctx.createGain();
        g.gain.setValueAtTime(0.6, t);
        g.gain.linearRampToValueAtTime(0, t + 0.15); // Short, staccato bass

        osc.connect(g); g.connect(this.master);
        osc.start(t); osc.stop(t + 0.15);
      }

      playMelody(t, step, bar) {
        // "Lead" usually plays distinct phrases
        // Phrase A: Bars 0-3 (Intense)
        // Phrase B: Bars 4-7 (Resolve)

        // Pseudo-random but deterministic melody based on bar/step
        const seed = (bar * 16) + step;
        const isNote = (seed * 9301 + 49297) % 233280 > 100000; // 50% density

        if (isNote) {
          const progression = [0, 0, 5, 5, 4, 4, 0, 0];
          const root = progression[bar];

          // Pick a note from the scale (High octave)
          const scaleIndex = Math.floor(Math.random() * 5); // Bottom 5 notes of scale
          const note = root + this.scale[scaleIndex];
          const freq = this.baseFreq * Math.pow(2, (note + 12) / 12); // Up 1 octave

          this.playPulse(t, freq, 0.15, 0.2, 'lead');
        }
      }

      playArp(t, step, bar) {
        // "Arpeggios" are the secret sauce of 8-bit music.
        // They fill the silence and create urgency.

        const progression = [0, 0, 5, 5, 4, 4, 0, 0];
        const root = progression[bar];

        // Cycle: Root -> 3rd -> 5th -> Octave
        const arpPattern = [0, 2, 4, 7];
        const noteOffset = arpPattern[step % 4];

        // Map to scale
        const scaleDeg = (root + noteOffset) % 7; // Wrap scale
        // Check if index exists in scale, simplified logic:
        const freq = this.baseFreq * Math.pow(2, (this.scale[scaleDeg]) / 12);

        // Arps are quieter
        this.playPulse(t, freq, 0.05, 0.08, 'arp');
      }

      playPulse(t, freq, vol, dur, type) {
        const osc = this.ctx.createOscillator();
        osc.type = 'square';
        osc.frequency.setValueAtTime(freq, t);

        const g = this.ctx.createGain();
        g.gain.setValueAtTime(vol, t);

        // Envelope: Game Boy sound had no "attack", instant on, linear decay
        g.gain.setValueAtTime(vol, t);
        g.gain.linearRampToValueAtTime(0, t + dur);

        // "Duty Cycle" hack:
        // Web Audio square is 50%. Game Boy leads were often 12.5% or 25% (nasal).
        // We can mimic this with a Highpass filter to thin it out.
        if (type === 'lead') {
          const f = this.ctx.createBiquadFilter();
          f.type = 'highpass';
          f.frequency.value = 800; // Removes the "body", leaves the "buzz"
          osc.connect(f); f.connect(g);
        } else {
          osc.connect(g);
        }

        g.connect(this.master);
        osc.start(t); osc.stop(t + dur);
      }

      playNoise(t, type) {
        const src = this.ctx.createBufferSource();
        src.buffer = this.noiseBuffer;

        const filter = this.ctx.createBiquadFilter();
        const g = this.ctx.createGain();

        if (type === 'kick') {
          filter.type = 'lowpass';
          filter.frequency.value = 200; // Low rumble
          g.gain.setValueAtTime(0.8, t);
          g.gain.exponentialRampToValueAtTime(0.01, t + 0.1);
          src.playbackRate.value = 0.5; // Pitch down noise
        }
        else if (type === 'snare') {
          filter.type = 'bandpass'; // "Crunchy" mid-range
          filter.frequency.value = 1000;
          g.gain.setValueAtTime(0.6, t);
          g.gain.exponentialRampToValueAtTime(0.01, t + 0.15);
        }
        else { // Hi-hat / closed
          filter.type = 'highpass'; // Hissy
          filter.frequency.value = 3000;
          g.gain.setValueAtTime(0.3, t);
          g.gain.exponentialRampToValueAtTime(0.01, t + 0.05);
        }

        src.connect(filter); filter.connect(g); g.connect(this.master);
        src.start(t);
      }
    }
    // MODULE 10: ROMANCE (The Waltz System)
    class RomanceModule {
      constructor(ctx, dest) {
        this.ctx = ctx;
        this.dest = dest;
        this.timer = null;

        // 1. ADD REVERB (Essential for "Dreamy" sound)
        this.master = ctx.createGain();
        this.master.gain.value = 0.5;
        this.revNode = ctx.createConvolver();
        this.setupReverb();
        this.revGain = ctx.createGain();
        this.revGain.gain.value = 0.4; // Wet mix

        this.master.connect(this.dest);
        this.master.connect(this.revNode);
        this.revNode.connect(this.revGain);
        this.revGain.connect(this.dest);

        // --- State ---
        // Eb Major (A classic "Love" key, warm and mellow)
        this.keys = ['Eb'];
        this.keyFreqs = { 'Eb': 311.13 };
        this.currentKey = 'Eb';

        // Slow Waltz Tempos
        this.tempos = [60, 72, 84];
        this.currentTempo = 60;
        this.timeSignatures = [[3, 4]]; // Waltz only
        this.currentTimeSignature = [3, 4];

        // --- Runtime ---
        this.barCount = 1;
        this.beatsInBar = 0;
        this.eighthCount = 0;

        // Momentum (Used for intensity)
        this.momentum = { melody: 0, harmony: 0, bass: 0 };

        // Conflict Checking
        this.activeNotes = { melody: [], harmony: [], bass: [], metronome: [] };

        // Scale: Eb Major
        // 1=Eb, 2=F, 3=G, 4=Ab, 5=Bb, 6=C, 7=D
        this.scaleIntervals = { 1: 0, 2: 2, 3: 4, 4: 5, 5: 7, 6: 9, 7: 11, 8: 12 };

        this.bassOsc = null;
        this.bassGain = null;
      }

      setupReverb() {
        const len = this.ctx.sampleRate * 3.0; // 3 seconds tail
        const buf = this.ctx.createBuffer(2, len, this.ctx.sampleRate);
        for (let c = 0; c < 2; c++) {
          const d = buf.getChannelData(c);
          for (let i = 0; i < len; i++) d[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / len, 2);
        }
        this.revNode.buffer = buf;
      }

      start() {
        this.resetState();
        this.loop();
      }

      stop() {
    if (this.timer) clearTimeout(this.timer);
    if (this.bassOsc) {
        // Kill bass immediately
        this.bassGain.gain.cancelScheduledValues(this.ctx.currentTime);
        this.bassGain.gain.setValueAtTime(0, this.ctx.currentTime);
        this.bassOsc.stop(this.ctx.currentTime);
        this.bassOsc = null;
    }
    this.activeNotes = { melody: [], harmony: [], bass: [], metronome: [] };
    
    // Kill master
    this.master.gain.cancelScheduledValues(this.ctx.currentTime);
    this.master.gain.linearRampToValueAtTime(0, this.ctx.currentTime + 0.1);
    }

      resetState() {
        this.master.gain.setValueAtTime(0.5, this.ctx.currentTime);
        this.barCount = 1;
        this.beatsInBar = 0;
        this.eighthCount = 0;
        this.momentum = { melody: 0, harmony: 0, bass: 0 };
      }

      loop() {
        const beatsPerSec = this.currentTempo / 60;
        const eighthInterval = (1 / beatsPerSec) / 2 * 1000;

        // Rubato: Add slight random delay (0-30ms) to feel "human" and emotional
        const rubato = Math.random() * 30;
        this.timer = setTimeout(() => this.loop(), eighthInterval + rubato);

        // --- Logic ---
        if (this.eighthCount % 2 === 0) {
          // == Beat Start ==
          // Removed Metronome (Too mechanical for romance)

          this.processVoice('bass'); // Bass moves slowly

          this.beatsInBar++;
          if (this.beatsInBar >= this.currentTimeSignature[0]) {
            this.beatsInBar = 0;
            this.barCount++;

            // Modulate intensity occasionally
            if (this.barCount % 8 === 1 && this.barCount > 1) {
              this.momentum.melody = Math.min(5, this.momentum.melody + 2); // Swell
            }
          }
        }

        this.processVoice('melody');
        this.processVoice('harmony');
        this.eighthCount++;
      }

      // --- Voice Processing ---

      processVoice(type) {
        if (type === 'bass' && this.beatsInBar !== 1) return; // Bass only on downbeat (Waltz style: BOOM-cha-cha)

        // Lower probability for slower, more spacious music
        let prob = 0.4 + (this.momentum[type] * 0.05);
        if (type === 'harmony') prob = 0.3; // Sparse harmony

        if (Math.random() < prob) {
          const note = this.getValidNote(type);
          if (note !== null) {
            this.playNote(note, type);
            // In romance, momentum drops slowly (sustain the mood)
            this.momentum[type] = Math.max(-2, this.momentum[type] - 1);
          }
        } else {
          this.momentum[type] = Math.min(5, this.momentum[type] + 1);
        }
      }

      getValidNote(type) {
        let attempts = 0;
        while (attempts < 8) {
          // Bias towards lower/mid range notes for warmth
          const note = Math.floor(Math.random() * 7) + 1;
          if (!this.checkConflicts(note, type)) {
            return note;
          }
          attempts++;
        }
        return null;
      }

      checkConflicts(newNote, myType) {
        const now = Date.now();
        ['melody', 'harmony', 'bass'].forEach(t => {
          this.activeNotes[t] = this.activeNotes[t].filter(n => n.endTime > now);
        });

        let others = [];
        ['melody', 'harmony', 'bass'].forEach(t => {
          if (t !== myType) others = others.concat(this.activeNotes[t]);
        });

        for (let other of others) {
          const allowed = this.getConsonantNotes(other.note);
          if (!allowed.includes(newNote)) return true;
        }
        return false;
      }

      getConsonantNotes(note) {
        // SWEET INTERVALS MAP (Focus on 3rds and 6ths)
        // This avoids "hollow" sounds and creates "warm" chords
        const map = {
          1: [1, 3, 5, 6, 8], // Root pairs well with 3rd, 5th, 6th
          2: [2, 4, 5, 7],
          3: [1, 3, 5, 6],    // 3rd pairs with Root, 5th, 6th
          4: [2, 4, 6, 8],
          5: [1, 2, 3, 5],
          6: [1, 3, 4, 6],
          7: [2, 5, 7],
          8: [1, 4, 6, 8]
        };
        return map[note] || [];
      }

      // --- Audio Gen (The "Soft" Upgrade) ---

      playNote(degree, type) {
        const t = this.ctx.currentTime;
        const interval = this.scaleIntervals[degree];
        const base = this.keyFreqs[this.currentKey];

        let freq = base * Math.pow(2, interval / 12);

        // 1. BASS (Deep Sine Wave)
        if (type === 'bass') {
          if (this.bassOsc) {
            this.bassGain.gain.linearRampToValueAtTime(0, t + 0.5); // Long fade out
            this.bassOsc.stop(t + 0.5);
          }
          freq = freq / 2; // Octave down
          this.bassOsc = this.ctx.createOscillator();
          this.bassOsc.type = 'sine'; // Sine is deep and smooth
          this.bassOsc.frequency.value = freq;
          this.bassGain = this.ctx.createGain();

          // Envelope: Slow swell
          this.bassGain.gain.setValueAtTime(0, t);
          this.bassGain.gain.linearRampToValueAtTime(0.3, t + 1.0); // 1s attack

          this.bassOsc.connect(this.bassGain);
          this.bassGain.connect(this.master);
          this.bassOsc.start(t);

          this.activeNotes.bass.push({ note: degree, endTime: Date.now() + 3000 });
          return;
        }

        // 2. MELODY / HARMONY (Felt Piano / Strings)
        const osc = this.ctx.createOscillator();
        const gn = this.ctx.createGain();

        // Triangle = Flute-like / Soft Piano
        osc.type = 'triangle';
        osc.frequency.value = freq;

        // Filter to remove buzz (Muffle sound)
        const filter = this.ctx.createBiquadFilter();
        filter.type = 'lowpass';
        filter.frequency.value = type === 'melody' ? 800 : 400; // Darker harmony

        // Vibrato (Essential for emotion)
        if (type === 'melody') {
          const lfo = this.ctx.createOscillator();
          const lfoGain = this.ctx.createGain();
          lfo.frequency.value = 5; // 5Hz vibrato
          lfoGain.gain.value = 3;  // Slight pitch wobble
          lfo.connect(lfoGain);
          lfoGain.connect(osc.frequency);
          lfo.start(t);
        }

        const dur = (60 / this.currentTempo) * 1.5; // Sustain notes longer
        const vol = type === 'harmony' ? 0.1 : 0.2;

        // SOFT ENVELOPE
        gn.gain.setValueAtTime(0, t);
        // Attack: 0.2s (Not instant) - sounds like a bow or soft hammer
        gn.gain.linearRampToValueAtTime(vol, t + 0.2);
        // Decay: Long fade
        gn.gain.linearRampToValueAtTime(0, t + dur + 1.0);

        osc.connect(filter); filter.connect(gn); gn.connect(this.master);
        osc.start(t);
        osc.stop(t + dur + 1.5);

        this.activeNotes[type].push({ note: degree, endTime: Date.now() + (dur * 1000) });
      }
    }
    // MODULE 11: AUTO-LYRE (The "Real" Harpsichord)
    class BachModule {
      constructor(ctx, dest) {
        this.ctx = ctx;
        this.dest = dest;
        this.timer = null;

        // --- State ---
        this.keys = ['C', 'D', 'E', 'F', 'G', 'A', 'B'];
        this.keyFreqs = { 'C': 261.63, 'D': 293.66, 'E': 329.63, 'F': 349.23, 'G': 392.00, 'A': 440.00, 'B': 493.88 };
        this.currentKey = 'C';
        this.tempos = [60, 70, 80, 90];
        this.currentTempo = 60;
        this.timeSignatures = [[4, 4], [3, 4], [6, 8]];
        this.currentTimeSignature = [4, 4];

        // --- Runtime ---
        this.barCount = 1;
        this.beatsInBar = 0;
        this.eighthCount = 0;

        this.momentum = { melody: 0, harmony: 0, bass: 0 };
        this.activeNotes = { melody: [], harmony: [], bass: [], metronome: [] };
        this.scaleIntervals = { 1: 0, 2: 2, 3: 4, 4: 5, 5: 7, 6: 9, 7: 11, 8: 12 };

        this.bassNodes = null;
      }

      start() {
        this.resetState();
        this.loop();
      }

      stop() {
        if (this.timer) clearTimeout(this.timer);
        this.stopBass();
        this.activeNotes = { melody: [], harmony: [], bass: [], metronome: [] };
      }

      resetState() {
        this.barCount = 1;
        this.beatsInBar = 0;
        this.eighthCount = 0;
        this.momentum = { melody: 0, harmony: 0, bass: 0 };
      }

      loop() {
        const beatsPerSec = this.currentTempo / 60;
        const eighthInterval = (1 / beatsPerSec) / 2 * 1000;

        this.timer = setTimeout(() => this.loop(), eighthInterval);

        if (this.eighthCount % 2 === 0) {
          this.playMetronome();
          this.processVoice('bass');

          this.beatsInBar++;
          if (this.beatsInBar >= this.currentTimeSignature[0]) {
            this.beatsInBar = 0;
            this.barCount++;
            if (this.barCount % 12 === 1 && this.barCount > 1) {
              this.changeKeyAndRhythm();
            }
          }
        }

        this.processVoice('melody');
        this.processVoice('harmony');
        this.eighthCount++;
      }

      changeKeyAndRhythm() {
        this.currentKey = this.keys[Math.floor(Math.random() * this.keys.length)];
        this.currentTimeSignature = this.timeSignatures[Math.floor(Math.random() * this.timeSignatures.length)];
        this.currentTempo = this.tempos[Math.floor(Math.random() * this.tempos.length)];
        console.log(`Lyre: Modulating to ${this.currentKey} at ${this.currentTempo}bpm`);
      }

      processVoice(type) {
        if (type === 'bass' && this.eighthCount % 2 !== 0) return;

        const prob = 0.5 + (this.momentum[type] * 0.05);
        if (Math.random() < prob) {
          const note = this.getValidNote(type);
          if (note !== null) {
            this.playNote(note, type);
            this.momentum[type] = Math.max(-5, this.momentum[type] - 1);
          } else {
            this.momentum[type] = Math.min(5, this.momentum[type] + 1);
          }
        } else {
          this.momentum[type] = Math.min(5, this.momentum[type] + 1);
        }
      }

      getValidNote(type) {
        let attempts = 0;
        while (attempts < 8) {
          const note = Math.floor(Math.random() * 8) + 1;
          if (!this.checkConflicts(note, type)) {
            return note;
          }
          attempts++;
        }
        return null;
      }

      checkConflicts(newNote, myType) {
        const now = Date.now();
        ['melody', 'harmony', 'bass', 'metronome'].forEach(t => {
          this.activeNotes[t] = this.activeNotes[t].filter(n => n.endTime > now);
        });

        let others = [];
        ['melody', 'harmony', 'bass'].forEach(t => {
          if (t !== myType) others = others.concat(this.activeNotes[t]);
        });

        for (let other of others) {
          const allowed = this.getConsonantNotes(other.note);
          if (!allowed.includes(newNote)) return true;
        }
        return false;
      }

      getConsonantNotes(note) {
        const map = {
          1: [1, 3, 4, 5, 6], 2: [2, 4, 5, 6, 7], 3: [1, 3, 5, 6, 7],
          4: [1, 2, 4, 6, 7], 5: [1, 2, 3, 5, 7], 6: [1, 2, 3, 4, 6],
          7: [2, 3, 4, 5, 7], 8: [1, 3, 4, 5, 6]
        };
        return map[note] || [];
      }

      // --- SOUND ENGINE: THE REALISTIC HARPSICHORD ---

      playMetronome() {
        // Silent
      }

      stopBass() {
        if (this.bassNodes) {
          // Harpsichord dampers stop sound abruptly
          this.bassNodes.gain.gain.setTargetAtTime(0, this.ctx.currentTime, 0.02);
          this.bassNodes.osc1.stop(this.ctx.currentTime + 0.1);
          this.bassNodes.osc2.stop(this.ctx.currentTime + 0.1);
          this.bassNodes = null;
        }
      }

      playNote(degree, type) {
        const t = this.ctx.currentTime;
        const interval = this.scaleIntervals[degree];
        const base = this.keyFreqs[this.currentKey];
        let freq = base * Math.pow(2, interval / 12);

        let dur = (60 / this.currentTempo);
        let volume = 0.1;

        // VOICE CONFIGURATION
        if (type === 'bass') {
          this.stopBass();
          freq = freq / 2;
          volume = 0.15;
        }
        else if (type === 'harmony') {
          volume = 0.06;
        }

        // 1. The "Plectrum" (Mechanical Click)
        // This is a tiny burst of noise to simulate the quill hitting the string
        const noiseBuf = this.ctx.createBuffer(1, 1000, this.ctx.sampleRate);
        const noiseData = noiseBuf.getChannelData(0);
        for (let i = 0; i < 1000; i++) noiseData[i] = Math.random() * 2 - 1;

        const click = this.ctx.createBufferSource();
        click.buffer = noiseBuf;
        const clickGain = this.ctx.createGain();
        clickGain.gain.setValueAtTime(0.05, t);
        clickGain.gain.exponentialRampToValueAtTime(0.001, t + 0.01); // ultra short
        click.connect(clickGain); clickGain.connect(this.dest);
        click.start(t);


        // 2. The String (Oscillators)
        const osc1 = this.ctx.createOscillator();
        osc1.type = 'sawtooth';
        osc1.frequency.value = freq;
        // Random detune for realism (strings are never perfect)
        osc1.detune.value = (Math.random() * 4) - 2;

        const osc2 = this.ctx.createOscillator();
        osc2.type = 'sawtooth';
        osc2.frequency.value = freq * 2; // Octave up
        osc2.detune.value = (Math.random() * 6) - 3;

        // 3. The "Pluck" Filter
        // This is the secret sauce. The filter starts OPEN and snaps CLOSED.
        const filter = this.ctx.createBiquadFilter();
        filter.type = 'lowpass';
        filter.Q.value = 1; // Slight resonance for the "twang"

        // Filter Envelope
        filter.frequency.setValueAtTime(5000, t); // Start Bright
        // Snap down quickly to dull (mimics energy loss)
        filter.frequency.exponentialRampToValueAtTime(800, t + 0.2);

        // 4. The Amplitude Envelope (Poor Sustain)
        const gain = this.ctx.createGain();

        // Attack is instant
        gain.gain.setValueAtTime(0, t);
        gain.gain.linearRampToValueAtTime(volume, t + 0.005);

        // Decay is fast and exponential. Harpsichord notes die away quickly.
        // Even if the note duration (dur) is long, the volume drops off.
        gain.gain.exponentialRampToValueAtTime(volume * 0.01, t + 1.5);

        // Wiring
        const osc2Gain = this.ctx.createGain();
        osc2Gain.gain.value = 0.3; // Octave is quieter

        osc1.connect(filter);
        osc2.connect(osc2Gain); osc2Gain.connect(filter);

        filter.connect(gain);
        gain.connect(this.dest);

        osc1.start(t); osc1.stop(t + 2.0); // Stop slightly after decay
        osc2.start(t); osc2.stop(t + 2.0);

        if (type === 'bass') {
          this.bassNodes = { osc1, osc2, gain };
          this.activeNotes.bass.push({ note: degree, endTime: Date.now() + 2000 });
        } else {
          this.activeNotes[type].push({ note: degree, endTime: Date.now() + (dur * 1000) });
        }
      }
    }/////////////////////[MAIN GAME LOOP]//////////////////////////
    // MODULE 12: THE INVENTION ENGINE (Procedural Counterpoint)
    class Bach2Module {
      constructor(ctx, dest) {
        this.ctx = ctx;
        this.dest = dest;
        this.timer = null;

        // --- Musical State ---
        this.tempo = 90; // Standard Baroque Allegro
        this.keyBase = 261.63; // Middle C

        // C Major Scale (extended range for runs)
        // 0=C, 1=D, 2=E, 3=F, 4=G, 5=A, 6=B, 7=C...
        this.scale = [0, 2, 4, 5, 7, 9, 11];

        // --- The "Composer" State ---
        this.tickCount = 0;   // 16th note counter
        this.measureCount = 0;

        // Harmony: 0=I, 1=ii, 2=iii, 3=IV, 4=V, 5=vi, 6=vii
        this.currentChordRoot = 0;

        // The "Subject" (The Motif)
        // This is a shape: [0, 1, 2, 4] means "Root, Step Up, Step Up, Skip Up"
        this.subject = [0, 1, 2, 0]; // A simple "Turn" motif (C-D-E-C)

        // Who has the melody? 'right' or 'left'
        this.activeHand = 'right';

        // Panning Nodes (for stereo separation)
        this.panL = ctx.createStereoPanner();
        this.panL.pan.value = -0.3; // Bass slightly left
        this.panL.connect(dest);

        this.panR = ctx.createStereoPanner();
        this.panR.pan.value = 0.3; // Treble slightly right
        this.panR.connect(dest);
      }

      start() {
        this.tickCount = 0;
        this.measureCount = 0;
        this.loop();
      }

      stop() {
        if (this.timer) clearTimeout(this.timer);
      }

      loop() {
        const secondsPerBeat = 60 / this.tempo;
        const interval = (secondsPerBeat / 4) * 1000; // 16th notes

        this.timer = setTimeout(() => this.loop(), interval);

        // --- COMPOSITION LOGIC (The Brain) ---

        const beat = Math.floor(this.tickCount / 4);
        const step = this.tickCount % 16; // Step within the measure (0-15)

        // 1. New Measure Logic (Harmony & Role Swap)
        if (step === 0) {
          // Every 2 measures, swap hands (The "Switching Off")
          if (this.measureCount % 2 === 0) {
            this.activeHand = (this.activeHand === 'right') ? 'left' : 'right';
            // Mutate the subject slightly for variety
            if (Math.random() > 0.5) this.mutateSubject();
          }

          this.progressHarmony();
          this.measureCount++;
        }

        // 2. Play The Voices
        this.playVoice('right', this.tickCount);
        this.playVoice('left', this.tickCount);

        this.tickCount++;
      }

      mutateSubject() {
        // Change the melodic shape slightly
        const shapes = [
          [0, 1, 2, 0], // Turn
          [0, 2, 4, 7], // Arpeggio Up
          [7, 4, 2, 0], // Arpeggio Down
          [0, 1, 0, -1], // Neighbor tone
          [0, 2, 1, 3]  // Broken thirds
        ];
        this.subject = shapes[Math.floor(Math.random() * shapes.length)];
      }

      progressHarmony() {
        // Classic Cycle of Fifths / Tonal Logic
        const r = Math.random();
        // 0=I, 1=ii, 3=IV, 4=V, 5=vi
        if (this.currentChordRoot === 0) this.currentChordRoot = (r < 0.5) ? 3 : 4; // I -> IV or V
        else if (this.currentChordRoot === 3) this.currentChordRoot = (r < 0.5) ? 4 : 1; // IV -> V or ii
        else if (this.currentChordRoot === 4) this.currentChordRoot = (r < 0.7) ? 0 : 5; // V -> I (Resolve) or vi (Deceptive)
        else if (this.currentChordRoot === 5) this.currentChordRoot = 1; // vi -> ii
        else this.currentChordRoot = 4; // ii -> V
      }

      playVoice(hand, tick) {
        const stepInBar = tick % 16;
        const subBeat = tick % 4; // 0, 1, 2, 3 (16th notes inside a beat)

        let noteToPlay = null; // Null means rest
        let octave = (hand === 'right') ? 1 : -1; // Treble vs Bass range

        // --- COUNTERPOINT LOGIC ---

        // Scenario A: This hand is ACTIVE (Playing the Subject/Run)
        if (this.activeHand === hand) {
          // Play continuous 16th notes (The Motor)

          // Map the current "Subject" shape onto the current Harmony
          // We loop through the subject array (mod 4)
          const subjectNoteIndex = this.subject[subBeat];

          // Calculate scale degree relative to Chord Root
          // e.g., if Chord is V (G), and subject is 0 (Root), we play G.
          noteToPlay = this.currentChordRoot + subjectNoteIndex;
        }

        // Scenario B: This hand is PASSIVE (Accompaniment)
        else {
          // Play sparse notes (Quarters or Eighths) to let the other hand shine
          // This creates the "Switching Off" effect

          // Only play on the beat (0, 4, 8, 12) OR off-beat (8) for syncopation
          if (stepInBar === 0 || stepInBar === 8) {
            // Just play the Root or 3rd of the chord
            if (stepInBar === 0) noteToPlay = this.currentChordRoot; // Root on 1
            if (stepInBar === 8) noteToPlay = this.currentChordRoot + 2; // 3rd on 3
          }

          // MIRRORING TRICK:
          // Sometimes, mimic the active hand in slow motion (Canon style)
          // (If we wanted complex canon, we'd store history, but simple harmony works best for procedurals)
        }

        // --- EXECUTE NOTE ---
        if (noteToPlay !== null) {
          this.soundEngine(noteToPlay, octave, hand);
        }
      }

      soundEngine(scaleDegree, octaveShift, hand) {
        const t = this.ctx.currentTime;

        // 1. Quantize to Scale (C Major)
        // Handle negative scale degrees correctly
        let normDegree = scaleDegree;
        let octAdjust = 0;

        while (normDegree < 0) { normDegree += 7; octAdjust -= 1; }
        while (normDegree >= 7) { normDegree -= 7; octAdjust += 1; }

        const semitone = this.scale[normDegree];
        const totalOctave = octaveShift + octAdjust;

        const freq = this.keyBase * Math.pow(2, (semitone + (totalOctave * 12)) / 12);

        // 2. Harpsichord Physics (The "Plectrum Pluck")

        // Destination based on Hand (Pan Left or Right)
        const destNode = (hand === 'left') ? this.panL : this.panR;

        // Oscillators (Sawtooth for brightness)
        const osc = this.ctx.createOscillator();
        osc.type = 'sawtooth';
        osc.frequency.value = freq;

        // Random micro-detune for realism
        osc.detune.value = (Math.random() * 6) - 3;

        // Filter (The "Twang")
        // Key tracking: Higher notes are brighter
        const filter = this.ctx.createBiquadFilter();
        filter.type = 'lowpass';
        filter.Q.value = 1.5; // Resonant pluck
        const baseCutoff = (hand === 'right') ? 5000 : 3000;
        filter.frequency.setValueAtTime(baseCutoff, t);
        filter.frequency.exponentialRampToValueAtTime(600, t + 0.2); // Snap shut

        // Amplitude (No sustain)
        const gain = this.ctx.createGain();
        const vol = (hand === 'left') ? 0.12 : 0.1; // Bass slightly louder to carry rhythm

        gain.gain.setValueAtTime(0, t);
        gain.gain.linearRampToValueAtTime(vol, t + 0.005); // Instant attack
        gain.gain.exponentialRampToValueAtTime(0.001, t + 0.8); // Short decay

        // Mechanical Click (The Quill)
        this.playClick(t, destNode);

        // Connect
        osc.connect(filter);
        filter.connect(gain);
        gain.connect(destNode); // Connect to Panner, not Master directly

        osc.start(t);
        osc.stop(t + 1.0);
      }

      playClick(t, dest) {
        // Tiny burst of high-pass noise
        const buf = this.ctx.createBuffer(1, 400, this.ctx.sampleRate);
        const data = buf.getChannelData(0);
        for (let i = 0; i < 400; i++) data[i] = Math.random() * 0.5;

        const src = this.ctx.createBufferSource();
        src.buffer = buf;
        const g = this.ctx.createGain();
        g.gain.value = 0.05;

        src.connect(g); g.connect(dest);
        src.start(t);
      }
    }
    // MODULE 13: THE WELL-TEMPERED INVENTION (With Key Modulation)
    class Bach3Module {
      constructor(ctx, dest) {
        this.ctx = ctx;
        this.dest = dest;
        this.timer = null;

        // --- Musical State ---
        this.tempo = 96;

        // KEY DEFINITIONS (The full chromatic spectrum for maximum freshness)
        this.keyMap = {
          'C': 261.63, 'C#': 277.18, 'D': 293.66, 'Eb': 311.13,
          'E': 329.63, 'F': 349.23, 'F#': 369.99, 'G': 392.00,
          'Ab': 415.30, 'A': 440.00, 'Bb': 466.16, 'B': 493.88
        };
        this.availableKeys = Object.keys(this.keyMap);

        // Start in C
        this.currentKeyName = 'C';
        this.keyBase = this.keyMap['C'];

        // Major Scale Intervals (0=Root, 2=Major 2nd, etc.)
        this.scale = [0, 2, 4, 5, 7, 9, 11];

        // --- The "Composer" State ---
        this.tickCount = 0;
        this.measureCount = 0;

        // Harmony: 0=I, 1=ii, 2=iii, 3=IV, 4=V, 5=vi, 6=vii
        this.currentChordRoot = 0;

        this.subject = [0, 1, 2, 0]; // Default Motif
        this.activeHand = 'right';

        // Panning Nodes
        this.panL = ctx.createStereoPanner();
        this.panL.pan.value = -0.4;
        this.panL.connect(dest);

        this.panR = ctx.createStereoPanner();
        this.panR.pan.value = 0.4;
        this.panR.connect(dest);
      }

      start() {
        this.tickCount = 0;
        this.measureCount = 0;
        this.currentChordRoot = 0;
        this.loop();
      }

      stop() {
        if (this.timer) clearTimeout(this.timer);
      }

      loop() {
        const secondsPerBeat = 60 / this.tempo;
        const interval = (secondsPerBeat / 4) * 1000; // 16th notes

        this.timer = setTimeout(() => this.loop(), interval);

        // --- COMPOSITION LOGIC ---
        const step = this.tickCount % 16;

        // NEW MEASURE EVENT
        if (step === 0) {

          // 1. Role Swapping (Counterpoint)
          // Every 2 measures, swap hands
          if (this.measureCount % 2 === 0) {
            this.activeHand = (this.activeHand === 'right') ? 'left' : 'right';
            // Mutate the subject slightly for variety
            if (Math.random() > 0.6) this.mutateSubject();
          }

          // 2. MODULATION LOGIC (New Key)
          // Every 8 measures, change key to keep it fresh
          if (this.measureCount > 0 && this.measureCount % 8 === 0) {
            this.modulate();
          } else {
            // Otherwise, just progress chords normally
            this.progressHarmony();
          }

          this.measureCount++;
        }

        // PLAY VOICES
        this.playVoice('right', this.tickCount);
        this.playVoice('left', this.tickCount);

        this.tickCount++;
      }

      modulate() {
        // Pick a random new key that isn't the current one
        let newKey = this.currentKeyName;
        while (newKey === this.currentKeyName) {
          newKey = this.availableKeys[Math.floor(Math.random() * this.availableKeys.length)];
        }

        this.currentKeyName = newKey;
        this.keyBase = this.keyMap[newKey];

        // Reset Harmony to "I" (Root) so the new key establishes itself clearly
        this.currentChordRoot = 0;

        console.log(`Invention: Modulating to ${newKey} Major`);
      }

      mutateSubject() {
        const shapes = [
          [0, 1, 2, 0], // Turn
          [0, 2, 4, 7], // Arpeggio Up
          [7, 4, 2, 0], // Arpeggio Down
          [0, 1, 0, -1], // Neighbor tone
          [0, 2, 1, 3],  // Broken thirds
          [0, 0, 4, 4]   // Staccato jumps
        ];
        this.subject = shapes[Math.floor(Math.random() * shapes.length)];
      }

      progressHarmony() {
        // Classic Cycle of Fifths / Tonal Logic
        const r = Math.random();

        if (this.currentChordRoot === 0) this.currentChordRoot = (r < 0.5) ? 3 : 4; // I -> IV or V
        else if (this.currentChordRoot === 3) this.currentChordRoot = (r < 0.5) ? 4 : 1; // IV -> V or ii
        else if (this.currentChordRoot === 4) this.currentChordRoot = (r < 0.7) ? 0 : 5; // V -> I or vi
        else if (this.currentChordRoot === 5) this.currentChordRoot = 1; // vi -> ii
        else if (this.currentChordRoot === 1) this.currentChordRoot = 4; // ii -> V
        else this.currentChordRoot = 4; // Default to Dominant
      }

      playVoice(hand, tick) {
        const stepInBar = tick % 16;
        const subBeat = tick % 4;

        let noteToPlay = null;
        let octave = (hand === 'right') ? 1 : -1;

        // --- COUNTERPOINT LOGIC ---

        // ACTIVE HAND (Plays the Subject/Run)
        if (this.activeHand === hand) {
          // Apply Subject Shape to Current Chord
          const subjectNoteIndex = this.subject[subBeat];
          noteToPlay = this.currentChordRoot + subjectNoteIndex;
        }

        // PASSIVE HAND (Accompaniment)
        else {
          // Play sparse support notes
          if (stepInBar === 0) noteToPlay = this.currentChordRoot; // Root on 1
          if (stepInBar === 8) noteToPlay = this.currentChordRoot + 2; // 3rd on 3

          // Occasional 16th note run at the end of a bar (Cadential fill)
          if (stepInBar >= 14) {
            noteToPlay = this.currentChordRoot + (stepInBar % 2);
          }
        }

        if (noteToPlay !== null) {
          this.soundEngine(noteToPlay, octave, hand);
        }
      }

      soundEngine(scaleDegree, octaveShift, hand) {
        const t = this.ctx.currentTime;

        // 1. Quantize to Scale
        let normDegree = scaleDegree;
        let octAdjust = 0;

        // Handle wrapping for notes outside 0-6 range
        while (normDegree < 0) { normDegree += 7; octAdjust -= 1; }
        while (normDegree >= 7) { normDegree -= 7; octAdjust += 1; }

        const semitone = this.scale[normDegree];
        const totalOctave = octaveShift + octAdjust;

        const freq = this.keyBase * Math.pow(2, (semitone + (totalOctave * 12)) / 12);

        // 2. Harpsichord Physics
        const destNode = (hand === 'left') ? this.panL : this.panR;

        const osc = this.ctx.createOscillator();
        osc.type = 'sawtooth';
        osc.frequency.value = freq;
        osc.detune.value = (Math.random() * 5) - 2.5;

        // Filter (The "Twang")
        const filter = this.ctx.createBiquadFilter();
        filter.type = 'lowpass';
        filter.Q.value = 1.0;
        const baseCutoff = (hand === 'right') ? 5000 : 2500; // Bass is darker
        filter.frequency.setValueAtTime(baseCutoff, t);
        filter.frequency.exponentialRampToValueAtTime(500, t + 0.25);

        // Amplitude (Short sustain)
        const gain = this.ctx.createGain();
        const vol = (hand === 'left') ? 0.12 : 0.1;

        gain.gain.setValueAtTime(0, t);
        gain.gain.linearRampToValueAtTime(vol, t + 0.005);
        gain.gain.exponentialRampToValueAtTime(0.001, t + 0.6);

        // Mechanical Click
        this.playClick(t, destNode);

        // Connect
        osc.connect(filter);
        filter.connect(gain);
        gain.connect(destNode);

        osc.start(t);
        osc.stop(t + 0.7);
      }

      playClick(t, dest) {
        const buf = this.ctx.createBuffer(1, 400, this.ctx.sampleRate);
        const data = buf.getChannelData(0);
        for (let i = 0; i < 400; i++) data[i] = Math.random() * 0.3;

        const src = this.ctx.createBufferSource();
        src.buffer = buf;
        const g = this.ctx.createGain();
        g.gain.value = 0.05;

        src.connect(g); g.connect(dest);
        src.start(t);
      }
    }
    // MODULE 14: THE TOCCATA ENGINE (Heroic Bariolage)
    class Bach4Module {
      constructor(ctx, dest) {
        this.ctx = ctx;
        this.dest = dest;
        this.timer = null;

        // --- Battle Settings ---
        this.tempo = 130; // Fast!
        this.keyBase = 293.66; // D (D Minor is the classic "Epic" key)
        this.currentKeyName = 'D';

        // Harmonic Minor (The "Dramatic" Scale)
        // 0, 2, 3, 5, 7, 8, 11 (The 11 is the major 7th, creating tension)
        this.scale = [0, 2, 3, 5, 7, 8, 11];

        // --- State ---
        this.tickCount = 0;
        this.measureCount = 0;

        // Modes: 'bariolage' (alternating), 'run' (scale runs), 'chords' (heavy hits)
        this.currentMode = 'bariolage';

        // Harmony State
        this.currentRoot = 0; // Start on Tonic (i)

        // Bariolage State (The "Static" note we bounce off of)
        this.staticNoteOffset = 12; // Octave up

        // Panning
        this.panL = ctx.createStereoPanner(); this.panL.pan.value = -0.3; this.panL.connect(dest);
        this.panR = ctx.createStereoPanner(); this.panR.pan.value = 0.3; this.panR.connect(dest);
      }

      start() {
        this.tickCount = 0;
        this.measureCount = 0;
        this.loop();
      }

      stop() {
        if (this.timer) clearTimeout(this.timer);
      }

      loop() {
        const secondsPerBeat = 60 / this.tempo;
        const interval = (secondsPerBeat / 4) * 1000; // 16th notes

        this.timer = setTimeout(() => this.loop(), interval);

        const step = this.tickCount % 16;

        // --- TACTICAL DECISIONS (Every Bar) ---
        if (step === 0) {
          // 1. Change Harmony
          this.progressHarmony();

          // 2. Change Battle Tactic (Mode)
          const roll = Math.random();
          if (roll < 0.5) this.currentMode = 'bariolage';
          else if (roll < 0.8) this.currentMode = 'run';
          else this.currentMode = 'pedal_point'; // Epic sustained bass

          // Reset Bariolage Anchor (The static note)
          // Usually the 5th (Dominant) or the Octave of the current chord
          this.staticNoteOffset = (Math.random() > 0.5) ? 7 : 12;
        }

        // --- PLAY THE NOTES ---
        this.playToccata(step);

        this.tickCount++;
      }

      progressHarmony() {
        // Dramatic Minor Key Progression
        // 0=i, 3=iv, 4=V (Major), 5=VI (Epic Chord), 6=vii dim
        const r = Math.random();

        if (this.currentRoot === 0) { // From i
          this.currentRoot = (r < 0.5) ? 4 : 5; // Go to V (Tension) or VI (Epic)
        }
        else if (this.currentRoot === 4) { // From V
          this.currentRoot = (r < 0.8) ? 0 : 5; // Resolve to i or Deceptive to VI
        }
        else if (this.currentRoot === 5) { // From VI
          this.currentRoot = (r < 0.5) ? 3 : 4; // Go iv or V
        }
        else {
          this.currentRoot = 4; // Push to V
        }
      }

      playToccata(step) {
        // Logic for the different "Battle Modes"

        if (this.currentMode === 'bariolage') {
          // MODE A: BARIOLAGE (The "Alternating Thing")
          // Even steps: Play the MOVING note (changing melody)
          // Odd steps: Play the STATIC note (The pedal tone)

          if (step % 2 !== 0) {
            // The Static Anchor (High Pedal)
            // Plays on right hand
            this.soundEngine(this.currentRoot + this.staticNoteOffset, 1, 'right');
          } else {
            // The Moving Line (Melody)
            // Walks up or down scale degrees around the root
            const melodyNote = this.currentRoot + (step % 4);
            this.soundEngine(melodyNote, 0, 'left'); // Left hand plays moving line
          }
        }

        else if (this.currentMode === 'run') {
          // MODE B: UNISON RUN (The "Chase")
          // Both hands play a fast scale run in unison

          // Create a run pattern: 0, 1, 2, 3, 2, 1, 0, -1...
          const runOffset = (step < 8) ? step : (14 - step);
          const note = this.currentRoot + runOffset;

          // Play BOTH hands (Octave apart)
          this.soundEngine(note, 0, 'right');
          this.soundEngine(note, -1, 'left');
        }

        else if (this.currentMode === 'pedal_point') {
          // MODE C: PEDAL POINT (The "Heroic Stand")
          // Left hand holds a LOW thunderous note
          // Right hand does arpeggios above it

          // Bass: Only play on beat 1
          if (step === 0) {
            this.soundEngine(this.currentRoot, -2, 'left', 2.0); // Long sustain
          }

          // Treble: Continuous Arpeggio
          // Pattern: Root, 3rd, 5th, Octave
          const arp = [0, 2, 4, 7];
          const arpNote = this.currentRoot + arp[step % 4];
          this.soundEngine(arpNote, 1, 'right');
        }
      }

      soundEngine(scaleDegree, octaveShift, hand, forcedDuration = null) {
        const t = this.ctx.currentTime;

        // 1. Quantize to Harmonic Minor
        let normDegree = scaleDegree;
        let octAdjust = 0;

        while (normDegree < 0) { normDegree += 7; octAdjust -= 1; }
        while (normDegree >= 7) { normDegree -= 7; octAdjust += 1; }

        const semitone = this.scale[normDegree];
        const totalOctave = octaveShift + octAdjust;

        const freq = this.keyBase * Math.pow(2, (semitone + (totalOctave * 12)) / 12);

        // 2. Harpsichord Physics
        const destNode = (hand === 'left') ? this.panL : this.panR;

        const osc = this.ctx.createOscillator();
        osc.type = 'sawtooth';
        osc.frequency.value = freq;
        // Detune: Battle music needs grit. More detune!
        osc.detune.value = (Math.random() * 8) - 4;

        // Filter: Brighter/Harsher for battle
        const filter = this.ctx.createBiquadFilter();
        filter.type = 'lowpass';
        filter.Q.value = 2.0; // Sharp resonance

        // If left hand bass, make it growl
        const cutoffStart = (hand === 'left' && octaveShift < 0) ? 3000 : 6000;

        filter.frequency.setValueAtTime(cutoffStart, t);
        filter.frequency.exponentialRampToValueAtTime(400, t + 0.3); // Fast pluck

        // Amplitude
        const gain = this.ctx.createGain();
        const duration = forcedDuration || 0.6;

        // Louder volume for intensity
        const vol = (hand === 'left') ? 0.15 : 0.12;

        gain.gain.setValueAtTime(0, t);
        gain.gain.linearRampToValueAtTime(vol, t + 0.005);
        gain.gain.exponentialRampToValueAtTime(0.001, t + duration);

        // Mechanical Click (The Quill) - Louder/Sharper
        this.playClick(t, destNode);

        osc.connect(filter);
        filter.connect(gain);
        gain.connect(destNode);

        osc.start(t);
        osc.stop(t + duration + 0.1);
      }

      playClick(t, dest) {
        const buf = this.ctx.createBuffer(1, 400, this.ctx.sampleRate);
        const data = buf.getChannelData(0);
        for (let i = 0; i < 400; i++) data[i] = (Math.random() * 2 - 1) * 0.1; // Harder click

        const src = this.ctx.createBufferSource();
        src.buffer = buf;
        const g = this.ctx.createGain();
        g.gain.value = 0.1;

        src.connect(g); g.connect(dest);
        src.start(t);
      }
    }
    // MODULE 15: THE BATTLE ORCHESTRA (Epic Toccata)
    class Bach5Module {
      constructor(ctx, dest) {
        this.ctx = ctx;
        this.dest = dest;
        this.timer = null;

        // --- Battle Settings ---
        this.tempo = 130;
        this.keyBase = 293.66; // D (D Minor)
        this.scale = [0, 2, 3, 5, 7, 8, 11]; // Harmonic Minor

        // --- State ---
        this.tickCount = 0;
        this.measureCount = 0;
        this.currentMode = 'bariolage';
        this.currentRoot = 0;
        this.staticNoteOffset = 12;

        // --- GLOBAL MIXING (The Concert Hall) ---
        // We need a master compressor because the orchestra gets LOUD
        this.masterBus = ctx.createDynamicsCompressor();
        this.masterBus.threshold.value = -10;
        this.masterBus.knee.value = 40;
        this.masterBus.ratio.value = 12;
        this.masterBus.connect(dest);
      }

      start() {
        this.tickCount = 0;
        this.measureCount = 0;
        this.loop();
      }

      stop() {
        if (this.timer) clearTimeout(this.timer);
      }

      loop() {
        const secondsPerBeat = 60 / this.tempo;
        const interval = (secondsPerBeat / 4) * 1000;

        this.timer = setTimeout(() => this.loop(), interval);

        const step = this.tickCount % 16;

        // --- TACTICAL DECISIONS ---
        if (step === 0) {
          this.progressHarmony();

          // Randomly switch orchestral techniques
          const roll = Math.random();
          if (roll < 0.4) this.currentMode = 'bariolage'; // Rapid fire strings
          else if (roll < 0.7) this.currentMode = 'run'; // Unison sweeps
          else this.currentMode = 'pedal_point'; // Massive sustain

          this.staticNoteOffset = (Math.random() > 0.5) ? 7 : 12;

          // TIMPANI HIT on the '1' of every bar for impact
          this.playTimpani();
        }

        this.playToccata(step);
        this.tickCount++;
      }

      progressHarmony() {
        const r = Math.random();
        // Epic progressions
        if (this.currentRoot === 0) this.currentRoot = (r < 0.5) ? 4 : 5;
        else if (this.currentRoot === 4) this.currentRoot = (r < 0.8) ? 0 : 5;
        else if (this.currentRoot === 5) this.currentRoot = (r < 0.5) ? 3 : 4;
        else this.currentRoot = 4;
      }

      playToccata(step) {
        // --- ORCHESTRATION LOGIC ---

        if (this.currentMode === 'bariolage') {
          // Rapid Strings
          if (step % 2 !== 0) {
            // High static note: Violins
            this.playSection(this.currentRoot + this.staticNoteOffset, 1, 'strings');
          } else {
            // Moving line: Cellos/Violas
            const melodyNote = this.currentRoot + (step % 4);
            this.playSection(melodyNote, 0, 'strings');
          }
        }

        else if (this.currentMode === 'run') {
          // Unison Sweep: Full Tutti
          const runOffset = (step < 8) ? step : (14 - step);
          const note = this.currentRoot + runOffset;

          this.playSection(note, 1, 'strings'); // Violins
          this.playSection(note, -1, 'brass');  // Trombones/Horns reinforcement
        }

        else if (this.currentMode === 'pedal_point') {
          // Heroic Stand
          if (step === 0) {
            // Massive Low Brass/Bass sustain
            this.playSection(this.currentRoot, -2, 'brass_low');
          }
          // Violins arpeggiating over the top
          const arp = [0, 2, 4, 7];
          const arpNote = this.currentRoot + arp[step % 4];
          this.playSection(arpNote, 1, 'strings');
        }
      }

      // --- SOUND ENGINE: THE ORCHESTRA ---

      playSection(scaleDegree, octaveShift, section) {
        const t = this.ctx.currentTime;

        // 1. Calculate Frequency
        let normDegree = scaleDegree;
        let octAdjust = 0;
        while (normDegree < 0) { normDegree += 7; octAdjust -= 1; }
        while (normDegree >= 7) { normDegree -= 7; octAdjust += 1; }

        const semitone = this.scale[normDegree];
        const totalOctave = octaveShift + octAdjust;
        const freq = this.keyBase * Math.pow(2, (semitone + (totalOctave * 12)) / 12);

        // 2. Instrument Design

        if (section === 'strings') {
          // VIOLIN/CELLO SECTION (Spiccato)
          // Needs to be biting but have body
          this.createSynth(t, freq, 'sawtooth', {
            attack: 0.02, decay: 0.3, sustain: 0.1, release: 0.4, // Short bow strokes
            filter: 2000, Q: 1,
            detune: 5, // Ensemble effect
            vol: 0.15
          });
        }
        else if (section === 'brass') {
          // FRENCH HORNS / TROMBONES
          // Brassy swell
          this.createSynth(t, freq, 'sawtooth', {
            attack: 0.05, decay: 0.2, sustain: 0.4, release: 0.6,
            filter: 1500, Q: 2, // Resonant "Blare"
            detune: 8, // Wide section
            vol: 0.12
          });
        }
        else if (section === 'brass_low') {
          // TUBA / CONTRABASS
          // Deep growl
          this.createSynth(t, freq, 'sawtooth', {
            attack: 0.4, decay: 0.5, sustain: 0.8, release: 1.5, // Slow massive swell
            filter: 400, Q: 0,
            detune: 4,
            vol: 0.3
          });
        }
      }

      createSynth(t, freq, type, p) {
        // Creates a dual-oscillator voice (The "Section")
        const osc1 = this.ctx.createOscillator();
        const osc2 = this.ctx.createOscillator();

        osc1.type = type; osc2.type = type;
        osc1.frequency.value = freq; osc2.frequency.value = freq;

        // Ensemble Detuning
        osc1.detune.value = -p.detune;
        osc2.detune.value = p.detune;

        const filter = this.ctx.createBiquadFilter();
        filter.type = 'lowpass';
        filter.Q.value = p.Q;

        // Dynamic Filtering: Brass gets brighter as it gets louder
        filter.frequency.setValueAtTime(p.filter, t);
        if (p.attack > 0.1) {
          // Swell filter for long notes
          filter.frequency.linearRampToValueAtTime(p.filter * 2, t + p.attack);
        } else {
          // Snap filter for short notes
          filter.frequency.exponentialRampToValueAtTime(p.filter * 0.5, t + p.decay);
        }

        const gain = this.ctx.createGain();
        gain.gain.setValueAtTime(0, t);
        gain.gain.linearRampToValueAtTime(p.vol, t + p.attack);
        gain.gain.setTargetAtTime(p.sustain * p.vol, t + p.attack, p.decay);
        gain.gain.setTargetAtTime(0, t + p.attack + 0.2, p.release); // Release tail

        osc1.connect(filter); osc2.connect(filter);
        filter.connect(gain);
        gain.connect(this.masterBus);

        osc1.start(t); osc1.stop(t + 2.0);
        osc2.start(t); osc2.stop(t + 2.0);
      }

      playTimpani() {
        const t = this.ctx.currentTime;
        // Timpani is basically a low sine wave with a pitch drop
        const osc = this.ctx.createOscillator();
        osc.type = 'sine';
        osc.frequency.setValueAtTime(120, t);
        osc.frequency.exponentialRampToValueAtTime(40, t + 0.2); // The "Boom" pitch drop

        const gain = this.ctx.createGain();
        gain.gain.setValueAtTime(0.6, t); // Loud impact
        gain.gain.exponentialRampToValueAtTime(0.01, t + 0.5);

        // Add some noise for the "mallet hit" texture
        const noise = this.ctx.createBufferSource();
        const buf = this.ctx.createBuffer(1, 1000, this.ctx.sampleRate);
        const data = buf.getChannelData(0);
        for (let i = 0; i < 1000; i++) data[i] = Math.random() * 2 - 1;
        noise.buffer = buf;
        const noiseGain = this.ctx.createGain();
        noiseGain.gain.value = 0.2;

        osc.connect(gain);
        noise.connect(noiseGain); noiseGain.connect(gain);

        gain.connect(this.masterBus);
        osc.start(t); osc.stop(t + 0.5);
        noise.start(t);
      }
    }
    // MODULE 16: THE INFINITE BOSS (Procedural JRPG Battle)
    class InfiniteBattleModule {
      constructor(ctx, dest) {
        this.ctx = ctx;
        this.dest = dest;
        this.timer = null;

        // --- BATTLE SETTINGS ---
        this.tempo = 160;

        // KEY POOL (Dark/Epic Keys)
        this.keys = {
          'D': 293.66, 'Eb': 311.13, 'E': 329.63,
          'F': 349.23, 'G': 392.00, 'A': 440.00, 'Bb': 466.16
        };
        this.currentKey = 'D';
        this.keyBase = this.keys['D'];

        // MODE POOL (Musical Flavors)
        this.modes = {
          'Harmonic Minor': [0, 2, 3, 5, 7, 8, 11], // The "Dracula" sound
          'Phrygian': [0, 1, 3, 5, 7, 8, 10],       // The "Dark Tension" sound
          'Natural Minor': [0, 2, 3, 5, 7, 8, 10]   // The "Sad/Tragic" sound
        };
        this.currentScaleName = 'Harmonic Minor';
        this.scale = this.modes['Harmonic Minor'];

        // --- STATE ---
        this.tickCount = 0;
        this.barCount = 0;

        // Improviser State
        this.lastMelodyNote = 0; // Tracks where the melody "is" so it can walk
        this.bassPattern = 'gallop'; // 'gallop', 'walk', 'octaves'

        // Global Mix
        this.masterBus = ctx.createDynamicsCompressor();
        this.masterBus.threshold.value = -12;
        this.masterBus.ratio.value = 12;
        this.masterBus.connect(dest);
      }

      start() {
        this.tickCount = 0;
        this.barCount = 0;
        this.loop();
      }

      stop() {
        if (this.timer) clearTimeout(this.timer);
      }

      loop() {
        const secondsPerBeat = 60 / this.tempo;
        const interval = (secondsPerBeat / 4) * 1000; // 16th notes

        this.timer = setTimeout(() => this.loop(), interval);

        const step = this.tickCount % 16;

        // --- 1. THE "DIRECTOR" (Macro Changes) ---
        if (step === 0) {
          this.barCount++;

          // Every 8 bars: PHASE SHIFT (Key Change)
          if (this.barCount % 8 === 0) {
            this.modulateKey();
          }

          // Every 4 bars: CHANGE TACTICS (Bass/Scale)
          if (this.barCount % 4 === 0) {
            this.changeBassPattern();
            // Randomly swap scales (e.g. Minor to Phrygian)
            const modeNames = Object.keys(this.modes);
            this.currentScaleName = modeNames[Math.floor(Math.random() * modeNames.length)];
            this.scale = this.modes[this.currentScaleName];
          }
        }

        // --- 2. THE "DRUMMER" (Fills & Beats) ---
        const isFillBar = (this.barCount % 4 === 3); // 4th bar is a fill
        if (isFillBar && step > 8) {
          // Play Drum Fill (Snare rolls)
          if (step % 2 === 0) this.playDrum('snare');
          if (step === 15) this.playDrum('crash');
        } else {
          // Standard Beat
          this.playDrumSequencer(step);
        }

        // --- 3. THE "BASSIST" (Variations) ---
        this.playBassline(step);

        // --- 4. THE "LEAD" (Procedural Walker) ---
        this.playImprovisedSolo(step);

        this.tickCount++;
      }

      // --- DIRECTOR LOGIC ---
      modulateKey() {
        const keyNames = Object.keys(this.keys);
        // Pick a new key that isn't the current one
        let newKey = this.currentKey;
        while (newKey === this.currentKey) {
          newKey = keyNames[Math.floor(Math.random() * keyNames.length)];
        }
        this.currentKey = newKey;
        this.keyBase = this.keys[newKey];
        // Reset melody to root so it doesn't sound jarring
        this.lastMelodyNote = 0;
      }

      changeBassPattern() {
        const patterns = ['gallop', 'walk', 'octaves'];
        this.bassPattern = patterns[Math.floor(Math.random() * patterns.length)];
      }

      // --- IMPROVISER LOGIC ---
      playImprovisedSolo(step) {
        // We use a "Random Walker" algorithm.
        // Instead of picking a random note, we step Up or Down from the previous note.

        // RHYTHM VARIATION:
        // Sometimes play 16th notes (fast), sometimes 8ths (slow)
        const density = Math.random();
        if (density > 0.7 && step % 2 !== 0) return; // Skip some 16ths for gaps

        // 1. Decide Direction
        // 40% Step Up, 40% Step Down, 20% Big Jump
        const r = Math.random();
        let move = 0;
        if (r < 0.4) move = 1;
        else if (r < 0.8) move = -1;
        else move = (Math.random() > 0.5) ? 3 : -3; // Jump a 4th/5th

        this.lastMelodyNote += move;

        // 2. Constraints (Don't go too high/low)
        if (this.lastMelodyNote > 14) this.lastMelodyNote -= 2;
        if (this.lastMelodyNote < -7) this.lastMelodyNote += 2;

        // 3. Play Note
        // Play in High Octave (+1)
        this.playNote(this.lastMelodyNote, 1, 'lead');
      }

      playBassline(step) {
        let note = 0; // Root by default

        if (this.bassPattern === 'gallop') {
          // Dun-dun-dun-dun (Classic)
          if (step % 2 === 0) this.playNote(0, -2, 'bass');
        }
        else if (this.bassPattern === 'octaves') {
          // Low-High-Low-High
          if (step % 2 === 0) {
            const oct = (step % 4 === 0) ? -2 : -1;
            this.playNote(0, oct, 'bass');
          }
        }
        else if (this.bassPattern === 'walk') {
          // Moves around the scale: Root -> Flat 2 -> Flat 6 -> 5th
          if (step === 0) note = 0;
          else if (step === 4) note = 1; // Tension note
          else if (step === 8) note = 5; // The 6th
          else if (step === 12) note = 4; // The 5th

          if (step % 4 === 0) this.playNote(note, -2, 'bass');
        }
      }

      // --- SOUND ENGINE ---
      playNote(scaleDegree, octaveShift, type) {
        const t = this.ctx.currentTime;

        // Quantize
        let normDegree = scaleDegree;
        let octAdjust = 0;
        while (normDegree < 0) { normDegree += 7; octAdjust -= 1; }
        while (normDegree >= 7) { normDegree -= 7; octAdjust += 1; }

        const semitone = this.scale[normDegree];
        const freq = this.keyBase * Math.pow(2, (semitone + ((octaveShift + octAdjust) * 12)) / 12);

        if (type === 'lead') {
          // BOSS LEAD: Square Wave with Slide
          const osc = this.ctx.createOscillator();
          osc.type = 'square';
          osc.frequency.setValueAtTime(freq, t);

          // "Legato" Slide effect randomly
          if (Math.random() > 0.7) {
            osc.frequency.setValueAtTime(freq * 0.9, t);
            osc.frequency.linearRampToValueAtTime(freq, t + 0.05);
          }

          const filter = this.ctx.createBiquadFilter();
          filter.type = 'lowpass';
          filter.frequency.value = 3000;
          filter.Q.value = 2; // Resonant beep

          const gain = this.ctx.createGain();
          gain.gain.setValueAtTime(0.1, t);
          gain.gain.exponentialRampToValueAtTime(0.01, t + 0.2);

          osc.connect(filter); filter.connect(gain); gain.connect(this.masterBus);
          osc.start(t); osc.stop(t + 0.2);
        }
        else if (type === 'bass') {
          // DRIVING BASS: Sawtooth
          const osc = this.ctx.createOscillator();
          osc.type = 'sawtooth';
          osc.frequency.value = freq;

          const filter = this.ctx.createBiquadFilter();
          filter.type = 'lowpass';
          filter.frequency.setValueAtTime(800, t);
          filter.frequency.exponentialRampToValueAtTime(100, t + 0.2); // Pluck envelope

          const gain = this.ctx.createGain();
          gain.gain.setValueAtTime(0.3, t);
          gain.gain.exponentialRampToValueAtTime(0.01, t + 0.2);

          osc.connect(filter); filter.connect(gain); gain.connect(this.masterBus);
          osc.start(t); osc.stop(t + 0.2);
        }
      }

      playDrumSequencer(step) {
        if (step % 2 === 0) this.playDrum('hihat');
        if (step === 4 || step === 12) this.playDrum('snare');
        if (step === 0 || step === 10) this.playDrum('kick');
        // Occasional double kick
        if (step === 2 && Math.random() > 0.5) this.playDrum('kick');
      }

      playDrum(type) {
        const t = this.ctx.currentTime;
        const gn = this.ctx.createGain();
        gn.connect(this.masterBus);

        if (type === 'kick') {
          const osc = this.ctx.createOscillator();
          osc.frequency.setValueAtTime(150, t);
          osc.frequency.exponentialRampToValueAtTime(40, t + 0.1);
          gn.gain.setValueAtTime(0.8, t);
          gn.gain.exponentialRampToValueAtTime(0.01, t + 0.1);
          osc.connect(gn); osc.start(t); osc.stop(t + 0.1);
        }
        else if (type === 'snare') {
          const buf = this.ctx.createBuffer(1, 1000, this.ctx.sampleRate);
          const data = buf.getChannelData(0);
          for (let i = 0; i < 1000; i++) data[i] = Math.random() * 2 - 1;
          const src = this.ctx.createBufferSource();
          src.buffer = buf;
          const filt = this.ctx.createBiquadFilter();
          filt.type = 'highpass'; filt.frequency.value = 1000;
          gn.gain.setValueAtTime(0.4, t);
          gn.gain.exponentialRampToValueAtTime(0.01, t + 0.1);
          src.connect(filt); filt.connect(gn); src.start(t);
        }
        else if (type === 'hihat') {
          const buf = this.ctx.createBuffer(1, 300, this.ctx.sampleRate);
          const data = buf.getChannelData(0);
          for (let i = 0; i < 300; i++) data[i] = Math.random() * 2 - 1;
          const src = this.ctx.createBufferSource();
          src.buffer = buf;
          const filt = this.ctx.createBiquadFilter();
          filt.type = 'highpass'; filt.frequency.value = 8000;
          gn.gain.setValueAtTime(0.1, t);
          gn.gain.exponentialRampToValueAtTime(0.01, t + 0.05);
          src.connect(filt); filt.connect(gn); src.start(t);
        }
        else if (type === 'crash') {
          const buf = this.ctx.createBuffer(1, 20000, this.ctx.sampleRate);
          const data = buf.getChannelData(0);
          for (let i = 0; i < 20000; i++) data[i] = Math.random() * 2 - 1;
          const src = this.ctx.createBufferSource();
          src.buffer = buf;
          const filt = this.ctx.createBiquadFilter();
          filt.type = 'highpass'; filt.frequency.value = 4000;
          gn.gain.setValueAtTime(0.3, t);
          gn.gain.exponentialRampToValueAtTime(0.01, t + 1.5);
          src.connect(filt); filt.connect(gn); src.start(t);
        }
      }
    }
    // MODULE 17: FinalBoss1 (Final Boss Engine) - FIXED STOP
class FinalBossModule {
  constructor(ctx, dest) {
    this.ctx = ctx;
    this.dest = dest;
    this.timer = null;
    this.activeNodes = []; // TRACKER: Keeps track of playing sounds

    // --- BOSS STATS ---
    this.tempo = 165; 
    this.basePitch = 293.66; 

    this.scale = [0, 1, 4, 5, 7, 8, 10];

    // --- STATE ---
    this.tickCount = 0;
    this.barCount = 0;
    this.phase = 1; 
    this.currentRoot = 0;

    // --- MIXING ---
    this.masterBus = ctx.createDynamicsCompressor();
    this.masterBus.threshold.value = -10;
    this.masterBus.ratio.value = 20; 
    this.masterBus.attack.value = 0.001;

    // OUTPUT GAIN: The final gate
    this.outputGain = ctx.createGain();
    this.outputGain.gain.value = 1.0;

    this.masterBus.connect(this.outputGain);
    this.outputGain.connect(dest);
  }

  start() {
    this.stop(); // clear any ghosts first
    this.tickCount = 0;
    this.barCount = 0;
    this.tempo = 165; 
    this.activeNodes = []; // Reset tracker

    // Un-mute
    this.outputGain.gain.cancelScheduledValues(this.ctx.currentTime);
    this.outputGain.gain.setValueAtTime(1.0, this.ctx.currentTime);
    this.outputGain.connect(this.dest);
    
    this.playIntro(); 
    this.timer = setTimeout(() => this.loop(), 2000);
  }

  stop() {
    // 1. Stop the loop logic
    if (this.timer) clearTimeout(this.timer);

    // 2. FORCE STOP ALL ACTIVE OSCILLATORS
    this.activeNodes.forEach(node => {
        try {
            node.stop(); 
            node.disconnect();
        } catch (e) { /* ignore already stopped */ }
    });
    this.activeNodes = [];

    // 3. Mute the output gain instantly
    if (this.outputGain) {
        this.outputGain.gain.cancelScheduledValues(this.ctx.currentTime);
        this.outputGain.gain.setValueAtTime(this.outputGain.gain.value, this.ctx.currentTime);
        this.outputGain.gain.linearRampToValueAtTime(0, this.ctx.currentTime + 0.01); // 10ms fade
        
        // Disconnect after a tiny moment to prevent clicks
        setTimeout(() => {
             // Only disconnect if we haven't started again
             if(this.outputGain.gain.value === 0) this.outputGain.disconnect(); 
        }, 50);
    }
  }

  // --- THE "WARNING" INTRO ---
  playIntro() {
    const t = this.ctx.currentTime;
    // Siren Alarms
    this.createSiren(t, this.basePitch * 2);
    this.createSiren(t + 0.5, this.basePitch * 2 * 1.414); 
    this.createSiren(t + 1.0, this.basePitch * 2);
    this.createSiren(t + 1.5, this.basePitch * 2 * 1.414);

    this.playDrum('reverse_cymbal', t);
    this.playDrum('crash', t + 1.9); 
  }

  createSiren(t, freq) {
    const osc = this.ctx.createOscillator();
    osc.type = 'sawtooth';
    osc.frequency.setValueAtTime(freq, t);
    osc.frequency.linearRampToValueAtTime(freq * 0.9, t + 0.5); 

    const gain = this.ctx.createGain();
    gain.gain.setValueAtTime(0.3, t);
    gain.gain.linearRampToValueAtTime(0, t + 0.5);

    osc.connect(gain); gain.connect(this.masterBus);
    
    osc.start(t); osc.stop(t + 0.5);
    
    // Add to tracker so we can kill it
    this.activeNodes.push(osc);
  }

  // --- MAIN LOOP ---
  loop() {
    const secondsPerBeat = 60 / this.tempo;
    const interval = (secondsPerBeat / 4) * 1000; 

    this.timer = setTimeout(() => this.loop(), interval);
    const step = this.tickCount % 16;

    if (step === 0) {
      this.barCount++;
      if (this.barCount % 4 === 0) this.progressHarmony();
      if (this.barCount % 32 === 0) {
        this.tempo += 5; 
        this.phase = 2;
        console.log("BOSS ENRAGED: Tempo " + this.tempo);
      }
      if (this.barCount % 4 === 1) this.playChoirChord();
    }

    this.playMetalDrums(step);
    this.playPowerBass(step);

    if (this.phase === 1) this.playThemeMelody(step);
    else this.playShredArp(step);

    this.tickCount++;
  }

  progressHarmony() {
    const moves = [1, 4, 1, -2]; 
    const move = moves[Math.floor(Math.random() * moves.length)];
    this.currentRoot += move;
    if (this.currentRoot > 3) this.currentRoot -= 7;
    if (this.currentRoot < -3) this.currentRoot += 7;
  }

  // --- INSTRUMENTS ---

  playMetalDrums(step) {
    if (step % 2 === 0) this.playDrum('kick');
    if (step === 4 || step === 12) this.playDrum('snare');
    if (this.phase === 2 && step % 4 === 0) this.playDrum('hihat_open');
    else if (step % 2 === 0) this.playDrum('hihat_closed');
  }

  playPowerBass(step) {
    const chugGrid = [1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 1, 1, 0];
    if (chugGrid[step] === 1) {
      this.playNote(this.currentRoot, -2, 'dist_bass'); 
      this.playNote(this.currentRoot + 4, -2, 'dist_bass'); 
    }
  }

  playChoirChord() {
    const notes = [0, 2, 4]; 
    notes.forEach(n => {
      this.playNote(this.currentRoot + n, 0, 'choir');
      this.playNote(this.currentRoot + n, -1, 'choir'); 
    });
  }

  playThemeMelody(step) {
    if (step % 4 === 0) {
      const tones = [0, 1, 4, 7];
      const tone = this.currentRoot + tones[Math.floor(Math.random() * tones.length)];
      this.playNote(tone, 1, 'lead_saw');
    }
  }

  playShredArp(step) {
    const arpPattern = [0, 2, 4, 7, 4, 2, 0, -1];
    const note = this.currentRoot + arpPattern[step % 8];
    this.playNote(note, 2, 'lead_saw');
  }

  // --- SYNTH ENGINE ---

  playNote(degree, octave, type) {
    const t = this.ctx.currentTime;
    
    let normDegree = degree;
    let octAdjust = 0;
    while (normDegree < 0) { normDegree += 7; octAdjust -= 1; }
    while (normDegree >= 7) { normDegree -= 7; octAdjust += 1; }
    const freq = this.basePitch * Math.pow(2, (this.scale[normDegree] + ((octave + octAdjust) * 12)) / 12);

    if (type === 'dist_bass') {
      this.createVoice(t, freq, 'sawtooth', {
        att: 0.01, dec: 0.1, sus: 0.5, rel: 0.1,
        filt: 800, Q: 5, vol: 0.3
      });
    }
    else if (type === 'lead_saw') {
      this.createVoice(t, freq, 'square', {
        att: 0.05, dec: 0.1, sus: 0.8, rel: 0.3,
        filt: 4000, Q: 2, vol: 0.15
      });
    }
    else if (type === 'choir') {
      const osc = this.ctx.createOscillator();
      osc.type = 'sawtooth';
      osc.frequency.value = freq;
      osc.detune.value = (Math.random() * 20) - 10; 

      const filter = this.ctx.createBiquadFilter();
      filter.type = 'bandpass'; filter.frequency.value = 1200; filter.Q.value = 4;

      const gain = this.ctx.createGain();
      gain.gain.setValueAtTime(0, t);
      gain.gain.linearRampToValueAtTime(0.2, t + 0.5); 
      gain.gain.setTargetAtTime(0, t + 2.0, 0.5); 

      osc.connect(filter); filter.connect(gain); gain.connect(this.masterBus);
      osc.start(t); osc.stop(t + 3.0);
      
      this.activeNodes.push(osc); // Track choir
    }
  }

  createVoice(t, freq, wave, p) {
    const osc = this.ctx.createOscillator();
    osc.type = wave;
    osc.frequency.value = freq;

    const filter = this.ctx.createBiquadFilter();
    filter.type = 'lowpass';
    filter.frequency.value = p.filt;
    filter.Q.value = p.Q;

    filter.frequency.exponentialRampToValueAtTime(p.filt * 0.2, t + p.dec);

    const gain = this.ctx.createGain();
    gain.gain.setValueAtTime(0, t);
    gain.gain.linearRampToValueAtTime(p.vol, t + p.att);
    gain.gain.setTargetAtTime(p.vol * p.sus, t + p.att, p.dec);
    gain.gain.setTargetAtTime(0, t + p.att + 0.1, p.rel);

    osc.connect(filter); filter.connect(gain); gain.connect(this.masterBus);
    osc.start(t); osc.stop(t + 1.0);
    
    this.activeNodes.push(osc); // Track voice
  }

  playDrum(type, time) {
    const t = time || this.ctx.currentTime;
    const gn = this.ctx.createGain();
    gn.connect(this.masterBus);
    
    let osc = null; // Track kick osc

    if (type === 'kick') {
      osc = this.ctx.createOscillator();
      osc.frequency.setValueAtTime(100, t);
      osc.frequency.exponentialRampToValueAtTime(20, t + 0.1);
      gn.gain.setValueAtTime(1.0, t); 
      gn.gain.exponentialRampToValueAtTime(0.01, t + 0.1);
      osc.connect(gn); osc.start(t); osc.stop(t + 0.1);
      this.activeNodes.push(osc);
    }
    else if (type === 'snare') {
      const buf = this.ctx.createBuffer(1, 1000, this.ctx.sampleRate);
      const data = buf.getChannelData(0);
      for (let i = 0; i < 1000; i++) data[i] = Math.random() * 2 - 1;
      const src = this.ctx.createBufferSource();
      src.buffer = buf;
      const f = this.ctx.createBiquadFilter();
      f.type = 'highpass'; f.frequency.value = 800;
      gn.gain.setValueAtTime(0.6, t);
      gn.gain.exponentialRampToValueAtTime(0.01, t + 0.15);
      src.connect(f); f.connect(gn); src.start(t);
      this.activeNodes.push(src);
    }
    else if (type === 'reverse_cymbal') {
      const buf = this.ctx.createBuffer(1, 44100 * 2, this.ctx.sampleRate);
      const data = buf.getChannelData(0);
      for (let i = 0; i < data.length; i++) data[i] = Math.random() * 0.5;
      const src = this.ctx.createBufferSource();
      src.buffer = buf;
      const f = this.ctx.createBiquadFilter();
      f.type = 'bandpass'; f.frequency.value = 5000;
      gn.gain.setValueAtTime(0, t);
      gn.gain.linearRampToValueAtTime(0.4, t + 1.8);
      gn.gain.linearRampToValueAtTime(0, t + 1.9); 
      src.connect(f); f.connect(gn); src.start(t);
      this.activeNodes.push(src);
    }
    else if (type === 'crash') {
      const buf = this.ctx.createBuffer(1, 44100, this.ctx.sampleRate);
      const data = buf.getChannelData(0);
      for (let i = 0; i < data.length; i++) data[i] = Math.random() * 2 - 1;
      const src = this.ctx.createBufferSource();
      src.buffer = buf;
      const f = this.ctx.createBiquadFilter();
      f.type = 'lowpass'; f.frequency.value = 8000;
      gn.gain.setValueAtTime(0.5, t);
      gn.gain.exponentialRampToValueAtTime(0.01, t + 2.0);
      src.connect(f); f.connect(gn); src.start(t);
      this.activeNodes.push(src);
    }
  }
}
// MODULE 18: EVENT HORIZON (The True Form)
    class FinalFormModule {
      constructor(ctx, dest) {
        this.ctx = ctx;
        this.dest = dest;
        this.timer = null;

        // --- COSMIC STATS ---
        this.tempo = 175; // Heart attack speed
        this.basePitch = 146.83; // D3

        // THE "EVIL" SCALE (Octatonic: Half-Whole)
        // C, Db, Eb, E, F#, G, A, Bb (Symmetrical, no center, pure tension)
        this.scale = [0, 1, 3, 4, 6, 7, 9, 10];

        // --- STATE ---
        this.tickCount = 0;
        this.barCount = 0;
        this.gameState = 'transform'; // Starts with the transformation

        // Logic
        this.currentRoot = 0;
        this.chaosLevel = 0; // Increases over time

        // --- GLOBAL FX CHAIN ---

        // 1. Distortion (The "Reality Break")
        this.dist = ctx.createWaveShaper();
        this.dist.curve = this.makeDistortionCurve(50); // Mild crunch
        this.dist.oversample = '4x';

        // 2. Compression (The "Wall of Sound")
        this.comp = ctx.createDynamicsCompressor();
        this.comp.threshold.value = -15;
        this.comp.ratio.value = 20;
        this.comp.attack.value = 0.001;

        // Chain: Source -> Dist -> Comp -> Dest
        this.dist.connect(this.comp);
        this.comp.connect(dest);

        // We connect instruments to 'this.dist'
        this.mixBus = this.dist;
      }

      makeDistortionCurve(amount) {
        const k = typeof amount === 'number' ? amount : 50,
          n_samples = 44100,
          curve = new Float32Array(n_samples),
          deg = Math.PI / 180;
        for (let i = 0; i < n_samples; ++i) {
          let x = i * 2 / n_samples - 1;
          curve[i] = (3 + k) * x * 20 * deg / (Math.PI + k * Math.abs(x));
        }
        return curve;
      }

      start() {
        this.tickCount = 0;
        this.barCount = 0;
        this.gameState = 'transform';
        this.loop();
      }

      stop() {
        if (this.timer) clearTimeout(this.timer);
      }

      loop() {
        // Frantic update rate
        const secondsPerBeat = 60 / this.tempo;
        const interval = (secondsPerBeat / 4) * 1000; // 16th notes

        this.timer = setTimeout(() => this.loop(), interval);

        if (this.gameState === 'transform') {
          this.playTransformationSequence();
        } else {
          this.playApocalypse();
        }

        this.tickCount++;
      }

      // --- PHASE 1: THE TRANSFORMATION (Silence & Dread) ---
      playTransformationSequence() {
        const t = this.ctx.currentTime;
        const step = this.tickCount;

        // 0. The "Heartbeat" (Player's Panic)
        // Thumps on beats 1.... and.... 
        if (step % 16 === 0 || step % 16 === 2) {
          this.playDrum('heartbeat');
        }

        // 1. The "Tinnitus" (Ear Ringing)
        // High pitched sine wave fading in
        if (step === 0) {
          const osc = this.ctx.createOscillator();
          osc.frequency.setValueAtTime(8000, t);
          const gn = this.ctx.createGain();
          gn.gain.setValueAtTime(0, t);
          gn.gain.linearRampToValueAtTime(0.05, t + 4.0); // Slow fade in
          osc.connect(gn); gn.connect(this.mixBus);
          osc.start(t); osc.stop(t + 5.0);
        }

        // 2. The "Reality Crack" (End of intro)
        if (step === 32) {
          this.playDrum('crash');
          this.gameState = 'battle';
          this.tickCount = -1; // Reset
        }
      }

      // --- PHASE 2: THE APOCALYPSE ---
      playApocalypse() {
        const step = this.tickCount % 16;

        // --- DIRECTOR ---
        if (step === 0) {
          this.barCount++;

          // Randomly shift root to disorient player (Tritone jumps)
          if (this.barCount % 2 === 0) {
            this.currentRoot = (Math.random() > 0.5) ? 0 : 6; // Root vs Tritone
          }

          // TRIGGER "DESPAIR" CHOIR
          this.playChoirCluster();
        }

        // --- 1. BLAST BEAT DRUMS (Relentless) ---
        this.playBlastBeat(step);

        // --- 2. CHAOS BASS (Octave Jumps) ---
        if (step % 2 === 0) {
          const oct = (step % 4 === 0) ? -2 : -1;
          this.playNote(this.currentRoot, oct, 'dist_bass');
        }

        // --- 3. THE "BEYOND" LEAD (Octatonic Sweep) ---
        // Ultra fast 32nd note feel (playing every tick)
        const arpIndex = step % 8;
        // 0, 1, 3, 4, 6, 7, 9, 10
        const note = this.currentRoot + this.scale[arpIndex];
        // Random octave jumps to sound "glitchy"
        const randOct = (Math.random() > 0.7) ? 2 : 1;
        this.playNote(note, randOct, 'glitch_lead');

        // --- 4. THE "HOPE" (Desperate Piano) ---
        // Tries to play a melody but gets drowned out
        if (step % 4 === 0 && Math.random() > 0.3) {
          // High piano note, Major 3rd or 5th (trying to be major in a minor world)
          const hopeNote = this.currentRoot + 4; // Major 3rd (clashes with minor context)
          this.playNote(hopeNote, 2, 'piano');
        }
      }

      // --- INSTRUMENTS ---

      playBlastBeat(step) {
        // KICK: Every beat (0, 4, 8, 12) + rapid doubles
        if (step % 4 === 0) this.playDrum('kick');
        if (step % 4 === 1 && Math.random() > 0.5) this.playDrum('kick'); // Double kick

        // SNARE: MACHINE GUN
        // Hits on all off-beats (2, 6, 10, 14) + Ghost notes
        if (step % 4 === 2) this.playDrum('snare');

        // CRASH: Constant washing noise (The "Wall")
        if (step === 0 || step === 8) this.playDrum('open_hat');
      }

      playChoirCluster() {
        // Plays a "Cluster Chord" (Notes extremely close together)
        // This creates a terrifying "Wail" sound
        const t = this.ctx.currentTime;
        const notes = [0, 1, 3]; // Root, Flat 2, Minor 3rd (Very dissonant)

        notes.forEach(n => {
          this.playNote(this.currentRoot + n, 0, 'choir');
          this.playNote(this.currentRoot + n, 1, 'choir');
        });
      }

      // --- SYNTH ENGINE ---

      playNote(degree, octave, type) {
        const t = this.ctx.currentTime;

        // Octatonic Mapping
        let idx = degree;
        // Map degrees to scale index roughly
        while (idx < 0) idx += 8;
        const noteIndex = idx % 8;
        const semitone = this.scale[noteIndex];

        const freq = this.basePitch * Math.pow(2, (semitone + (octave * 12)) / 12);

        if (type === 'dist_bass') {
          // DOOM BASS
          this.createVoice(t, freq, 'sawtooth', {
            att: 0.01, dec: 0.2, sus: 0.8, rel: 0.1,
            filt: 600, Q: 10, vol: 0.4
          });
        }
        else if (type === 'glitch_lead') {
          // ALIEN TECH
          // Square wave that pitch bends randomly
          const osc = this.ctx.createOscillator();
          osc.type = 'square';
          osc.frequency.setValueAtTime(freq, t);
          // Glitch slide
          if (Math.random() > 0.5) osc.frequency.linearRampToValueAtTime(freq * 1.5, t + 0.1);

          const gain = this.ctx.createGain();
          gain.gain.setValueAtTime(0.1, t);
          gain.gain.exponentialRampToValueAtTime(0.01, t + 0.1); // Staccato

          osc.connect(gain); gain.connect(this.mixBus);
          osc.start(t); osc.stop(t + 0.1);
        }
        else if (type === 'choir') {
          // THE DAMNED
          const osc = this.ctx.createOscillator();
          osc.type = 'sawtooth';
          osc.frequency.value = freq;
          osc.detune.value = (Math.random() * 20) - 10; // Massive detune

          const filt = this.ctx.createBiquadFilter();
          filt.type = 'highpass'; filt.frequency.value = 800; // Thin, ghostly

          const gain = this.ctx.createGain();
          gain.gain.setValueAtTime(0, t);
          gain.gain.linearRampToValueAtTime(0.15, t + 0.5); // Slow swell
          gain.gain.setTargetAtTime(0, t + 1.5, 0.5);

          osc.connect(filt); filt.connect(gain); gain.connect(this.mixBus);
          osc.start(t); osc.stop(t + 3.0);
        }
        else if (type === 'piano') {
          // THE HEROIC PIANO
          // Simple Sine+Triangle mix for clarity
          const osc = this.ctx.createOscillator();
          osc.type = 'triangle';
          osc.frequency.value = freq;

          const gain = this.ctx.createGain();
          gain.gain.setValueAtTime(0, t);
          gain.gain.linearRampToValueAtTime(0.3, t + 0.01); // Ping
          gain.gain.exponentialRampToValueAtTime(0.01, t + 0.8);

          osc.connect(gain); gain.connect(this.mixBus); // Bypass distortion? No, let it distort for tragedy
          osc.start(t); osc.stop(t + 0.8);
        }
      }

      createVoice(t, freq, wave, p) {
        const osc = this.ctx.createOscillator();
        osc.type = wave;
        osc.frequency.value = freq;

        const filter = this.ctx.createBiquadFilter();
        filter.type = 'lowpass';
        filter.frequency.value = p.filt;
        filter.Q.value = p.Q;

        const gain = this.ctx.createGain();
        gain.gain.setValueAtTime(0, t);
        gain.gain.linearRampToValueAtTime(p.vol, t + p.att);
        gain.gain.setTargetAtTime(p.vol * p.sus, t + p.att, p.dec);
        gain.gain.setTargetAtTime(0, t + p.att + 0.1, p.rel);

        osc.connect(filter); filter.connect(gain); gain.connect(this.mixBus);
        osc.start(t); osc.stop(t + 0.5);
      }

      playDrum(type) {
        const t = this.ctx.currentTime;
        const gn = this.ctx.createGain();
        gn.connect(this.mixBus);

        if (type === 'kick') {
          // MASSIVE KICK
          const osc = this.ctx.createOscillator();
          osc.frequency.setValueAtTime(100, t);
          osc.frequency.exponentialRampToValueAtTime(20, t + 0.1);
          gn.gain.setValueAtTime(1.0, t); // Max volume
          gn.gain.exponentialRampToValueAtTime(0.01, t + 0.1);
          osc.connect(gn); osc.start(t); osc.stop(t + 0.1);
        }
        else if (type === 'heartbeat') {
          // DULL THUD
          const osc = this.ctx.createOscillator();
          osc.frequency.setValueAtTime(60, t);
          osc.frequency.exponentialRampToValueAtTime(10, t + 0.3); // Slower drop
          gn.gain.setValueAtTime(0.8, t);
          gn.gain.exponentialRampToValueAtTime(0.01, t + 0.3);

          const filt = this.ctx.createBiquadFilter();
          filt.type = 'lowpass'; filt.frequency.value = 100; // Muffled

          osc.disconnect(); osc.connect(filt); filt.connect(gn);
          osc.start(t); osc.stop(t + 0.3);
        }
        else if (type === 'snare') {
          // CRACKING SNARE
          const buf = this.ctx.createBuffer(1, 1000, this.ctx.sampleRate);
          const data = buf.getChannelData(0);
          for (let i = 0; i < 1000; i++) data[i] = Math.random() * 2 - 1;
          const src = this.ctx.createBufferSource();
          src.buffer = buf;
          const f = this.ctx.createBiquadFilter();
          f.type = 'highpass'; f.frequency.value = 800;
          gn.gain.setValueAtTime(0.6, t);
          gn.gain.exponentialRampToValueAtTime(0.01, t + 0.15);
          src.connect(f); f.connect(gn); src.start(t);
        }
        else if (type === 'open_hat') {
          // WHITE NOISE WASH
          const buf = this.ctx.createBuffer(1, 10000, this.ctx.sampleRate);
          const data = buf.getChannelData(0);
          for (let i = 0; i < 10000; i++) data[i] = Math.random() * 2 - 1;
          const src = this.ctx.createBufferSource();
          src.buffer = buf;
          const f = this.ctx.createBiquadFilter();
          f.type = 'highpass'; f.frequency.value = 4000;
          gn.gain.setValueAtTime(0.2, t);
          gn.gain.exponentialRampToValueAtTime(0.01, t + 0.3);
          src.connect(f); f.connect(gn); src.start(t);
        }
      }
    }
    // MODULE 19: EVENT HORIZON (Fixed & Tightened)
    class SingularityModule {
  constructor(ctx, dest) {
    this.ctx = ctx;
    this.dest = dest;
    this.timer = null;

    // --- COSMIC STATS ---
    this.tempo = 140; 
    this.basePitch = 73.42; // D2
    this.currentKeyPitch = this.basePitch;
    this.scale = [0, 1, 3, 4, 6, 7, 9, 10]; // Octatonic

    // --- STATE ---
    this.tickCount = 0;
    this.barCount = 0;
    this.gameState = 'transform';
    this.melodyMode = 'sustain';
    
    // --- TIMING ENGINE (The Fix for 175 BPM jitter) ---
    this.nextNoteTime = 0; // Tracks "Perfect Time" instead of "Browser Time"

    // --- GLOBAL FX CHAIN ---
    // 1. Master Volume (ADDED: Essential for stopping)
    this.outputGain = ctx.createGain();
    this.outputGain.gain.value = 0.5;
    this.outputGain.connect(dest);

    // 2. Compressor 
    this.comp = ctx.createDynamicsCompressor();
    this.comp.threshold.value = -10;
    this.comp.ratio.value = 12;
    this.comp.connect(this.outputGain); // Connect to Gain, not Dest

    // 3. Filter
    this.globalFilter = ctx.createBiquadFilter();
    this.globalFilter.type = 'lowpass';
    this.globalFilter.frequency.value = 18000;
    this.globalFilter.connect(this.comp);

    // 4. Distortion
    this.distortion = ctx.createWaveShaper();
    this.distortion.curve = this.makeDistortionCurve(80);
    this.distortion.oversample = '4x';
    this.distortion.connect(this.globalFilter);

    // Instruments connect here
    this.bus = this.distortion;
    
    // Improviser State
    this.lastNoteIndex = 0;
    this.currentRoot = 0;
  }

  makeDistortionCurve(amount) {
    const k = amount, n_samples = 44100, curve = new Float32Array(n_samples);
    const deg = Math.PI / 180;
    for (let i = 0; i < n_samples; ++i) {
      let x = i * 2 / n_samples - 1;
      curve[i] = (3 + k) * x * 20 * deg / (Math.PI + k * Math.abs(x));
    }
    return curve;
  }

  start() {
    this.tickCount = 0;
    this.barCount = 0;
    this.currentKeyPitch = this.basePitch;
    this.gameState = 'transform';
    
    // Reset Volume
    this.outputGain.gain.cancelScheduledValues(this.ctx.currentTime);
    this.outputGain.gain.setValueAtTime(0.5, this.ctx.currentTime);

    // CRITICAL: Sync "Next Note" to "Now" plus a tiny buffer
    this.nextNoteTime = this.ctx.currentTime + 0.05;

    this.loop();
  }

  stop() {
    if (this.timer) clearTimeout(this.timer);
    
    // CRITICAL FIX: Hard cut the volume on the new Output Gain node
    if (this.outputGain) {
        this.outputGain.gain.cancelScheduledValues(this.ctx.currentTime);
        this.outputGain.gain.setValueAtTime(this.outputGain.gain.value, this.ctx.currentTime);
        this.outputGain.gain.linearRampToValueAtTime(0, this.ctx.currentTime + 0.05); // Instant silence
    }
  }

  loop() {
    // 1. Schedule audio ahead of time
    const secondsPerBeat = 60 / this.tempo;
    const stepInterval = secondsPerBeat / 4; // 16th note
    const scheduleAheadTime = 0.1; // Look 100ms into the future

    // While the next note is within our "Look Ahead" window, schedule it
    while (this.nextNoteTime < this.ctx.currentTime + scheduleAheadTime) {
        this.scheduleTick(this.nextNoteTime);
        this.nextNoteTime += stepInterval;
    }

    // 2. Keep the loop alive (Check again in 25ms)
    this.timer = setTimeout(() => this.loop(), 25);
  }

  // This replaces your old 'tick()'
  scheduleTick(t) {
    const step = this.tickCount % 20; // 5/4 Time

    if (this.gameState === 'transform') {
        this.playTransformationSequence(t);
    } else {
        this.playApocalypse(t);
    }

    this.tickCount++;
  }

  // --- LOGIC (Updated to use 't' instead of 'now') ---

  playTransformationSequence(t) {
    const step = this.tickCount;

    if (step % 16 === 0 || step % 16 === 2) {
      this.playDrum('heartbeat', t);
    }

    if (step === 0) {
      const osc = this.ctx.createOscillator();
      osc.frequency.setValueAtTime(8000, t);
      const gn = this.ctx.createGain();
      gn.gain.setValueAtTime(0, t);
      gn.gain.linearRampToValueAtTime(0.05, t + 4.0);
      osc.connect(gn); gn.connect(this.bus);
      osc.start(t); osc.stop(t + 5.0);
    }

    if (step === 32) {
      this.playDrum('crash', t);
      this.gameState = 'battle';
      this.tickCount = -1; 
    }
  }

  playApocalypse(t) {
    const step = this.tickCount % 16;

    if (step === 0) {
      this.barCount++;
      if (this.barCount % 4 === 0) this.modulateKey();
      
      this.melodyMode = (Math.random() > 0.6) ? 'run' : 'sustain';
      
      this.playSubDrop(t);
      this.playAlienChoir(t);
    }

    if (step === 0 || step === 3 || step === 6 || step === 14) {
      this.playIndustrialPercussion(t);
    }

    this.playEpicLead(step, t);
  }

  modulateKey() {
    const shift = (Math.random() > 0.5) ? 3 : -3;
    this.currentKeyPitch *= Math.pow(2, shift / 12);
    if (this.currentKeyPitch > 150) this.currentKeyPitch /= 2;
    if (this.currentKeyPitch < 50) this.currentKeyPitch *= 2;
  }

  playEpicLead(step, t) {
    if (Math.random() > 0.8 && this.melodyMode === 'sustain') return;

    let playNote = false;
    let noteDuration = 0.2;

    if (this.melodyMode === 'sustain') {
      if (step === 0 || step === 6 || step === 12 || step === 16) {
        playNote = true;
        noteDuration = 0.8;
        const move = (Math.random() > 0.5) ? 1 : -1;
        this.lastNoteIndex += move;
      }
    } else {
      playNote = true;
      noteDuration = 0.15;
      const move = Math.floor(Math.random() * 5) - 2;
      this.lastNoteIndex += move;
    }

    if (this.lastNoteIndex > 10) this.lastNoteIndex -= 4;
    if (this.lastNoteIndex < 0) this.lastNoteIndex += 4;

    if (playNote) {
      const degree = this.scale[this.lastNoteIndex % 8];
      const freq = this.currentKeyPitch * 8 * Math.pow(2, degree / 12);
      this.createLeadVoice(freq, noteDuration, t);
    }
  }

  // --- INSTRUMENTS (Updated to accept 't') ---

  createLeadVoice(freq, duration, t) {
    const osc = this.ctx.createOscillator();
    osc.type = 'sawtooth';
    osc.frequency.setValueAtTime(freq * 0.9, t);
    osc.frequency.linearRampToValueAtTime(freq, t + 0.05);

    const filter = this.ctx.createBiquadFilter();
    filter.type = 'lowpass';
    filter.frequency.value = 4000;
    filter.Q.value = 2;

    const gain = this.ctx.createGain();
    gain.gain.setValueAtTime(0, t);
    gain.gain.linearRampToValueAtTime(0.15, t + 0.05);
    gain.gain.setTargetAtTime(0.1, t + 0.05, duration); 
    gain.gain.setTargetAtTime(0, t + duration, 0.1); // Fast release

    const lfo = this.ctx.createOscillator();
    lfo.frequency.value = 6;
    const lfoGain = this.ctx.createGain();
    lfoGain.gain.value = freq * 0.02;

    lfo.connect(lfoGain); lfoGain.connect(osc.frequency);
    lfo.start(t); lfo.stop(t + duration + 0.2);

    osc.connect(filter); filter.connect(gain); gain.connect(this.bus);
    osc.start(t); osc.stop(t + duration + 0.2);
  }

  playSubDrop(t) {
    const osc = this.ctx.createOscillator();
    osc.frequency.setValueAtTime(this.currentKeyPitch, t);
    osc.frequency.exponentialRampToValueAtTime(20, t + 1.0);

    const g = this.ctx.createGain();
    g.gain.setValueAtTime(0.8, t);
    g.gain.exponentialRampToValueAtTime(0.001, t + 1.5);

    osc.connect(g); g.connect(this.bus);
    osc.start(t); osc.stop(t + 1.5);
  }

  playAlienChoir(t) {
    const freq = this.currentKeyPitch * 2;
    const osc = this.ctx.createOscillator();
    osc.type = 'sawtooth';
    osc.frequency.value = freq;
    osc.detune.value = (Math.random() * 20) - 10;

    const f1 = this.ctx.createBiquadFilter();
    f1.type = 'bandpass'; f1.frequency.value = 600; f1.Q.value = 5;
    const f2 = this.ctx.createBiquadFilter();
    f2.type = 'bandpass'; 
    f2.frequency.setValueAtTime(1200, t);
    f2.frequency.linearRampToValueAtTime(800, t + 2.0);
    f2.Q.value = 5;

    const g = this.ctx.createGain();
    g.gain.setValueAtTime(0, t);
    g.gain.linearRampToValueAtTime(0.3, t + 1.0);
    g.gain.setTargetAtTime(0, t + 2.0, 0.5);

    osc.connect(f1); f1.connect(g);
    osc.connect(f2); f2.connect(g);
    g.connect(this.bus);
    osc.start(t); osc.stop(t + 4.0);
  }

  playIndustrialPercussion(t) {
    const carrier = this.ctx.createOscillator();
    carrier.frequency.value = 200;
    const mod = this.ctx.createOscillator();
    mod.frequency.value = 345;
    const modGain = this.ctx.createGain();
    modGain.gain.value = 1000;

    mod.connect(modGain); modGain.connect(carrier.frequency);

    const amp = this.ctx.createGain();
    amp.gain.setValueAtTime(0.4, t);
    amp.gain.exponentialRampToValueAtTime(0.001, t + 0.1);

    carrier.connect(amp); amp.connect(this.bus);
    carrier.start(t); carrier.stop(t + 0.1);
    mod.start(t); mod.stop(t + 0.1);
  }

  playDrum(type, t) {
    const gn = this.ctx.createGain();
    gn.connect(this.bus);

    if (type === 'heartbeat') {
      const osc = this.ctx.createOscillator();
      osc.frequency.setValueAtTime(60, t);
      osc.frequency.exponentialRampToValueAtTime(10, t + 0.3);
      gn.gain.setValueAtTime(0.8, t);
      gn.gain.exponentialRampToValueAtTime(0.01, t + 0.3);
      const filt = this.ctx.createBiquadFilter();
      filt.type = 'lowpass'; filt.frequency.value = 100;
      osc.connect(filt); filt.connect(gn);
      osc.start(t); osc.stop(t + 0.3);
    }
    else if (type === 'crash') {
        const buf = this.ctx.createBuffer(1, 44100, this.ctx.sampleRate);
        const data = buf.getChannelData(0);
        for(let i=0; i<44100; i++) data[i] = Math.random()*2-1;
        const src = this.ctx.createBufferSource();
        src.buffer = buf;
        const f = this.ctx.createBiquadFilter();
        f.type='lowpass'; f.frequency.value=8000;
        gn.gain.setValueAtTime(0.5, t);
        gn.gain.exponentialRampToValueAtTime(0.01, t+2.0);
        src.connect(f); f.connect(gn); src.start(t);
    }
  }
}
// MODULE 21: THE LAMENT (Baroque Sorrow Engine)
class LamentModule {
  constructor(ctx, dest) {
    this.ctx = ctx;
    this.dest = dest;
    this.timer = null;

    // --- EMOTIONAL SETTINGS ---
    this.tempo = 50; // Largo (Very Slow)
    this.basePitch = 196.00; // G3 (The G String)

    // D Minor (The saddest key) / G Minor / A Minor
    // We start in G Minor for that deep "Air" feel
    this.currentScale = this.getScale('G', 'minor'); 
    this.currentRootFreq = 196.00; // G3

    // --- STATE ---
    this.tickCount = 0;
    this.barCount = 0;
    this.chordIndex = 0;

    // The "Memory" (Required for Suspensions/Fugues)
    this.lastMelodyNote = 0; 
    this.heldSuspension = null; 

    // --- THE TEAR-JERKER FX CHAIN ---
    // 1. Convolver (The Cathedral)
    this.revNode = ctx.createConvolver();
    this.setupReverb();
    
    // 2. Master Gain (Volume Control)
    this.mainGain = ctx.createGain();
    this.mainGain.gain.value = 0.0; // Fade in
    this.mainGain.connect(this.revNode);
    this.revNode.connect(dest);
    
    // Dry signal (direct) mixed low for clarity
    this.dryGain = ctx.createGain();
    this.dryGain.gain.value = 0.4;
    this.mainGain.connect(this.dryGain);
    this.dryGain.connect(dest);
  }

  getScale(root, type) {
    // Circle of 5ths logic for modulation
    const roots = { 'C': 261.63, 'G': 196.00, 'D': 146.83, 'A': 220.00, 'E': 164.81, 'B': 246.94, 'F': 174.61, 'Bb': 233.08 };
    const base = roots[root];
    
    // Minor Scale intervals
    const intervals = [0, 2, 3, 5, 7, 8, 10]; 
    this.currentRootFreq = base;
    return intervals;
  }

  setupReverb() {
    // 4-Second Decay (Massive, empty space)
    const len = this.ctx.sampleRate * 4.0;
    const buf = this.ctx.createBuffer(2, len, this.ctx.sampleRate);
    for (let c = 0; c < 2; c++) {
      const d = buf.getChannelData(c);
      for (let i = 0; i < len; i++) {
        // Exponential decay
        d[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / len, 4);
      }
    }
    this.revNode.buffer = buf;
  }

  start() {
    this.tickCount = 0;
    this.barCount = 0;
    // Slow fade in
    this.mainGain.gain.linearRampToValueAtTime(0.6, this.ctx.currentTime + 3);
    this.loop();
  }

  stop() {
    if (this.timer) clearTimeout(this.timer);
    // Slow mournful fade out
    this.mainGain.gain.cancelScheduledValues(this.ctx.currentTime);
    this.mainGain.gain.linearRampToValueAtTime(0, this.ctx.currentTime + 3);
  }

  loop() {
    // Loop speed: Eighth notes (Walking Bass speed)
    const secondsPerBeat = 60 / this.tempo;
    const interval = (secondsPerBeat / 2) * 1000; 

    this.timer = setTimeout(() => this.loop(), interval);

    // Humanize timing slightly (The "Breath")
    const t = this.ctx.currentTime + (Math.random() * 0.02);
    const step = this.tickCount % 8; // 8 steps per bar (4/4 time, 8th notes)

    // --- 1. HARMONIC PROGRESSION (The Cycle of Grief) ---
    // Change chords every bar (step 0)
    if (step === 0) {
      this.barCount++;
      this.progressHarmony();
      
      // Modulate Key every 8 bars to keep it fresh
      if (this.barCount % 8 === 0) this.modulate();
    }

    // --- 2. WALKING BASS (The Heartbeat) ---
    // Plays steady 8th notes, moving stepwise
    this.playWalkingBass(t, step);

    // --- 3. THE WEEPING MELODY (Violins) ---
    // Plays slower, sustaining notes over the top
    this.playSighingMelody(t, step);

    // --- 4. INNER VOICES (Violas) ---
    // Fills the gap to create lushness
    if (step === 0 || step === 4) this.playInnerVoice(t);

    this.tickCount++;
  }

  // --- COMPOSITION LOGIC ---

  progressHarmony() {
    // Circle of Fifths Logic (Falling)
    // 0=i, 2=III, 3=iv, 4=v, 5=VI, 6=VII
    // Classic Lament: i -> v6 -> VI -> V -> i
    const cycle = [0, 4, 5, 3, 6, 2, 4, 0];
    this.chordIndex = (this.chordIndex + 1) % cycle.length;
    this.currentChord = cycle[this.chordIndex];
  }

  modulate() {
    // Shift the "Center of Sadness"
    // Move from G Minor -> D Minor (Darker) or Bb Major (Fleeting Hope)
    const targets = ['D', 'C', 'A', 'Bb']; 
    const key = targets[Math.floor(Math.random() * targets.length)];
    this.currentScale = this.getScale(key, 'minor');
    // Pitch shift sound cue?
    console.log(`Lament: Modulating to ${key} Minor`);
  }

  // --- INSTRUMENT LOGIC ---

  playWalkingBass(t, step) {
    // The bass "Walks" scale degrees
    // If Chord is i (0), bass plays 0, -1, -2, -3... descending lines are sad
    
    let noteDegree = this.currentChord; // Start on root
    
    // Step logic: Try to connect to next chord
    if (step > 0) {
        // 50% chance to step down (Lamento Bass), 50% to jump octave
        if (Math.random() > 0.5) noteDegree -= (step % 3); 
        else noteDegree += (step % 2);
    }

    this.playString(t, noteDegree, -2, 'cello');
  }

  playSighingMelody(t, step) {
    // This is the "Air" Logic. 
    // We want long notes that "suspend".

    // Only play on beat 1 or 3 (slow)
    if (step % 4 !== 0) return;

    // THE SUSPENSION ALGORITHM:
    // 1. If we have a held note, resolve it down by 1 step (The "Sigh")
    // 2. If no held note, jump up to a high tension note
    
    let noteDegree;
    let duration = 2.0; // Long

    if (this.heldSuspension !== null) {
        // RESOLVE DOWN
        noteDegree = this.heldSuspension - 1;
        this.heldSuspension = null; // Resolution complete
    } else {
        // CREATE TENSION
        // Pick a note 2 octaves up
        // Bias towards the 9th or 4th scale degree (beautiful tension)
        const tension = [1, 3, 5]; 
        noteDegree = this.currentChord + tension[Math.floor(Math.random()*tension.length)];
        
        // 40% chance to hold this note into the next chord clash
        if (Math.random() < 0.4) {
            this.heldSuspension = noteDegree;
            duration = 3.5; // Hold across bar line
        }
    }

    this.playString(t, noteDegree, 1, 'violin');
  }

  playInnerVoice(t) {
    // Viola playing the 3rd of the chord (defines sadness)
    this.playString(t, this.currentChord + 2, 0, 'viola');
  }

  // --- SOUND ENGINE (The Weeping Strings) ---

  playString(t, degree, octave, type) {
    // 1. Frequency Math
    let idx = degree;
    let octShift = 0;
    while(idx < 0) { idx += 7; octShift--; }
    while(idx >= 7) { idx -= 7; octShift++; }
    
    const semitone = this.currentScale[idx % 7];
    const freq = this.currentRootFreq * Math.pow(2, (semitone + (octave + octShift) * 12) / 12);

    // 2. Oscillators
    const osc = this.ctx.createOscillator();
    // Sawtooth is rich in harmonics (like a bowed string)
    osc.type = 'sawtooth'; 
    osc.frequency.value = freq;

    // 3. Vibrato (The "Human" Element)
    // Essential for "crying" sound
    const lfo = this.ctx.createOscillator();
    lfo.frequency.value = 4.5; // Speed of vibrato
    const lfoGain = this.ctx.createGain();
    lfoGain.gain.value = (type === 'violin') ? 3 : 1; // Violins vibrate more
    lfo.connect(lfoGain);
    lfoGain.connect(osc.frequency);
    lfo.start(t);

    // 4. The "Bow" Filter
    // Strings don't start bright. The bow drags, then sings.
    const filter = this.ctx.createBiquadFilter();
    filter.type = 'lowpass';
    const brightness = (type === 'cello') ? 600 : 2000;
    
    filter.frequency.setValueAtTime(200, t); // Start muffled
    // Slow swell of brightness (Swell logic)
    filter.frequency.linearRampToValueAtTime(brightness, t + 1.0); 

    // 5. Volume Envelope (ADSR)
    const gain = this.ctx.createGain();
    const vol = (type === 'cello') ? 0.4 : 0.25;
    
    gain.gain.setValueAtTime(0, t);
    // Slow attack (The Bow touching string)
    gain.gain.linearRampToValueAtTime(vol, t + 0.8); 
    // Long sustain
    gain.gain.setValueAtTime(vol, t + 2.0);
    // Long release
    gain.gain.linearRampToValueAtTime(0, t + 3.5);

    // Connections
    osc.connect(filter);
    filter.connect(gain);
    gain.connect(this.mainGain);

    osc.start(t);
    osc.stop(t + 4.0);
    lfo.stop(t + 4.0);
  }
}
// MODULE 22: ELEGIA (The "Sad and Beautiful" Engine)
class ElegiaModule {
  constructor(ctx, dest) {
    this.ctx = ctx;
    this.dest = dest;
    this.timer = null;

    // --- EMOTIONAL SETTINGS ---
    this.tempo = 40; // Extremely Slow (Adagio)
    // G Minor (The key of "Air") -> but we use extended voicings
    this.rootFreq = 196.00; 

    // --- STATE ---
    this.tickCount = 0;
    this.chordIndex = 0;
    
    // Tracks the current melody note for sliding (Portamento)
    this.lastMelodyFreq = null; 

    // --- THE "SILK" MIXER ---
    // We need a very smooth reverb, almost infinite
    this.masterGain = ctx.createGain();
    this.masterGain.gain.value = 0.0; // Fade in

    this.convolver = ctx.createConvolver();
    this.setupLushReverb();

    // Compressor to glue the "Orchestra"
    this.comp = ctx.createDynamicsCompressor();
    this.comp.threshold.value = -20;
    this.comp.ratio.value = 10;
    this.comp.attack.value = 0.1; // Slow attack for smoothness

    // Wiring: Source -> Comp -> Reverb -> Dest
    this.masterGain.connect(this.comp);
    this.comp.connect(this.convolver);
    this.convolver.connect(dest);
    
    // Also connect dry signal for definition
    this.dryGain = ctx.createGain();
    this.dryGain.gain.value = 0.2;
    this.comp.connect(this.dryGain);
    this.dryGain.connect(dest);
    
    // HARMONY STATE
    // i - VI - III - VII (The "Heroic/Tragic" Loop)
    // Gmin - EbMaj - BbMaj - FMaj
    this.progression = [
        { root: 0, type: 'minor', name: 'Gm' },
        { root: 8, type: 'major', name: 'Eb' }, // Up a minor 6th
        { root: 3, type: 'major', name: 'Bb' }, // Up a minor 3rd
        { root: 10, type: 'major', name: 'F' }  // Up a minor 7th
    ];
  }

  setupLushReverb() {
    // 5-second tail, very dense
    const len = this.ctx.sampleRate * 5.0;
    const buf = this.ctx.createBuffer(2, len, this.ctx.sampleRate);
    for (let c = 0; c < 2; c++) {
      const d = buf.getChannelData(c);
      for (let i = 0; i < len; i++) {
        // Linear fade is smoother than exponential for "pads"
        d[i] = (Math.random() * 2 - 1) * (1 - i / len);
      }
    }
    this.convolver.buffer = buf;
  }

  start() {
    this.tickCount = 0;
    this.masterGain.gain.linearRampToValueAtTime(0.7, this.ctx.currentTime + 4); // 4s Fade in
    this.loop();
  }

  stop() {
    if (this.timer) clearTimeout(this.timer);
    // 4s Fade out (Don't cut the emotion)
    this.masterGain.gain.cancelScheduledValues(this.ctx.currentTime);
    this.masterGain.gain.linearRampToValueAtTime(0, this.ctx.currentTime + 4);
  }

  loop() {
    const secondsPerBeat = 60 / this.tempo;
    const interval = (secondsPerBeat / 4) * 1000; // 16th notes

    this.timer = setTimeout(() => this.loop(), interval);

    const step = this.tickCount % 64; // Long phrases (4 bars of 4/4)

    // --- 1. THE BED (Orchestral Pads) ---
    // Change chord every bar (16 ticks)
    if (step % 16 === 0) {
        const chordIdx = Math.floor(step / 16);
        this.playChordPad(this.progression[chordIdx]);
        
        // Play a deep bass root on the change
        this.playBassRoot(this.progression[chordIdx].root);
    }

    // --- 2. THE SOLOIST (The Crying Violin) ---
    // Plays intuitively, not on grid.
    // Logic: Mostly long notes, occasional runs.
    
    // Try to play a note?
    if (step % 4 === 0) { // Check every beat
        const currentChord = this.progression[Math.floor(step / 16)];
        
        // Higher probability on beat 1, lower on others
        let prob = (step % 16 === 0) ? 0.9 : 0.4;
        
        // If we just played a note, lower chance (give it space to breathe)
        if (Math.random() < prob) {
            this.playSoloNote(currentChord);
        }
    }

    this.tickCount++;
  }

  // --- MUSIC THEORY ENGINE ---

  playChordPad(chord) {
    // Play a lush 3-note chord in the mid-range
    // Spread the voicing: Root, 5th, 3rd (Open voicing sounds "bigger")
    
    const rootPitch = this.rootFreq * Math.pow(2, chord.root / 12);
    
    // Voicing intervals relative to root
    let intervals;
    if (chord.type === 'minor') intervals = [0, 7, 15]; // Root, 5th, 10th (High min 3rd)
    else intervals = [0, 7, 16]; // Root, 5th, 10th (High maj 3rd)

    intervals.forEach((interval, i) => {
        // Stagger entries slightly so it doesn't sound like a block
        const delay = i * 0.1; 
        const freq = rootPitch * Math.pow(2, interval / 12);
        this.createPadVoice(freq, delay);
    });
  }

  playBassRoot(semitone) {
    const freq = (this.rootFreq / 2) * Math.pow(2, semitone / 12); // Octave down
    this.createPadVoice(freq, 0, 'bass');
  }

  playSoloNote(chord) {
    // Pick a "Beautiful" note relative to the chord
    // Target: 9th, 3rd, or 5th. Avoid Root (too boring).
    
    const rootPitch = this.rootFreq * Math.pow(2, chord.root / 12);
    
    // Intervals: 
    // 2 (9th) -> Very wistful
    // 3/4 (3rd) -> Emotional
    // 7 (5th) -> Soaring
    const options = (chord.type === 'minor') ? [2, 3, 7, 10] : [2, 4, 7, 11];
    const interval = options[Math.floor(Math.random() * options.length)];
    
    // Play high (Octave up)
    let freq = (rootPitch * 2) * Math.pow(2, interval / 12);

    // Duration: 1 to 3 beats
    const duration = 1.5 + Math.random() * 3.0;

    this.createSoloVoice(freq, duration);
  }

  // --- SOUND GENERATION (The "Beautiful" Part) ---

  createPadVoice(freq, delay, type = 'pad') {
    const t = this.ctx.currentTime + delay;
    const dur = 4.0; // Whole note + sustain

    const osc = this.ctx.createOscillator();
    const gain = this.ctx.createGain();
    const filter = this.ctx.createBiquadFilter();

    // SOUND DESIGN: TRIANGLE + DETUNE
    // Triangles are much softer/sadder than Saws
    osc.type = 'triangle';
    osc.frequency.value = freq;
    
    // Slight detune for "ensemble" feel
    osc.detune.value = (Math.random() * 10) - 5; 

    // Filter swells to simulate bowing intensity
    filter.type = 'lowpass';
    filter.frequency.value = 200; // Start dark
    filter.frequency.linearRampToValueAtTime(type === 'bass' ? 400 : 800, t + 2.0); // Swell
    filter.frequency.linearRampToValueAtTime(200, t + 4.0); // Fade

    // Envelope: Very slow attack (The "Pad" sound)
    gain.gain.setValueAtTime(0, t);
    gain.gain.linearRampToValueAtTime(type === 'bass' ? 0.3 : 0.1, t + 1.5); // 1.5s Attack
    gain.gain.linearRampToValueAtTime(0, t + dur); // Slow release

    osc.connect(filter);
    filter.connect(gain);
    gain.connect(this.masterGain);

    osc.start(t);
    osc.stop(t + dur + 1);
  }

  createSoloVoice(targetFreq, duration) {
    const t = this.ctx.currentTime;
    
    const osc = this.ctx.createOscillator();
    const gain = this.ctx.createGain();
    const vibrato = this.ctx.createOscillator();
    const vibratoGain = this.ctx.createGain();

    // SOUND DESIGN: SOLO VIOLIN
    // Sawtooth filtered heavily creates a "reed/string" tone
    osc.type = 'sawtooth';
    
    // PORTAMENTO (The "Cry")
    // If we have a previous note, slide from it. If not, slide from slightly below.
    let startFreq = this.lastMelodyFreq || (targetFreq * 0.9); 
    osc.frequency.setValueAtTime(startFreq, t);
    // Emotional Slide: Takes 0.3s to reach pitch (Legato)
    osc.frequency.exponentialRampToValueAtTime(targetFreq, t + 0.3);
    
    this.lastMelodyFreq = targetFreq; // Remember for next time

    // VIBRATO (The "Human" Shiver)
    vibrato.frequency.value = 5.0; // 5Hz
    vibratoGain.gain.value = 0; // Start with no vibrato
    // Delay vibrato: Musicians usually play the note straight, then add vibrato
    vibratoGain.gain.setTargetAtTime(10, t + 0.5, 0.5); 
    
    vibrato.connect(vibratoGain);
    vibratoGain.connect(osc.frequency);
    vibrato.start(t);

    // FILTER (Formant-ish)
    const filter = this.ctx.createBiquadFilter();
    filter.type = 'lowpass';
    filter.Q.value = 3; // Resonance emphasizes the pitch center
    filter.frequency.value = targetFreq * 2; // Harmonics

    // AMPLITUDE ENVELOPE
    gain.gain.setValueAtTime(0, t);
    gain.gain.linearRampToValueAtTime(0.2, t + 0.4); // Soft attack
    gain.gain.setValueAtTime(0.2, t + duration - 0.5); // Sustain
    gain.gain.linearRampToValueAtTime(0, t + duration); // Release

    osc.connect(filter);
    filter.connect(gain);
    gain.connect(this.masterGain);

    osc.start(t);
    osc.stop(t + duration + 0.2);
    vibrato.stop(t + duration + 0.2);
  }
}
///////////////////////////////////////////////////////////////////
///////////////MAIN GAME LOOP//////////////////////////////
///////////////////////////////////////////////////////////////////
function drawField(){
  //////////////main game timer///////
  let now = Date.now();
  let dt = (now - lastFrameTime) / 1000; 
  lastFrameTime = now;
  if (dt > 0.1) dt = 0.1; // Safety cap
  //x,y,z,l,h,type='frame',visible = 1
  
  ////////////////////////////////////
  if (startGame == 0){//intro message
    ctx.fillStyle = "rgba(0,6,13,1)";
    ctx.fillRect(0,0,wX,wY);
    //draw a new portrait every 3 secs
    if (now - lastTriggerTime > 3000) {
        lastrandom = rnd(0,21)
        lastTriggerTime = now;
    }
    else {
      drawPortrait(lastrandom,2.5,2.5,.5);
      drawShape('rec',1.9,2.9,1,5,5,0,0,0,0,0,0,'gold',0);
    }
    //page text
    drawText(2, .25, 10, .5, "To those who would test fate...", `rgba(${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)})`, 1);
    drawText(0.25, 1.5, 10, 1, "Do you have the stones to play?", `rgba(${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)})`, 1);
    drawText(2.5, 8.5, 8, 0.8, "Tap to continue", `rgba(60,60,60,${0.6 + 0.4 * Math.sin(Date.now() / 400)})`, 1);
  }
  else if (startGame == 1){//suncat studios 
    ctx.fillStyle = "rgba(0,6,13,1)";
	  ctx.fillRect(0,0,wX,wY);
    //music timer
    if (!MusicEngine.isPlaying()) {
        console.log("Audio failsafe triggered: Restarting music...");
        
        // Optional: Force resume if suspended (browsers sometimes suspend if user clicks too fast)
        if (MusicEngine.ctx && MusicEngine.ctx.state === 'suspended') {
            MusicEngine.ctx.resume();
        }
        
        // Pick a song and play
        song = rnd(0, 21); 
        MusicEngine.play(song); 
        lastSongTime = now; // Reset timer so it doesn't skip immediately
    }
    if (now - lastSongTime > 60000) {
      MusicEngine.stop();
      MusicEngine.play(rnd(0,21));
      lastSongTime = now;
    }
    //dice formation
    Player.d4.animate(5,1,1,1,dt);
    Player.d6.animate(2,2,1,1,dt);
    Player.d8.animate(8,2,1,1,dt);
    Player.d10.animate(2,6.5,1,1,dt);
    Player.d12.animate(8,6.5,1,1,dt);
    Player.d20.animate(5,7.5,1,1,dt);
    //Coin animation
    if (now - lastTriggerTime > 100) {
      lastTriggerTime = now;
      coinswitch = rnd(0,9)
      if (coinswitch == 0){
        coinanix = coinanix- .1;
        coinaniy = coinaniy - .1;
        coinaniz = coinaniz -.1;
      }
      if (coinswitch == 1){
        coinanix = coinanix + .1;
        coinaniy = coinaniy + .1;
        coinaniz = coinaniz + .1;
      }
      if (coinswitch == 2){
        coinanix = coinanix - .1;
        coinaniy = coinaniy + .1;
        coinaniz = coinaniz + .1;
      }
      if (coinswitch == 3){
        coinanix = coinanix + .1;
        coinaniy = coinaniy - .1;
        coinaniz = coinaniz + .1;
      }
      if (coinswitch == 4){
        coinanix = coinanix + .1;
        coinaniy = coinaniy + .1;
        coinaniz = coinaniz - .1;
      }
      if (coinswitch == 5){
        coinanix = coinanix - .1;
        coinaniy = coinaniy - .1;
        coinaniz = coinaniz + .1;
      }
      if (coinswitch == 8){
        coinanix = coinanix - .1;
        coinaniy = coinaniy + .1;
        coinaniz = coinaniz - .1;
      }
      if (coinswitch == 9){
        coinanix = coinanix + .1;
        coinaniy = coinaniy - .1;
        coinaniz = coinaniz - .1;
      }
      coinanir = coinanir + rnd(-1,1);
      Player.d2.animate(coinanix,coinaniy,coinaniz,coinanir,dt);
    }
    else { Player.d2.animate(coinanix,coinaniy,coinaniz,coinanir,dt);}
    //page text
    drawText(4.8, 2.5, 9, 0.6, "A", "rgba(100,100,100,1)", 1);
    drawText(0.05, 3.5, 10, 2.0, "SUNCAT STUDIO", `rgba(${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)})`, 1);
    drawText(3.25, 5.5, 9, 0.6, "PRODUCTION", "rgba(100,100,100,1)", 1);
    drawText(2.5, 8.5, 8, 0.8, "Tap to continue", `rgba(60,60,60,${0.6 + 0.4 * Math.sin(Date.now() / 400)})`, 1);
  }
  else if (startGame == 2){//runestones tcg
	//musictimer
  if (now - lastSongTime > 90000) {
    MusicEngine.stop();
    MusicEngine.play(rnd(0,21))
    lastSongTime = now;
  }
	ctx.fillStyle = "rgba(0,6,13,1)";
	ctx.fillRect(0,0,wX,wY);
  drawPortrait(-4,1,1.25,.15)//sword
  drawPortrait(-5,3,1.25,.15)//wand
  drawPortrait(-6,5.45,1.25,.15)////shield
  drawPortrait(-7,7.63,1.25,.15)////hourglass
  drawText(.1,3.5,10,2,"Runestones TCG",`rgba(${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)})`,1);
  drawText(3.05, 5.5, 9, 0.6, "DIGITAL DEMO", "rgba(100,100,100,1)", 1);
  drawText(3,7.5,8,.8,"Tap to start",`rgba(60,60,60,${0.6 + 0.4 * Math.sin(Date.now() / 400)})`,1);
}
  else if (startGame == 3){//selection screen
    ctx.fillStyle = "rgba(0,6,13,1)";
	  ctx.fillRect(0,0,wX,wY);
    //music timer
    if (now - lastSongTime > 90000) {
      MusicEngine.stop();
      MusicEngine.play(rnd(0,21))
      lastSongTime = now;
    }  
    //4 suit symbols
    drawPortrait(-4,1,1.25,.15)//sword
    drawPortrait(-5,3,1.25,.15)//wand
    drawPortrait(-6,5.45,1.25,.15)////shield
    drawPortrait(-7,7.63,1.25,.15)////hourglass
    //page text
    drawText(.1,3.5,10,2,"Runestones TCG",`rgba(${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)})`,1);
    drawText(3.05, 5.5, 9, 0.6, "DIGITAL DEMO", "rgba(100,100,100,1)", 1);
    drawText(1.25,7,8,.8,"vs CPU",`rgba(60,60,60,${0.6 + 0.4 * Math.sin(Date.now() / 400)})`,1);
    drawText(6.25,7,8,.8,"vs Local",`rgba(60,60,60,${0.6 + 0.4 * Math.sin(Date.now() / 400)})`,1);
    drawText(1.25,8.75,8,.8,"Tutorial",`rgba(60,60,60,${0.6 + 0.4 * Math.sin(Date.now() / 400)})`,1);
    drawText(6.25,8.75,8,.8,"Jukebox",`rgba(60,60,60,${0.6 + 0.4 * Math.sin(Date.now() / 400)})`,1);

}
  else if (startGame > 3){//main game loop
    //standby and after battle
    if ((Player.option <= 5 && Foe.option <= 5) || (Player.option > 8 || Foe.option > 8)){
      //draw padding
	    ctx.fillStyle = "rgba(39,39,39,1)";
	    ctx.fillRect(0,0,wX,wY);
	    //draw table
	    ctx.fillStyle = "rgba(0,6,13,1)";
	    ctx.fillRect(tX,tY,tL,tH);
  
	    //REFRESH PLAYER AND FOE FIELDS
      Player.refresh(dt);
	    Foe.refresh(dt);
      sRune.refresh(dt);
      cRune.refresh(dt);
      iRune.refresh(dt);
      aRune.refresh(dt);
    }
    //during battle
    if ((Player.option > 5 && Foe.option > 5) && (Player.option <= 8 || Foe.option <= 8)){
	    //draw padding
	    ctx.fillStyle = "rgba(39,39,39,1)";
	    ctx.fillRect(0,0,wX,wY);
	    //draw table
	    ctx.fillStyle = "rgba(0,6,13,1)";
	    ctx.fillRect(tX,tY,tL,tH);
      sRune.refresh(dt);
      cRune.refresh(dt);
      iRune.refresh(dt);
      aRune.refresh(dt);
      drawShape('rec',0,0,1,0,0,10,10,0,0,0,0,'rgba(0,0,0,.9)',1);
	  //REFRESH PLAYER AND FOE FIELDS
    }
    //react handles player input throughout options
    Player.react(dt);
    Foe.react(dt);
  
  }//end else startgame == 1
  else if (startGame == 'explore'||startGame == 'battle'||startGame == 'dialogue'||startGame == 'tutorial'){
    debug = 0;
    ctx.fillStyle = "rgba(0,6,13,1)";
    ctx.fillRect(0,0,wX,wY);
    Dungeon.render();
    if(startGame == 'battle'){
      Dungeon.battle(); 
    }
    else if(startGame == 'dialogue'){ // NEW
      Dungeon.dialogue();
    }
    else if(startGame == 'tutorial'){ // NEW
      Dungeon.tutorial(dt);
      if (now - lastTriggerTime > 5000) {
        //intro to monsters and attack
        if (Dungeon.option == 7 && ( (Dungeon.dCounter >0 && Dungeon.dCounter <2) || (Dungeon.dCounter >2 &&Dungeon.dCounter <= 3) || (Dungeon.dCounter >4 && Dungeon.dCounter <6) ) ){}
        else{
        if (Dungeon.dCounter != 6 ||Dungeon.option == 6||Dungeon.option == 7||Dungeon.option == 9){Dungeon.dCounter = Dungeon.dCounter + 1;}
        }
        //Agility tutotial
        if(Dungeon.option == 4&&Dungeon.at >= 36){Dungeon.at = Dungeon.at + 1;}
        if(Dungeon.option == 4&&Dungeon.at == 31){Dungeon.at = 36;}
        //fool attacks, high priestess defends, fool is slain
        if(Dungeon.option == 5&&Dungeon.at >= 75){Dungeon.at = Dungeon.at + 1;}
        if(Dungeon.option == 5&&Dungeon.at == 69){Dungeon.at = 76;}
        //Agility ROUND 2 
        if(Dungeon.option == 8&&Dungeon.at >= 36){Dungeon.at = Dungeon.at + 1;}
        if(Dungeon.option == 8&&Dungeon.at == 31){Dungeon.at = 36;}
        lastTriggerTime = now;
        }
    }
  }
  else if(startGame == 'jukebox'){
    ctx.fillStyle = "rgba(0,6,13,1)";
	  ctx.fillRect(0,0,wX,wY);
    //Coin animation
    if (now - lastTriggerTime > 100) {
      lastTriggerTime = now;
      coinswitch = rnd(0,9)
      if (coinswitch == 0){
        coinanix = coinanix- .1;
        coinaniy = coinaniy - .1;
        coinaniz = coinaniz -.1;
      }
      if (coinswitch == 1){
        coinanix = coinanix + .1;
        coinaniy = coinaniy + .1;
        coinaniz = coinaniz + .1;
      }
      if (coinswitch == 2){
        coinanix = coinanix - .1;
        coinaniy = coinaniy + .1;
        coinaniz = coinaniz + .1;
      }
      if (coinswitch == 3){
        coinanix = coinanix + .1;
        coinaniy = coinaniy - .1;
        coinaniz = coinaniz + .1;
      }
      if (coinswitch == 4){
        coinanix = coinanix + .1;
        coinaniy = coinaniy + .1;
        coinaniz = coinaniz - .1;
      }
      if (coinswitch == 5){
        coinanix = coinanix - .1;
        coinaniy = coinaniy - .1;
        coinaniz = coinaniz + .1;
      }
      if (coinswitch == 8){
        coinanix = coinanix - .1;
        coinaniy = coinaniy + .1;
        coinaniz = coinaniz - .1;
      }
      if (coinswitch == 9){
        coinanix = coinanix + .1;
        coinaniy = coinaniy - .1;
        coinaniz = coinaniz - .1;
      }
      coinanir = coinanir + rnd(-1,1);
      Player.d2.animate(coinanix,coinaniy,coinaniz,coinanir,dt);
    }
    else { 
      Player.d2.animate(coinanix,coinaniy,coinaniz,coinanir,dt);
    }
    //portrait animation
    if (now - lastTriggerTime2 > 10000) {
      lastrandom = rnd(0,21)
      lastTriggerTime2 = now;
    }
    else {
      drawPortrait(lastrandom,2.5,5,.5);
      
    }

    if (song == 'shuffle'){
      if (now - lastSongTime > 60000) {
      MusicEngine.stop();
      cursong = rnd(0,21);
      MusicEngine.play(cursong);
      lastSongTime = now;
    }
    drawText(4.1, 2.8, 9, 0.6, cursong + ' / 21', "rgba(100,100,100,1)", 1);
    drawText(4.075, 1.5, 9, 0.6, 'Shuffle', "rgba(100,100,100,1)", 1);
    }else{
      drawText(4.1, 2.8, 9, 0.6, song + ' / 21', "rgba(100,100,100,1)", 1)
    }
    

    drawText(4, .5, 9, 0.6, "Jukebox", "rgba(100,100,100,1)", 1);
    drawText(0, 8.75, 2, 1, '<<Back', "rgba(100,100,100,1)", 1);
    drawPortrait(-1,1,3,.2);
    drawPortrait(-2,7,3,.2);
    MessageBox.show(4.35,3.37,1,1.25,1.25,'','jrpg_btn',1,0)
  }
  requestAnimationFrame(drawField);
  
  if (debug == 2){
    ctx.fillStyle = "rgba(0,6,13,1)";
    ctx.fillRect(0,0,wX,wY);
	  drawPortrait(18,0,0,1);
    //drawText(7.7,8,2,2,''+Player.at,'white',1);
  }
  if (debug == 1 || debug == 2){
	  for(h=0;h<20;h++){ //grid lines
		  drawShape('lin',0,0,.5,h,0,h,20,0,0,0,0,'green',0);
		  drawShape('lin',0,0,.5,0,h,20,h,0,0,0,0,'green',0);
      if (h < 10){    
        drawText(h-.25,0,.5,.5,'' + (h),'blue',1);
        drawText(-.25,h,.5,.5,'' + (h),'blue',1); 
      }
      if (h%2 == 0){
        drawShape('lin',0,0,.5,h,0,h,20,0,0,0,0,'red',0);
        drawShape('lin',0,0,.5,0,h,20,h,0,0,0,0,'red',0);
      }
	  }
   // drawText(8,2,2,1,'Dir:' + Dungeon.dir,'white',1)
  }
  if (debug == 3){
    if (now - lastSongTime > 90000) {
      MusicEngine.stop();
      MusicEngine.play(rnd(0,21))
      lastSongTime = now;
    }  
	  for(h=0;h<10;h++){ //grid lines
		  drawShape('lin',0,0,1,0,h,5,5, 0,0,0,0,'green',0);//x line
		  drawShape('lin',0,0,1,10,h,5,5,0,0,0,0,'green',0);
      
      
        drawShape('lin',0,0,1,h,0,5,5,0,0,0,0,'red',0);
        drawShape('lin',0,0,1,h,10,5,5,0,0,0,0,'red',0);
      
	  }
  }
  /*
  if (MessageBox.visible == 1){
    MessageBox.show(MessageBox.x + dt,2,MessageBox.z-dt*.1,2,2,'frame',1,3,3,2)
    if (MessageBox.x+MessageBox.l*MessageBox.z >= 10){
      MessageBox.show(MessageBox.originx,2,MessageBox.z,2,2,'frame',1,3,3,2)
      MessageBox.visible = 2;
    }
  }
  if (MessageBox.visible == 2){
    MessageBox.show(MessageBox.originx,2,MessageBox.z - dt*.1,2,2,'frame',1,3,3,2)
    if (MessageBox.z <=0){
      MessageBox.show(MessageBox.originx,2,MessageBox.originz,2,2,'frame',1,3,3,2)
      MessageBox.visible = 3
    }
  }
  if (MessageBox.visible == 3){
    MessageBox.show(MessageBox.originx,2,MessageBox.originz,2,2,'frame',1,3,3,2)
  }*/
  
}//END FUNCTION
/////////////////////[END MAIN GAME LOOP]////////////////////////
debug = 0;
////////////////////////[FUNCTION CALLS]//////////////////////////
drawField();//starts the game loop
/////////////////////////[END OF SCRIPT]//////////////////////////
</script>
</body>
</html>>